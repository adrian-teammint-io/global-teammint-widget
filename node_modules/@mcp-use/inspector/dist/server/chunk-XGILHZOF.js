import {
  formatErrorResponse
} from "./chunk-JCLAFMDT.js";
import {
  rpcLogBus
} from "./chunk-CVECQ7BJ.js";
import {
  generateWidgetContainerHtml,
  generateWidgetContentHtml,
  getWidgetData,
  getWidgetSecurityHeaders,
  handleChatRequest,
  handleChatRequestStream,
  storeWidgetData
} from "./chunk-MCMZDGO6.js";

// src/server/shared-routes.ts
import { logger } from "hono/logger";
function registerInspectorRoutes(app, config) {
  app.get("/inspector/health", (c) => {
    return c.json({ status: "ok", timestamp: (/* @__PURE__ */ new Date()).toISOString() });
  });
  app.use("/inspector/api/proxy/*", logger());
  app.all("/inspector/api/proxy/*", async (c) => {
    try {
      const targetUrl = c.req.header("X-Target-URL");
      if (!targetUrl) {
        return c.json({ error: "X-Target-URL header is required" }, 400);
      }
      const method = c.req.method;
      const headers = {};
      const requestHeaders = c.req.header();
      for (const [key, value] of Object.entries(requestHeaders)) {
        const lowerKey = key.toLowerCase();
        if (!lowerKey.startsWith("x-proxy-") && !lowerKey.startsWith("x-target-") && lowerKey !== "host" && lowerKey !== "accept-encoding") {
          headers[key] = value;
        }
      }
      headers["Accept-Encoding"] = "identity";
      try {
        const targetUrlObj = new URL(targetUrl);
        headers.Host = targetUrlObj.host;
      } catch {
        return c.json({ error: "Invalid target URL" }, 400);
      }
      const body = method !== "GET" && method !== "HEAD" ? await c.req.arrayBuffer() : void 0;
      const response = await fetch(targetUrl, {
        method,
        headers,
        body: body ? new Uint8Array(body) : void 0
      });
      const responseHeaders = {};
      response.headers.forEach((value, key) => {
        const lowerKey = key.toLowerCase();
        if (lowerKey !== "content-encoding" && lowerKey !== "transfer-encoding" && lowerKey !== "content-length") {
          responseHeaders[key] = value;
        }
      });
      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers: responseHeaders
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      console.error("Proxy request failed:", message, error);
      return c.json({ error: "Proxy request failed", details: message }, 500);
    }
  });
  app.post("/inspector/api/chat/stream", async (c) => {
    try {
      const requestBody = await c.req.json();
      const { readable, writable } = new globalThis.TransformStream();
      const writer = writable.getWriter();
      const encoder = new TextEncoder();
      (async () => {
        try {
          for await (const chunk of handleChatRequestStream(requestBody)) {
            await writer.write(encoder.encode(chunk));
          }
        } catch (error) {
          const errorMsg = `${JSON.stringify({
            type: "error",
            data: {
              message: error instanceof Error ? error.message : "Unknown error"
            }
          })}
`;
          await writer.write(encoder.encode(errorMsg));
        } finally {
          await writer.close();
        }
      })();
      return new Response(readable, {
        headers: {
          "Content-Type": "text/event-stream",
          "Cache-Control": "no-cache",
          Connection: "keep-alive"
        }
      });
    } catch (error) {
      return c.json(formatErrorResponse(error, "handleChatRequestStream"), 500);
    }
  });
  app.post("/inspector/api/chat", async (c) => {
    try {
      const requestBody = await c.req.json();
      const result = await handleChatRequest(requestBody);
      return c.json(result);
    } catch (error) {
      return c.json(formatErrorResponse(error, "handleChatRequest"), 500);
    }
  });
  app.post("/inspector/api/resources/widget/store", async (c) => {
    try {
      const body = await c.req.json();
      const result = storeWidgetData(body);
      if (!result.success) {
        return c.json(result, 400);
      }
      return c.json(result);
    } catch (error) {
      console.error("[Widget Store] Error:", error);
      console.error(
        "[Widget Store] Stack:",
        error instanceof Error ? error.stack : ""
      );
      return c.json(formatErrorResponse(error, "storeWidgetData"), 500);
    }
  });
  app.get("/inspector/api/resources/widget/:toolId", async (c) => {
    const toolId = c.req.param("toolId");
    const widgetData = getWidgetData(toolId);
    if (!widgetData) {
      return c.html(
        "<html><body>Error: Widget data not found or expired</body></html>",
        404
      );
    }
    return c.html(generateWidgetContainerHtml("/inspector", toolId));
  });
  app.get("/inspector/api/resources/widget-content/:toolId", async (c) => {
    try {
      const toolId = c.req.param("toolId");
      const widgetData = getWidgetData(toolId);
      if (!widgetData) {
        console.error(
          "[Widget Content] Widget data not found for toolId:",
          toolId
        );
        return c.html(
          "<html><body>Error: Widget data not found or expired</body></html>",
          404
        );
      }
      const result = generateWidgetContentHtml(widgetData);
      if (result.error) {
        return c.html(`<html><body>Error: ${result.error}</body></html>`, 404);
      }
      const headers = getWidgetSecurityHeaders(widgetData.widgetCSP);
      Object.entries(headers).forEach(([key, value]) => {
        c.header(key, value);
      });
      return c.html(result.html);
    } catch (error) {
      console.error("[Widget Content] Error:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      const errorStack = error instanceof Error ? error.stack : "";
      console.error("[Widget Content] Stack:", errorStack);
      return c.html(`<html><body>Error: ${errorMessage}</body></html>`, 500);
    }
  });
  app.get("/inspector/api/dev-widget/:toolId", async (c) => {
    try {
      const toolId = c.req.param("toolId");
      const widgetData = getWidgetData(toolId);
      if (!widgetData?.devWidgetUrl || !widgetData?.devServerBaseUrl) {
        return c.html(
          "<html><body>Error: Dev widget data not found or expired</body></html>",
          404
        );
      }
      const response = await fetch(widgetData.devWidgetUrl);
      if (!response.ok) {
        const status = response.status;
        return c.html(
          `<html><body>Error: Failed to fetch widget from dev server (${response.status})</body></html>`,
          status
        );
      }
      let html = await response.text();
      const modifiedWidgetData = {
        ...widgetData,
        resourceData: {
          contents: [{ text: html }]
        }
      };
      const result = generateWidgetContentHtml(modifiedWidgetData);
      if (result.error) {
        return c.html(`<html><body>Error: ${result.error}</body></html>`, 500);
      }
      html = result.html;
      const proxyBase = `/inspector/api/dev-widget/${toolId}/assets`;
      const widgetNameMatch = widgetData.devWidgetUrl?.match(
        /\/mcp-use\/widgets\/([^/?]+)/
      );
      const widgetName = widgetNameMatch ? widgetNameMatch[1] : "widget";
      const escapedBaseUrl = widgetData.devServerBaseUrl.replace(
        /[.*+?^${}()|[\]\\]/g,
        "\\$&"
      );
      html = html.replace(
        new RegExp(
          `(src|href)="(${escapedBaseUrl}/mcp-use/widgets/[^"]+)"`,
          "g"
        ),
        (_match, attr, url) => {
          const path = url.replace(widgetData.devServerBaseUrl, "");
          return `${attr}="${proxyBase}${path}"`;
        }
      );
      html = html.replace(
        /(src|href)="(\/mcp-use\/widgets\/[^"]+)"/g,
        (_match, attr, path) => {
          return `${attr}="${widgetData.devServerBaseUrl}${path}"`;
        }
      );
      html = html.replace(/(src|href)="\.\/([^"]+)"/g, (match, attr, path) => {
        if (path.match(/\.(js|css|png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot)$/i)) {
          return `${attr}="${proxyBase}/mcp-use/widgets/${widgetName}/${path}"`;
        }
        return match;
      });
      if (widgetData.devServerBaseUrl) {
        const devServerUrl = new URL(widgetData.devServerBaseUrl);
        const wsProtocol = devServerUrl.protocol === "https:" ? "wss" : "ws";
        const wsHost = devServerUrl.host;
        const directWsUrl = `${wsProtocol}://${wsHost}/mcp-use/widgets/`;
        const baseTag = `<base href="${widgetData.devServerBaseUrl}/mcp-use/widgets/${widgetName}/">`;
        const cspWarningScript = `
    <script>
      // Listen for CSP violations (from Report-Only policy)
      document.addEventListener('securitypolicyviolation', (e) => {
        // Only warn about report-only violations (not enforced ones)
        if (e.disposition === 'report') {
          console.warn(
            '%c\u26A0\uFE0F CSP Warning: Resource would be blocked in production',
            'color: orange; font-weight: bold',
            '\\n  Blocked URL:', e.blockedURI,
            '\\n  Directive:', e.violatedDirective,
            '\\n  Policy:', e.originalPolicy,
            '\\n\\n\u2139\uFE0F To fix: Add this domain to your widget\\'s CSP configuration in appsSdkMetadata[\\'openai/widgetCSP\\']'
          );
        }
      });
    </script>`;
        const viteConfigScript = `
    <script>
      // Configure Vite HMR to connect directly to dev server
      window.__vite_ws_url__ = "${directWsUrl}";
    </script>`;
        html = html.replace(/<head>/i, `<head>
    ${baseTag}`);
        html = html.replace(
          /<script/,
          cspWarningScript + viteConfigScript + "\n    <script"
        );
      }
      const headers = getWidgetSecurityHeaders(
        widgetData.widgetCSP,
        widgetData.devServerBaseUrl
      );
      Object.entries(headers).forEach(([key, value]) => {
        c.header(key, value);
      });
      return c.html(html);
    } catch (error) {
      console.error("[Dev Widget Proxy] Error:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      return c.html(`<html><body>Error: ${errorMessage}</body></html>`, 500);
    }
  });
  app.get("/inspector/api/dev-widget/:toolId/assets/*", async (c) => {
    try {
      const toolId = c.req.param("toolId");
      const assetPath = c.req.path.replace(
        `/inspector/api/dev-widget/${toolId}/assets`,
        ""
      );
      const widgetData = getWidgetData(toolId);
      if (!widgetData?.devServerBaseUrl) {
        return c.notFound();
      }
      const devAssetUrl = `${widgetData.devServerBaseUrl}${assetPath}`;
      const response = await fetch(devAssetUrl, {
        headers: {
          Accept: c.req.header("Accept") || "*/*"
        }
      });
      if (!response.ok) {
        return c.notFound();
      }
      const contentType = response.headers.get("Content-Type") || "application/octet-stream";
      const headers = {
        "Content-Type": contentType
      };
      const cacheControl = response.headers.get("Cache-Control");
      if (cacheControl) {
        headers["Cache-Control"] = cacheControl;
      }
      return new Response(response.body, {
        status: response.status,
        headers
      });
    } catch (error) {
      console.error("[Dev Widget Asset Proxy] Error:", error);
      return c.notFound();
    }
  });
  app.get("/inspector/config.json", (c) => {
    return c.json({
      autoConnectUrl: config?.autoConnectUrl || null
    });
  });
  app.post("/inspector/api/tel/posthog", async (c) => {
    try {
      const body = await c.req.json();
      const { event, user_id, properties } = body;
      if (!event) {
        return c.json({ success: false, error: "Missing event name" }, 400);
      }
      const { PostHog } = await import("posthog-node");
      const posthog = new PostHog(
        "phc_lyTtbYwvkdSbrcMQNPiKiiRWrrM1seyKIMjycSvItEI",
        {
          host: "https://eu.i.posthog.com"
        }
      );
      const distinctId = user_id || "anonymous";
      posthog.capture({
        distinctId,
        event,
        properties: properties || {}
      });
      await posthog.shutdown();
      return c.json({ success: true });
    } catch (error) {
      console.error("[Telemetry] Error forwarding to PostHog:", error);
      return c.json({ success: false });
    }
  });
  app.post("/inspector/api/tel/scarf", async (c) => {
    try {
      const body = await c.req.json();
      const response = await fetch(
        "https://mcpuse.gateway.scarf.sh/events-inspector",
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(body)
        }
      );
      if (!response.ok) {
        console.error("[Telemetry] Scarf request failed:", response.status);
        return c.json({
          success: false,
          status: response.status,
          error: response.statusText
        });
      }
      return c.json({ success: true });
    } catch (error) {
      console.error("[Telemetry] Error forwarding to Scarf:", error);
      return c.json({ success: false });
    }
  });
  app.post("/inspector/api/rpc/log", async (c) => {
    try {
      const event = await c.req.json();
      rpcLogBus.publish(event);
      return c.json({ success: true });
    } catch (error) {
      console.error("[RPC Log] Error receiving RPC event:", error);
      return c.json({ success: false });
    }
  });
  app.delete("/inspector/api/rpc/log", async (c) => {
    try {
      const url = new URL(c.req.url);
      const serverIdsParam = url.searchParams.get("serverIds");
      const serverIds = serverIdsParam ? serverIdsParam.split(",").filter(Boolean) : void 0;
      rpcLogBus.clear(serverIds);
      return c.json({ success: true });
    } catch (error) {
      console.error("[RPC Log] Error clearing RPC log:", error);
      return c.json({ success: false });
    }
  });
  app.get("/inspector/api/rpc/stream", async (c) => {
    const url = new URL(c.req.url);
    const replay = parseInt(url.searchParams.get("replay") || "3", 10);
    const serverIdsParam = url.searchParams.get("serverIds");
    const serverIds = serverIdsParam ? serverIdsParam.split(",").filter(Boolean) : [];
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      start(controller) {
        const send = (data) => {
          try {
            controller.enqueue(
              encoder.encode(`data: ${JSON.stringify(data)}

`)
            );
          } catch {
          }
        };
        try {
          const recent = rpcLogBus.getBuffer(
            serverIds,
            isNaN(replay) ? 3 : replay
          );
          for (const evt of recent) {
            send({ type: "rpc", ...evt });
          }
        } catch {
        }
        const unsubscribe = rpcLogBus.subscribe(
          serverIds,
          (evt) => {
            send({ type: "rpc", ...evt });
          }
        );
        const keepalive = setInterval(() => {
          try {
            controller.enqueue(encoder.encode(`: keepalive ${Date.now()}

`));
          } catch {
          }
        }, 15e3);
        c.req.raw.signal?.addEventListener("abort", () => {
          try {
            clearInterval(keepalive);
            unsubscribe();
          } catch {
          }
          try {
            controller.close();
          } catch {
          }
        });
      }
    });
    return new Response(stream, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Expose-Headers": "*"
      }
    });
  });
}

export {
  registerInspectorRoutes
};
