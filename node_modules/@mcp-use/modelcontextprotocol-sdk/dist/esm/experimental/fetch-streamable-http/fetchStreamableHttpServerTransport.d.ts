/**
 * Web Standards Streamable HTTP Server Transport
 *
 * This is an experimental transport that implements the MCP Streamable HTTP specification
 * using Web Standard APIs (Request, Response, TransformStream) instead of Node.js HTTP.
 *
 * @see https://github.com/modelcontextprotocol/typescript-sdk/issues/260
 * @experimental
 */
import { Transport } from '../../shared/transport.js';
import { MessageExtraInfo, JSONRPCMessage, RequestId } from '../../types.js';
export type StreamId = string;
export type EventId = string;
/**
 * Interface for resumability support via event storage
 */
export interface EventStore {
    /**
     * Stores an event for later retrieval
     * @param streamId ID of the stream the event belongs to
     * @param message The JSON-RPC message to store
     * @returns The generated event ID for the stored event
     */
    storeEvent(streamId: StreamId, message: JSONRPCMessage): Promise<EventId>;
    /**
     * Get the stream ID associated with a given event ID.
     * @param eventId The event ID to look up
     * @returns The stream ID, or undefined if not found
     *
     * Optional: If not provided, the SDK will use the streamId returned by
     * replayEventsAfter for stream mapping.
     */
    getStreamIdForEventId?(eventId: EventId): Promise<StreamId | undefined>;
    replayEventsAfter(lastEventId: EventId, { send }: {
        send: (eventId: EventId, message: JSONRPCMessage) => Promise<void>;
    }): Promise<StreamId>;
}
/**
 * Session state that can be persisted externally for serverless deployments.
 */
export interface SessionState {
    /** Whether the session has completed initialization */
    initialized: boolean;
    /** The negotiated protocol version */
    protocolVersion: string;
    /** Timestamp when the session was created */
    createdAt: number;
}
/**
 * Interface for session storage in distributed/serverless deployments.
 *
 * In serverless environments (Lambda, Vercel, Cloudflare Workers), each request
 * may be handled by a different instance with no shared memory. The SessionStore
 * allows session state to be persisted externally (e.g., Redis, DynamoDB, KV).
 *
 * @example
 * ```typescript
 * // Cloudflare KV implementation
 * class KVSessionStore implements SessionStore {
 *   constructor(private kv: KVNamespace) {}
 *
 *   async get(sessionId: string) {
 *     return this.kv.get(`session:${sessionId}`, 'json');
 *   }
 *   async save(sessionId: string, state: SessionState) {
 *     await this.kv.put(`session:${sessionId}`, JSON.stringify(state), { expirationTtl: 3600 });
 *   }
 *   async delete(sessionId: string) {
 *     await this.kv.delete(`session:${sessionId}`);
 *   }
 * }
 * ```
 */
export interface SessionStore {
    /**
     * Retrieve session state by ID.
     * @param sessionId The session ID to look up
     * @returns The session state, or undefined if not found
     */
    get(sessionId: string): Promise<SessionState | undefined>;
    /**
     * Save session state.
     * Called when a session is initialized or updated.
     * @param sessionId The session ID
     * @param state The session state to persist
     */
    save(sessionId: string, state: SessionState): Promise<void>;
    /**
     * Delete session state.
     * Called when a session is explicitly closed via DELETE request.
     * @param sessionId The session ID to delete
     */
    delete(sessionId: string): Promise<void>;
}
/**
 * Configuration options for FetchStreamableHTTPServerTransport
 */
export interface FetchStreamableHTTPServerTransportOptions {
    /**
     * Function that generates a session ID for the transport.
     * The session ID SHOULD be globally unique and cryptographically secure (e.g., a securely generated UUID, a JWT, or a cryptographic hash)
     *
     * Return undefined to disable session management.
     */
    sessionIdGenerator: (() => string) | undefined;
    /**
     * A callback for session initialization events
     * This is called when the server initializes a new session.
     * Useful in cases when you need to register multiple mcp sessions
     * and need to keep track of them.
     * @param sessionId The generated session ID
     */
    onsessioninitialized?: (sessionId: string) => void | Promise<void>;
    /**
     * A callback for session close events
     * This is called when the server closes a session due to a DELETE request.
     * Useful in cases when you need to clean up resources associated with the session.
     * Note that this is different from the transport closing, if you are handling
     * HTTP requests from multiple nodes you might want to close each
     * WSStreamableHTTPServerTransport after a request is completed while still keeping the
     * session open/running.
     * @param sessionId The session ID that was closed
     */
    onsessionclosed?: (sessionId: string) => void | Promise<void>;
    /**
     * If true, the server will return JSON responses instead of starting an SSE stream.
     * This can be useful for simple request/response scenarios without streaming.
     * Default is false (SSE streams are preferred).
     */
    enableJsonResponse?: boolean;
    /**
     * Event store for resumability support
     * If provided, resumability will be enabled, allowing clients to reconnect and resume messages
     */
    eventStore?: EventStore;
    /**
     * List of allowed host header values for DNS rebinding protection.
     * If not specified, host validation is disabled.
     */
    allowedHosts?: string[];
    /**
     * List of allowed origin header values for DNS rebinding protection.
     * If not specified, origin validation is disabled.
     */
    allowedOrigins?: string[];
    /**
     * Enable DNS rebinding protection (requires allowedHosts and/or allowedOrigins to be configured).
     * Default is false for backwards compatibility.
     */
    enableDnsRebindingProtection?: boolean;
    /**
     * Retry interval in milliseconds to suggest to clients in SSE retry field.
     * When set, the server will send a retry field in SSE priming events to control
     * client reconnection timing for polling behavior.
     */
    retryInterval?: number;
    /**
     * Session store for distributed/serverless deployments.
     *
     * When provided, session state will be persisted externally, allowing the transport
     * to work across multiple serverless function invocations or instances.
     *
     * If not provided, session state is kept in-memory (single-instance mode).
     *
     * @example
     * ```typescript
     * // Redis session store
     * const transport = new FetchStreamableHTTPServerTransport({
     *   sessionIdGenerator: () => crypto.randomUUID(),
     *   sessionStore: {
     *     get: async (id) => redis.get(`session:${id}`),
     *     save: async (id, state) => redis.set(`session:${id}`, state, 'EX', 3600),
     *     delete: async (id) => redis.del(`session:${id}`)
     *   }
     * });
     * ```
     */
    sessionStore?: SessionStore;
}
/**
 * Server transport for Web Standards Streamable HTTP: this implements the MCP Streamable HTTP transport specification
 * using Web Standard APIs (Request, Response, TransformStream).
 *
 * Usage example:
 *
 * ```typescript
 * // Stateful mode - server sets the session ID
 * const statefulTransport = new FetchStreamableHTTPServerTransport({
 *   sessionIdGenerator: () => crypto.randomUUID(),
 * });
 *
 * // Stateless mode - explicitly set session ID to undefined
 * const statelessTransport = new FetchStreamableHTTPServerTransport({
 *   sessionIdGenerator: undefined,
 * });
 *
 * // Hono.js usage
 * app.all('/mcp', async (c) => {
 *   return transport.handleRequest(c.req.raw);
 * });
 * ```
 *
 * In stateful mode:
 * - Session ID is generated and included in response headers
 * - Session ID is always included in initialization responses
 * - Requests with invalid session IDs are rejected with 404 Not Found
 * - Non-initialization requests without a session ID are rejected with 400 Bad Request
 * - State is maintained in-memory (connections, message history)
 *
 * In stateless mode:
 * - No Session ID is included in any responses
 * - No session validation is performed
 *
 * @experimental
 */
export declare class FetchStreamableHTTPServerTransport implements Transport {
    private sessionIdGenerator;
    private _started;
    private _streamMapping;
    private _requestToStreamMapping;
    private _requestResponseMap;
    private _initialized;
    private _enableJsonResponse;
    private _standaloneSseStreamId;
    private _eventStore?;
    private _onsessioninitialized?;
    private _onsessionclosed?;
    private _allowedHosts?;
    private _allowedOrigins?;
    private _enableDnsRebindingProtection;
    private _retryInterval?;
    private _sessionStore?;
    sessionId?: string;
    onclose?: () => void;
    onerror?: (error: Error) => void;
    onmessage?: (message: JSONRPCMessage, extra?: MessageExtraInfo) => void;
    constructor(options: FetchStreamableHTTPServerTransportOptions);
    /**
     * Starts the transport. This is required by the Transport interface but is a no-op
     * for the Streamable HTTP transport as connections are managed per-request.
     */
    start(): Promise<void>;
    /**
     * Helper to create a JSON error response
     */
    private createJsonErrorResponse;
    /**
     * Validates request headers for DNS rebinding protection.
     * @returns Error response if validation fails, undefined if validation passes.
     */
    private validateRequestHeaders;
    /**
     * Handles an incoming HTTP request, whether GET, POST, or DELETE
     * Returns a Response object (Web Standard)
     */
    handleRequest(req: Request): Promise<Response>;
    /**
     * Writes a priming event to establish resumption capability.
     * Only sends if eventStore is configured (opt-in for resumability).
     */
    private writePrimingEvent;
    /**
     * Handles GET requests for SSE stream
     */
    private handleGetRequest;
    /**
     * Replays events that would have been sent after the specified event ID
     * Only used when resumability is enabled
     */
    private replayEvents;
    /**
     * Writes an event to an SSE stream via controller with proper formatting
     */
    private writeSSEEvent;
    /**
     * Handles unsupported requests (PUT, PATCH, etc.)
     */
    private handleUnsupportedRequest;
    /**
     * Handles POST requests containing JSON-RPC messages
     */
    private handlePostRequest;
    /**
     * Handles DELETE requests to terminate sessions
     */
    private handleDeleteRequest;
    /**
     * Validates session ID for non-initialization requests.
     * In serverless mode with sessionStore, this will hydrate session state from the store.
     * Returns Response error if invalid, undefined otherwise
     */
    private validateSession;
    private validateProtocolVersion;
    close(): Promise<void>;
    /**
     * Close an SSE stream for a specific request, triggering client reconnection.
     * Use this to implement polling behavior during long-running operations -
     * client will reconnect after the retry interval specified in the priming event.
     */
    closeSSEStream(requestId: RequestId): void;
    /**
     * Close the standalone GET SSE stream, triggering client reconnection.
     * Use this to implement polling behavior for server-initiated notifications.
     */
    closeStandaloneSSEStream(): void;
    send(message: JSONRPCMessage, options?: {
        relatedRequestId?: RequestId;
    }): Promise<void>;
}
//# sourceMappingURL=fetchStreamableHttpServerTransport.d.ts.map