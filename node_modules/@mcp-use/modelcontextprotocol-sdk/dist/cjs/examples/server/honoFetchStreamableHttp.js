"use strict";
/**
 * Example MCP Server using Hono.js with FetchStreamableHTTPServerTransport
 *
 * This example demonstrates how to use the experimental FetchStreamableHTTPServerTransport
 * with Hono.js to create an MCP server that uses Web Standard APIs.
 *
 * The FetchStreamableHTTPServerTransport uses Web Standard Request/Response objects,
 * making it compatible with various runtimes like Cloudflare Workers, Deno, Bun, etc.
 * This example runs on Node.js using @hono/node-server.
 *
 * To run this example:
 *   npx tsx src/examples/server/honoFetchStreamableHttp.ts
 *
 * Then test with curl:
 *   # Initialize
 *   curl -X POST http://localhost:3000/mcp \
 *     -H "Content-Type: application/json" \
 *     -H "Accept: application/json, text/event-stream" \
 *     -d '{"jsonrpc":"2.0","method":"initialize","params":{"protocolVersion":"2025-03-26","clientInfo":{"name":"test","version":"1.0"},"capabilities":{}},"id":1}'
 *
 *   # List tools (use session ID from init response)
 *   curl -X POST http://localhost:3000/mcp \
 *     -H "Content-Type: application/json" \
 *     -H "Accept: application/json, text/event-stream" \
 *     -H "mcp-session-id: <session-id>" \
 *     -d '{"jsonrpc":"2.0","method":"tools/list","params":{},"id":2}'
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const hono_1 = require("hono");
const cors_1 = require("hono/cors");
const node_server_1 = require("@hono/node-server");
const v4_1 = __importDefault(require("zod/v4"));
const mcp_js_1 = require("../../server/mcp.js");
const index_js_1 = require("../../experimental/fetch-streamable-http/index.js");
// Create the Hono app
const app = new hono_1.Hono();
// Store active transports by session ID for session management
const transports = new Map();
/**
 * Creates and configures an MCP server with example tools, resources, and prompts
 */
function createMcpServer() {
    const server = new mcp_js_1.McpServer({
        name: 'hono-fetch-streamable-http-server',
        version: '1.0.0'
    }, { capabilities: { logging: {} } });
    // Register a simple tool using the new registerTool API
    server.registerTool('greet', {
        description: 'Greets someone by name',
        inputSchema: {
            name: v4_1.default.string().describe('The name to greet')
        }
    }, async ({ name }) => {
        return {
            content: [
                {
                    type: 'text',
                    text: `Hello, ${name}! Welcome to the Hono MCP server.`
                }
            ]
        };
    });
    // Register a tool that demonstrates async operations
    server.registerTool('calculate', {
        description: 'Performs a simple calculation',
        inputSchema: {
            operation: v4_1.default.enum(['add', 'subtract', 'multiply', 'divide']).describe('The operation to perform'),
            a: v4_1.default.number().describe('First operand'),
            b: v4_1.default.number().describe('Second operand')
        }
    }, async ({ operation, a, b }) => {
        let result;
        switch (operation) {
            case 'add':
                result = a + b;
                break;
            case 'subtract':
                result = a - b;
                break;
            case 'multiply':
                result = a * b;
                break;
            case 'divide':
                if (b === 0) {
                    return {
                        content: [{ type: 'text', text: 'Error: Division by zero' }],
                        isError: true
                    };
                }
                result = a / b;
                break;
        }
        return {
            content: [
                {
                    type: 'text',
                    text: `${a} ${operation} ${b} = ${result}`
                }
            ]
        };
    });
    // Register a tool that sends notifications (demonstrates SSE streaming)
    server.registerTool('send-notifications', {
        description: 'Sends a series of notifications to demonstrate SSE streaming',
        inputSchema: {
            count: v4_1.default.number().min(1).max(10).default(3).describe('Number of notifications to send'),
            interval: v4_1.default.number().min(100).max(2000).default(500).describe('Interval between notifications in ms')
        }
    }, async ({ count, interval }, extra) => {
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        for (let i = 1; i <= count; i++) {
            await server.sendLoggingMessage({
                level: 'info',
                data: `Notification ${i} of ${count} at ${new Date().toISOString()}`
            }, extra.sessionId);
            if (i < count) {
                await sleep(interval);
            }
        }
        return {
            content: [
                {
                    type: 'text',
                    text: `Sent ${count} notifications with ${interval}ms interval`
                }
            ]
        };
    });
    // Register a simple prompt using the new registerPrompt API
    server.registerPrompt('code-review', {
        description: 'A prompt template for code review',
        argsSchema: {
            language: v4_1.default.string().describe('Programming language'),
            code: v4_1.default.string().describe('Code to review')
        }
    }, async ({ language, code }) => {
        return {
            messages: [
                {
                    role: 'user',
                    content: {
                        type: 'text',
                        text: `Please review the following ${language} code and provide feedback on:
1. Code quality and best practices
2. Potential bugs or issues
3. Performance considerations
4. Suggestions for improvement

Code:
\`\`\`${language}
${code}
\`\`\``
                    }
                }
            ]
        };
    });
    // Register a simple resource using the new registerResource API
    server.registerResource('server-info', 'mcp://server/info', {
        description: 'Information about this MCP server',
        mimeType: 'application/json'
    }, async () => {
        return {
            contents: [
                {
                    uri: 'mcp://server/info',
                    mimeType: 'application/json',
                    text: JSON.stringify({
                        name: 'hono-fetch-streamable-http-server',
                        version: '1.0.0',
                        runtime: 'Node.js',
                        framework: 'Hono',
                        transport: 'FetchStreamableHTTPServerTransport',
                        timestamp: new Date().toISOString()
                    }, null, 2)
                }
            ]
        };
    });
    return server;
}
// Configure CORS middleware for all routes
app.use('*', (0, cors_1.cors)({
    origin: '*',
    allowMethods: ['GET', 'POST', 'DELETE', 'OPTIONS'],
    allowHeaders: ['Content-Type', 'Accept', 'mcp-session-id', 'last-event-id', 'mcp-protocol-version'],
    exposeHeaders: ['mcp-session-id']
}));
// Example auth middleware (uncomment to enable authentication):
// app.use('/mcp', async (c, next) => {
//     const token = c.req.header('Authorization')?.replace('Bearer ', '');
//     if (token) {
//         // Validate token and set auth info in context
//         c.set('auth', { token, clientId: 'example-client' });
//     }
//     await next();
// });
app.all('/mcp', async (c) => {
    // Check for existing session
    const sessionId = c.req.header('mcp-session-id');
    if (sessionId && transports.has(sessionId)) {
        // Reuse existing transport for this session
        const transport = transports.get(sessionId);
        // Pass auth from context if using auth middleware: { auth: c.get('auth') }
        return transport.handleRequest(c.req.raw);
    }
    // For new sessions or initialization, create new transport and server
    const server = createMcpServer();
    const transport = new index_js_1.FetchStreamableHTTPServerTransport({
        sessionIdGenerator: () => crypto.randomUUID(),
        onsessioninitialized: sessionId => {
            // Store the transport for session reuse
            transports.set(sessionId, transport);
            console.log(`Session initialized: ${sessionId}`);
        },
        onsessionclosed: sessionId => {
            // Clean up when session closes
            transports.delete(sessionId);
            console.log(`Session closed: ${sessionId}`);
        }
    });
    await server.connect(transport);
    // Pass auth from context if using auth middleware: { auth: c.get('auth') }
    return transport.handleRequest(c.req.raw);
});
// Health check endpoint
app.get('/health', c => {
    return c.json({
        status: 'healthy',
        activeSessions: transports.size,
        timestamp: new Date().toISOString()
    });
});
// Start the server
const PORT = 3000;
console.log(`MCP server running at http://localhost:${PORT}/mcp`);
(0, node_server_1.serve)({
    fetch: app.fetch,
    port: PORT
});
// Handle graceful shutdown
process.on('SIGINT', async () => {
    console.log('\nShutting down server...');
    // Close all active transports
    for (const [sessionId, transport] of transports) {
        console.log(`Closing session: ${sessionId}`);
        await transport.close();
    }
    transports.clear();
    console.log('Server stopped.');
    process.exit(0);
});
//# sourceMappingURL=honoFetchStreamableHttp.js.map