#!/usr/bin/env node

// ../../node_modules/.pnpm/tsup@8.5.1_jiti@2.6.1_postcss@8.5.6_tsx@4.21.0_typescript@5.9.3_yaml@2.8.2/node_modules/tsup/assets/esm_shims.js
import path from "path";
import { fileURLToPath } from "url";
var getFilename = () => fileURLToPath(import.meta.url);
var getDirname = () => path.dirname(getFilename());
var __dirname = /* @__PURE__ */ getDirname();

// ../../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// ../../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/vendor/supports-color/index.js
import process2 from "process";
import os from "os";
import tty from "tty";
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process2.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = process2;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (process2.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((key) => key in env)) {
      return 3;
    }
    if (["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if (env.TERM === "xterm-ghostty") {
    return 3;
  }
  if (env.TERM === "wezterm") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

// ../../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// ../../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = /* @__PURE__ */ Symbol("GENERATOR");
var STYLER = /* @__PURE__ */ Symbol("STYLER");
var IS_EMPTY = /* @__PURE__ */ Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = /* @__PURE__ */ Object.create(null);
var applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk2 = (...strings) => strings.join(" ");
  applyOptions(chalk2, options);
  Object.setPrototypeOf(chalk2, createChalk.prototype);
  return chalk2;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open2, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open2;
    closeAll = close;
  } else {
    openAll = parent.openAll + open2;
    closeAll = close + parent.closeAll;
  }
  return {
    open: open2,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self, string) => {
  if (self.level <= 0 || !string) {
    return self[IS_EMPTY] ? "" : string;
  }
  let styler = self[STYLER];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// src/index.ts
import { Command as Command2 } from "commander";
import "dotenv/config";
import { spawn } from "child_process";
import { readFileSync } from "fs";
import { access, mkdir as mkdir2, readFile as readFile2, writeFile as writeFile2 } from "fs/promises";
import path5 from "path";

// ../../node_modules/.pnpm/open@11.0.0/node_modules/open/index.js
import process9 from "process";
import path2 from "path";
import { fileURLToPath as fileURLToPath2 } from "url";
import childProcess3 from "child_process";
import fs6, { constants as fsConstants3 } from "fs/promises";

// ../../node_modules/.pnpm/wsl-utils@0.3.0/node_modules/wsl-utils/index.js
import { promisify as promisify2 } from "util";
import childProcess2 from "child_process";
import fs5, { constants as fsConstants2 } from "fs/promises";

// ../../node_modules/.pnpm/is-wsl@3.1.0/node_modules/is-wsl/index.js
import process3 from "process";
import os2 from "os";
import fs3 from "fs";

// ../../node_modules/.pnpm/is-inside-container@1.0.0/node_modules/is-inside-container/index.js
import fs2 from "fs";

// ../../node_modules/.pnpm/is-docker@3.0.0/node_modules/is-docker/index.js
import fs from "fs";
var isDockerCached;
function hasDockerEnv() {
  try {
    fs.statSync("/.dockerenv");
    return true;
  } catch {
    return false;
  }
}
function hasDockerCGroup() {
  try {
    return fs.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
  } catch {
    return false;
  }
}
function isDocker() {
  if (isDockerCached === void 0) {
    isDockerCached = hasDockerEnv() || hasDockerCGroup();
  }
  return isDockerCached;
}

// ../../node_modules/.pnpm/is-inside-container@1.0.0/node_modules/is-inside-container/index.js
var cachedResult;
var hasContainerEnv = () => {
  try {
    fs2.statSync("/run/.containerenv");
    return true;
  } catch {
    return false;
  }
};
function isInsideContainer() {
  if (cachedResult === void 0) {
    cachedResult = hasContainerEnv() || isDocker();
  }
  return cachedResult;
}

// ../../node_modules/.pnpm/is-wsl@3.1.0/node_modules/is-wsl/index.js
var isWsl = () => {
  if (process3.platform !== "linux") {
    return false;
  }
  if (os2.release().toLowerCase().includes("microsoft")) {
    if (isInsideContainer()) {
      return false;
    }
    return true;
  }
  try {
    return fs3.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isInsideContainer() : false;
  } catch {
    return false;
  }
};
var is_wsl_default = process3.env.__IS_WSL_TEST__ ? isWsl : isWsl();

// ../../node_modules/.pnpm/powershell-utils@0.1.0/node_modules/powershell-utils/index.js
import process4 from "process";
import { Buffer } from "buffer";
import { promisify } from "util";
import childProcess from "child_process";
import fs4, { constants as fsConstants } from "fs/promises";
var execFile = promisify(childProcess.execFile);
var powerShellPath = () => `${process4.env.SYSTEMROOT || process4.env.windir || String.raw`C:\Windows`}\\System32\\WindowsPowerShell\\v1.0\\powershell.exe`;
var executePowerShell = async (command, options = {}) => {
  const {
    powerShellPath: psPath,
    ...execFileOptions
  } = options;
  const encodedCommand = executePowerShell.encodeCommand(command);
  return execFile(
    psPath ?? powerShellPath(),
    [
      ...executePowerShell.argumentsPrefix,
      encodedCommand
    ],
    {
      encoding: "utf8",
      ...execFileOptions
    }
  );
};
executePowerShell.argumentsPrefix = [
  "-NoProfile",
  "-NonInteractive",
  "-ExecutionPolicy",
  "Bypass",
  "-EncodedCommand"
];
executePowerShell.encodeCommand = (command) => Buffer.from(command, "utf16le").toString("base64");
executePowerShell.escapeArgument = (value) => `'${String(value).replaceAll("'", "''")}'`;

// ../../node_modules/.pnpm/wsl-utils@0.3.0/node_modules/wsl-utils/index.js
var execFile2 = promisify2(childProcess2.execFile);
var wslDrivesMountPoint = /* @__PURE__ */ (() => {
  const defaultMountPoint = "/mnt/";
  let mountPoint;
  return async function() {
    if (mountPoint) {
      return mountPoint;
    }
    const configFilePath = "/etc/wsl.conf";
    let isConfigFileExists = false;
    try {
      await fs5.access(configFilePath, fsConstants2.F_OK);
      isConfigFileExists = true;
    } catch {
    }
    if (!isConfigFileExists) {
      return defaultMountPoint;
    }
    const configContent = await fs5.readFile(configFilePath, { encoding: "utf8" });
    const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
    if (!configMountPoint) {
      return defaultMountPoint;
    }
    mountPoint = configMountPoint.groups.mountPoint.trim();
    mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
    return mountPoint;
  };
})();
var powerShellPathFromWsl = async () => {
  const mountPoint = await wslDrivesMountPoint();
  return `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`;
};
var powerShellPath2 = is_wsl_default ? powerShellPathFromWsl : powerShellPath;
var canAccessPowerShellPromise;
var canAccessPowerShell = async () => {
  canAccessPowerShellPromise ??= (async () => {
    try {
      const psPath = await powerShellPath2();
      await fs5.access(psPath, fsConstants2.X_OK);
      return true;
    } catch {
      return false;
    }
  })();
  return canAccessPowerShellPromise;
};
var wslDefaultBrowser = async () => {
  const psPath = await powerShellPath2();
  const command = String.raw`(Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice").ProgId`;
  const { stdout } = await executePowerShell(command, { powerShellPath: psPath });
  return stdout.trim();
};
var convertWslPathToWindows = async (path6) => {
  if (/^[a-z]+:\/\//i.test(path6)) {
    return path6;
  }
  try {
    const { stdout } = await execFile2("wslpath", ["-aw", path6], { encoding: "utf8" });
    return stdout.trim();
  } catch {
    return path6;
  }
};

// ../../node_modules/.pnpm/define-lazy-prop@3.0.0/node_modules/define-lazy-prop/index.js
function defineLazyProperty(object, propertyName, valueGetter) {
  const define = (value) => Object.defineProperty(object, propertyName, { value, enumerable: true, writable: true });
  Object.defineProperty(object, propertyName, {
    configurable: true,
    enumerable: true,
    get() {
      const result = valueGetter();
      define(result);
      return result;
    },
    set(value) {
      define(value);
    }
  });
  return object;
}

// ../../node_modules/.pnpm/default-browser@5.4.0/node_modules/default-browser/index.js
import { promisify as promisify6 } from "util";
import process7 from "process";
import { execFile as execFile6 } from "child_process";

// ../../node_modules/.pnpm/default-browser-id@5.0.1/node_modules/default-browser-id/index.js
import { promisify as promisify3 } from "util";
import process5 from "process";
import { execFile as execFile3 } from "child_process";
var execFileAsync = promisify3(execFile3);
async function defaultBrowserId() {
  if (process5.platform !== "darwin") {
    throw new Error("macOS only");
  }
  const { stdout } = await execFileAsync("defaults", ["read", "com.apple.LaunchServices/com.apple.launchservices.secure", "LSHandlers"]);
  const match = /LSHandlerRoleAll = "(?!-)(?<id>[^"]+?)";\s+?LSHandlerURLScheme = (?:http|https);/.exec(stdout);
  const browserId = match?.groups.id ?? "com.apple.Safari";
  if (browserId === "com.apple.safari") {
    return "com.apple.Safari";
  }
  return browserId;
}

// ../../node_modules/.pnpm/run-applescript@7.1.0/node_modules/run-applescript/index.js
import process6 from "process";
import { promisify as promisify4 } from "util";
import { execFile as execFile4, execFileSync } from "child_process";
var execFileAsync2 = promisify4(execFile4);
async function runAppleScript(script, { humanReadableOutput = true, signal } = {}) {
  if (process6.platform !== "darwin") {
    throw new Error("macOS only");
  }
  const outputArguments = humanReadableOutput ? [] : ["-ss"];
  const execOptions = {};
  if (signal) {
    execOptions.signal = signal;
  }
  const { stdout } = await execFileAsync2("osascript", ["-e", script, outputArguments], execOptions);
  return stdout.trim();
}

// ../../node_modules/.pnpm/bundle-name@4.1.0/node_modules/bundle-name/index.js
async function bundleName(bundleId) {
  return runAppleScript(`tell application "Finder" to set app_path to application file id "${bundleId}" as string
tell application "System Events" to get value of property list item "CFBundleName" of property list file (app_path & ":Contents:Info.plist")`);
}

// ../../node_modules/.pnpm/default-browser@5.4.0/node_modules/default-browser/windows.js
import { promisify as promisify5 } from "util";
import { execFile as execFile5 } from "child_process";
var execFileAsync3 = promisify5(execFile5);
var windowsBrowserProgIds = {
  MSEdgeHTM: { name: "Edge", id: "com.microsoft.edge" },
  // The missing `L` is correct.
  MSEdgeBHTML: { name: "Edge Beta", id: "com.microsoft.edge.beta" },
  MSEdgeDHTML: { name: "Edge Dev", id: "com.microsoft.edge.dev" },
  AppXq0fevzme2pys62n3e0fbqa7peapykr8v: { name: "Edge", id: "com.microsoft.edge.old" },
  ChromeHTML: { name: "Chrome", id: "com.google.chrome" },
  ChromeBHTML: { name: "Chrome Beta", id: "com.google.chrome.beta" },
  ChromeDHTML: { name: "Chrome Dev", id: "com.google.chrome.dev" },
  ChromiumHTM: { name: "Chromium", id: "org.chromium.Chromium" },
  BraveHTML: { name: "Brave", id: "com.brave.Browser" },
  BraveBHTML: { name: "Brave Beta", id: "com.brave.Browser.beta" },
  BraveDHTML: { name: "Brave Dev", id: "com.brave.Browser.dev" },
  BraveSSHTM: { name: "Brave Nightly", id: "com.brave.Browser.nightly" },
  FirefoxURL: { name: "Firefox", id: "org.mozilla.firefox" },
  OperaStable: { name: "Opera", id: "com.operasoftware.Opera" },
  VivaldiHTM: { name: "Vivaldi", id: "com.vivaldi.Vivaldi" },
  "IE.HTTP": { name: "Internet Explorer", id: "com.microsoft.ie" }
};
var _windowsBrowserProgIdMap = new Map(Object.entries(windowsBrowserProgIds));
var UnknownBrowserError = class extends Error {
};
async function defaultBrowser(_execFileAsync = execFileAsync3) {
  const { stdout } = await _execFileAsync("reg", [
    "QUERY",
    " HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice",
    "/v",
    "ProgId"
  ]);
  const match = /ProgId\s*REG_SZ\s*(?<id>\S+)/.exec(stdout);
  if (!match) {
    throw new UnknownBrowserError(`Cannot find Windows browser in stdout: ${JSON.stringify(stdout)}`);
  }
  const { id } = match.groups;
  const browser = windowsBrowserProgIds[id];
  if (!browser) {
    throw new UnknownBrowserError(`Unknown browser ID: ${id}`);
  }
  return browser;
}

// ../../node_modules/.pnpm/default-browser@5.4.0/node_modules/default-browser/index.js
var execFileAsync4 = promisify6(execFile6);
var titleize = (string) => string.toLowerCase().replaceAll(/(?:^|\s|-)\S/g, (x) => x.toUpperCase());
async function defaultBrowser2() {
  if (process7.platform === "darwin") {
    const id = await defaultBrowserId();
    const name = await bundleName(id);
    return { name, id };
  }
  if (process7.platform === "linux") {
    const { stdout } = await execFileAsync4("xdg-mime", ["query", "default", "x-scheme-handler/http"]);
    const id = stdout.trim();
    const name = titleize(id.replace(/.desktop$/, "").replace("-", " "));
    return { name, id };
  }
  if (process7.platform === "win32") {
    return defaultBrowser();
  }
  throw new Error("Only macOS, Linux, and Windows are supported");
}

// ../../node_modules/.pnpm/is-in-ssh@1.0.0/node_modules/is-in-ssh/index.js
import process8 from "process";
var isInSsh = Boolean(process8.env.SSH_CONNECTION || process8.env.SSH_CLIENT || process8.env.SSH_TTY);
var is_in_ssh_default = isInSsh;

// ../../node_modules/.pnpm/open@11.0.0/node_modules/open/index.js
var fallbackAttemptSymbol = /* @__PURE__ */ Symbol("fallbackAttempt");
var __dirname2 = import.meta.url ? path2.dirname(fileURLToPath2(import.meta.url)) : "";
var localXdgOpenPath = path2.join(__dirname2, "xdg-open");
var { platform, arch } = process9;
var tryEachApp = async (apps2, opener) => {
  if (apps2.length === 0) {
    return;
  }
  const errors = [];
  for (const app of apps2) {
    try {
      return await opener(app);
    } catch (error) {
      errors.push(error);
    }
  }
  throw new AggregateError(errors, "Failed to open in all supported apps");
};
var baseOpen = async (options) => {
  options = {
    wait: false,
    background: false,
    newInstance: false,
    allowNonzeroExitCode: false,
    ...options
  };
  const isFallbackAttempt = options[fallbackAttemptSymbol] === true;
  delete options[fallbackAttemptSymbol];
  if (Array.isArray(options.app)) {
    return tryEachApp(options.app, (singleApp) => baseOpen({
      ...options,
      app: singleApp,
      [fallbackAttemptSymbol]: true
    }));
  }
  let { name: app, arguments: appArguments = [] } = options.app ?? {};
  appArguments = [...appArguments];
  if (Array.isArray(app)) {
    return tryEachApp(app, (appName) => baseOpen({
      ...options,
      app: {
        name: appName,
        arguments: appArguments
      },
      [fallbackAttemptSymbol]: true
    }));
  }
  if (app === "browser" || app === "browserPrivate") {
    const ids = {
      "com.google.chrome": "chrome",
      "google-chrome.desktop": "chrome",
      "com.brave.browser": "brave",
      "org.mozilla.firefox": "firefox",
      "firefox.desktop": "firefox",
      "com.microsoft.msedge": "edge",
      "com.microsoft.edge": "edge",
      "com.microsoft.edgemac": "edge",
      "microsoft-edge.desktop": "edge",
      "com.apple.safari": "safari"
    };
    const flags = {
      chrome: "--incognito",
      brave: "--incognito",
      firefox: "--private-window",
      edge: "--inPrivate"
      // Safari doesn't support private mode via command line
    };
    let browser;
    if (is_wsl_default) {
      const progId = await wslDefaultBrowser();
      const browserInfo = _windowsBrowserProgIdMap.get(progId);
      browser = browserInfo ?? {};
    } else {
      browser = await defaultBrowser2();
    }
    if (browser.id in ids) {
      const browserName = ids[browser.id.toLowerCase()];
      if (app === "browserPrivate") {
        if (browserName === "safari") {
          throw new Error("Safari doesn't support opening in private mode via command line");
        }
        appArguments.push(flags[browserName]);
      }
      return baseOpen({
        ...options,
        app: {
          name: apps[browserName],
          arguments: appArguments
        }
      });
    }
    throw new Error(`${browser.name} is not supported as a default browser`);
  }
  let command;
  const cliArguments = [];
  const childProcessOptions = {};
  let shouldUseWindowsInWsl = false;
  if (is_wsl_default && !isInsideContainer() && !is_in_ssh_default && !app) {
    shouldUseWindowsInWsl = await canAccessPowerShell();
  }
  if (platform === "darwin") {
    command = "open";
    if (options.wait) {
      cliArguments.push("--wait-apps");
    }
    if (options.background) {
      cliArguments.push("--background");
    }
    if (options.newInstance) {
      cliArguments.push("--new");
    }
    if (app) {
      cliArguments.push("-a", app);
    }
  } else if (platform === "win32" || shouldUseWindowsInWsl) {
    command = await powerShellPath2();
    cliArguments.push(...executePowerShell.argumentsPrefix);
    if (!is_wsl_default) {
      childProcessOptions.windowsVerbatimArguments = true;
    }
    if (is_wsl_default && options.target) {
      options.target = await convertWslPathToWindows(options.target);
    }
    const encodedArguments = ["$ProgressPreference = 'SilentlyContinue';", "Start"];
    if (options.wait) {
      encodedArguments.push("-Wait");
    }
    if (app) {
      encodedArguments.push(executePowerShell.escapeArgument(app));
      if (options.target) {
        appArguments.push(options.target);
      }
    } else if (options.target) {
      encodedArguments.push(executePowerShell.escapeArgument(options.target));
    }
    if (appArguments.length > 0) {
      appArguments = appArguments.map((argument) => executePowerShell.escapeArgument(argument));
      encodedArguments.push("-ArgumentList", appArguments.join(","));
    }
    options.target = executePowerShell.encodeCommand(encodedArguments.join(" "));
    if (!options.wait) {
      childProcessOptions.stdio = "ignore";
    }
  } else {
    if (app) {
      command = app;
    } else {
      const isBundled = !__dirname2 || __dirname2 === "/";
      let exeLocalXdgOpen = false;
      try {
        await fs6.access(localXdgOpenPath, fsConstants3.X_OK);
        exeLocalXdgOpen = true;
      } catch {
      }
      const useSystemXdgOpen = process9.versions.electron ?? (platform === "android" || isBundled || !exeLocalXdgOpen);
      command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
    }
    if (appArguments.length > 0) {
      cliArguments.push(...appArguments);
    }
    if (!options.wait) {
      childProcessOptions.stdio = "ignore";
      childProcessOptions.detached = true;
    }
  }
  if (platform === "darwin" && appArguments.length > 0) {
    cliArguments.push("--args", ...appArguments);
  }
  if (options.target) {
    cliArguments.push(options.target);
  }
  const subprocess = childProcess3.spawn(command, cliArguments, childProcessOptions);
  if (options.wait) {
    return new Promise((resolve, reject) => {
      subprocess.once("error", reject);
      subprocess.once("close", (exitCode) => {
        if (!options.allowNonzeroExitCode && exitCode !== 0) {
          reject(new Error(`Exited with code ${exitCode}`));
          return;
        }
        resolve(subprocess);
      });
    });
  }
  if (isFallbackAttempt) {
    return new Promise((resolve, reject) => {
      subprocess.once("error", reject);
      subprocess.once("spawn", () => {
        subprocess.once("close", (exitCode) => {
          subprocess.off("error", reject);
          if (exitCode !== 0) {
            reject(new Error(`Exited with code ${exitCode}`));
            return;
          }
          subprocess.unref();
          resolve(subprocess);
        });
      });
    });
  }
  subprocess.unref();
  return new Promise((resolve, reject) => {
    subprocess.once("error", reject);
    subprocess.once("spawn", () => {
      subprocess.off("error", reject);
      resolve(subprocess);
    });
  });
};
var open = (target, options) => {
  if (typeof target !== "string") {
    throw new TypeError("Expected a `target`");
  }
  return baseOpen({
    ...options,
    target
  });
};
function detectArchBinary(binary) {
  if (typeof binary === "string" || Array.isArray(binary)) {
    return binary;
  }
  const { [arch]: archBinary } = binary;
  if (!archBinary) {
    throw new Error(`${arch} is not supported`);
  }
  return archBinary;
}
function detectPlatformBinary({ [platform]: platformBinary }, { wsl } = {}) {
  if (wsl && is_wsl_default) {
    return detectArchBinary(wsl);
  }
  if (!platformBinary) {
    throw new Error(`${platform} is not supported`);
  }
  return detectArchBinary(platformBinary);
}
var apps = {
  browser: "browser",
  browserPrivate: "browserPrivate"
};
defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
  darwin: "google chrome",
  win32: "chrome",
  // `chromium-browser` is the older deb package name used by Ubuntu/Debian before snap.
  linux: ["google-chrome", "google-chrome-stable", "chromium", "chromium-browser"]
}, {
  wsl: {
    ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
    x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
  }
}));
defineLazyProperty(apps, "brave", () => detectPlatformBinary({
  darwin: "brave browser",
  win32: "brave",
  linux: ["brave-browser", "brave"]
}, {
  wsl: {
    ia32: "/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe",
    x64: ["/mnt/c/Program Files/BraveSoftware/Brave-Browser/Application/brave.exe", "/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe"]
  }
}));
defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
  darwin: "firefox",
  win32: String.raw`C:\Program Files\Mozilla Firefox\firefox.exe`,
  linux: "firefox"
}, {
  wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
}));
defineLazyProperty(apps, "edge", () => detectPlatformBinary({
  darwin: "microsoft edge",
  win32: "msedge",
  linux: ["microsoft-edge", "microsoft-edge-dev"]
}, {
  wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
}));
defineLazyProperty(apps, "safari", () => detectPlatformBinary({
  darwin: "Safari"
}));
var open_default = open;

// src/commands/auth.ts
import {
  createServer
} from "http";

// src/utils/config.ts
import { promises as fs7 } from "fs";
import path3 from "path";
import os3 from "os";
var CONFIG_DIR = path3.join(os3.homedir(), ".mcp-use");
var CONFIG_FILE = path3.join(CONFIG_DIR, "config.json");
var DEFAULT_API_URL = process.env.MCP_API_URL ? process.env.MCP_API_URL.replace(/\/api\/v1$/, "") + "/api/v1" : "https://cloud.mcp-use.com/api/v1";
var DEFAULT_WEB_URL = process.env.MCP_WEB_URL ? process.env.MCP_WEB_URL : "https://mcp-use.com";
async function ensureConfigDir() {
  try {
    await fs7.mkdir(CONFIG_DIR, { recursive: true });
  } catch (error) {
  }
}
async function readConfig() {
  try {
    const content = await fs7.readFile(CONFIG_FILE, "utf-8");
    return JSON.parse(content);
  } catch (error) {
    return {};
  }
}
async function writeConfig(config) {
  await ensureConfigDir();
  await fs7.writeFile(CONFIG_FILE, JSON.stringify(config, null, 2), "utf-8");
}
async function deleteConfig() {
  try {
    await fs7.unlink(CONFIG_FILE);
  } catch (error) {
  }
}
async function getApiUrl() {
  const config = await readConfig();
  return config.apiUrl || DEFAULT_API_URL;
}
async function getApiKey() {
  const config = await readConfig();
  return config.apiKey || null;
}
async function isLoggedIn() {
  const apiKey = await getApiKey();
  return !!apiKey;
}
async function getWebUrl() {
  return DEFAULT_WEB_URL;
}

// src/utils/api.ts
var McpUseAPI = class _McpUseAPI {
  baseUrl;
  apiKey;
  constructor(baseUrl, apiKey) {
    this.baseUrl = baseUrl || "";
    this.apiKey = apiKey;
  }
  /**
   * Initialize API client with config
   */
  static async create() {
    const baseUrl = await getApiUrl();
    const apiKey = await getApiKey();
    return new _McpUseAPI(baseUrl, apiKey ?? void 0);
  }
  /**
   * Make authenticated request
   */
  async request(endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;
    const headers = {
      "Content-Type": "application/json",
      ...options.headers || {}
    };
    if (this.apiKey) {
      headers["x-api-key"] = this.apiKey;
    }
    const response = await fetch(url, {
      ...options,
      headers
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`API request failed: ${response.status} ${error}`);
    }
    return response.json();
  }
  /**
   * Create API key using JWT token
   */
  async createApiKey(jwtToken, name = "CLI") {
    const url = `${this.baseUrl}/api-key`;
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${jwtToken}`
      },
      body: JSON.stringify({ name })
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to create API key: ${response.status} ${error}`);
    }
    return response.json();
  }
  /**
   * Test authentication
   */
  async testAuth() {
    return this.request("/test-auth");
  }
  /**
   * Create deployment
   */
  async createDeployment(request) {
    return this.request("/deployments", {
      method: "POST",
      body: JSON.stringify(request)
    });
  }
  /**
   * Get deployment by ID
   */
  async getDeployment(deploymentId) {
    return this.request(`/deployments/${deploymentId}`);
  }
  /**
   * Stream deployment logs
   */
  async *streamDeploymentLogs(deploymentId) {
    const url = `${this.baseUrl}/deployments/${deploymentId}/logs/stream`;
    const headers = {};
    if (this.apiKey) {
      headers["x-api-key"] = this.apiKey;
    }
    const response = await fetch(url, { headers });
    if (!response.ok) {
      throw new Error(`Failed to stream logs: ${response.status}`);
    }
    if (!response.body) {
      throw new Error("Response body is null");
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const data = line.slice(6);
            try {
              const parsed = JSON.parse(data);
              if (parsed.log) {
                yield parsed.log;
              } else if (parsed.error) {
                throw new Error(parsed.error);
              }
            } catch (e) {
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }
  /**
   * Create deployment with source code upload
   */
  async createDeploymentWithUpload(request, filePath) {
    const { readFile: readFile3 } = await import("fs/promises");
    const { basename } = await import("path");
    const { stat } = await import("fs/promises");
    const stats = await stat(filePath);
    const maxSize = 2 * 1024 * 1024;
    if (stats.size > maxSize) {
      throw new Error(
        `File size (${(stats.size / 1024 / 1024).toFixed(2)}MB) exceeds maximum of 2MB`
      );
    }
    const fileBuffer = await readFile3(filePath);
    const filename = basename(filePath);
    const formData = new FormData();
    const blob = new Blob([fileBuffer], { type: "application/gzip" });
    formData.append("source_file", blob, filename);
    formData.append("name", request.name);
    formData.append("source_type", "upload");
    if (request.source.type === "upload") {
      formData.append("runtime", request.source.runtime || "node");
      formData.append("port", String(request.source.port || 3e3));
      if (request.source.startCommand) {
        formData.append("startCommand", request.source.startCommand);
      }
      if (request.source.buildCommand) {
        formData.append("buildCommand", request.source.buildCommand);
      }
      if (request.source.env && Object.keys(request.source.env).length > 0) {
        formData.append("env", JSON.stringify(request.source.env));
      }
    }
    if (request.customDomain) {
      formData.append("customDomain", request.customDomain);
    }
    if (request.healthCheckPath) {
      formData.append("healthCheckPath", request.healthCheckPath);
    }
    const url = `${this.baseUrl}/deployments`;
    const headers = {};
    if (this.apiKey) {
      headers["x-api-key"] = this.apiKey;
    }
    const response = await fetch(url, {
      method: "POST",
      headers,
      body: formData
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Deployment failed: ${error}`);
    }
    return response.json();
  }
};

// src/commands/auth.ts
var LOGIN_TIMEOUT = 3e5;
async function findAvailablePort(startPort = 8765) {
  for (let port = startPort; port < startPort + 100; port++) {
    try {
      await new Promise((resolve, reject) => {
        const server = createServer();
        server.once("error", reject);
        server.once("listening", () => {
          server.close();
          resolve();
        });
        server.listen(port);
      });
      return port;
    } catch {
      continue;
    }
  }
  throw new Error("No available ports found");
}
async function startCallbackServer(port) {
  return new Promise((resolve, reject) => {
    let tokenResolver = null;
    const tokenPromise = new Promise((res) => {
      tokenResolver = res;
    });
    const server = createServer((req, res) => {
      if (req.url?.startsWith("/callback")) {
        const url = new URL(req.url, `http://localhost:${port}`);
        const token = url.searchParams.get("token");
        if (token && tokenResolver) {
          res.writeHead(200, { "Content-Type": "text/html" });
          res.end(`
              <!DOCTYPE html>
              <html>
                <head>
                  <title>Login Successful</title>
                  <meta name="viewport" content="width=device-width, initial-scale=1.0">
                  <style>
                    * {
                      margin: 0;
                      padding: 0;
                      box-sizing: border-box;
                    }
                    body {
                      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                      display: flex;
                      justify-content: center;
                      align-items: center;
                      min-height: 100vh;
                      background: #000;
                      padding: 1rem;
                    }
                    .container {
                      width: 100%;
                      max-width: 28rem;
                      padding: 3rem;
                      text-align: center;
                      -webkit-backdrop-filter: blur(40px);
                      border: 1px solid rgba(255, 255, 255, 0.2);
                      border-radius: 1.5rem;
                      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
                    }
                    .icon-container {
                      display: inline-flex;
                      align-items: center;
                      justify-content: center;
                      width: 6rem;
                      height: 6rem;
                      margin-bottom: 2rem;
                      background: rgba(255, 255, 255, 0.1);
                      backdrop-filter: blur(10px);
                      -webkit-backdrop-filter: blur(10px);
                      border-radius: 50%;
                    }
                    .checkmark {
                      font-size: 4rem;
                      color: #fff;
                      line-height: 1;
                      animation: scaleIn 0.5s ease-out;
                    }
                    @keyframes scaleIn {
                      from {
                        transform: scale(0);
                        opacity: 0;
                      }
                      to {
                        transform: scale(1);
                        opacity: 1;
                      }
                    }
                    h1 {
                      color: #fff;
                      margin: 0 0 1rem 0;
                      font-size: 2.5rem;
                      font-weight: 700;
                      letter-spacing: -0.025em;
                    }
                    p {
                      color: rgba(255, 255, 255, 0.8);
                      margin: 0 0 2rem 0;
                      font-size: 1.125rem;
                      line-height: 1.5;
                    }
                    .spinner {
                      display: inline-block;
                      width: 2rem;
                      height: 2rem;
                      border: 3px solid rgba(255, 255, 255, 0.3);
                      border-top-color: #fff;
                      border-radius: 50%;
                      animation: spin 0.8s linear infinite;
                    }
                    @keyframes spin {
                      to { transform: rotate(360deg); }
                    }
                    .footer {
                      margin-top: 2rem;
                      color: rgba(255, 255, 255, 0.6);
                      font-size: 0.875rem;
                    }
                  </style>
                </head>
                <body>
                  <div class="container">
                    <h1>Authentication Successful!</h1>
                    <p>You can now close this window and return to the CLI.</p>
                  </div>
                </body>
              </html>
            `);
          tokenResolver(token);
        } else {
          res.writeHead(400, { "Content-Type": "text/html" });
          res.end(`
              <!DOCTYPE html>
              <html>
                <head>
                  <title>Login Failed</title>
                  <meta name="viewport" content="width=device-width, initial-scale=1.0">
                  <style>
                    * {
                      margin: 0;
                      padding: 0;
                      box-sizing: border-box;
                    }
                    body {
                      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                      display: flex;
                      justify-content: center;
                      align-items: center;
                      min-height: 100vh;
                      background: #000;
                      padding: 1rem;
                    }
                    .container {
                      width: 100%;
                      max-width: 28rem;
                      padding: 3rem;
                      text-align: center;
                      background: rgba(255, 255, 255, 0.1);
                      backdrop-filter: blur(40px);
                      -webkit-backdrop-filter: blur(40px);
                      border: 1px solid rgba(255, 255, 255, 0.2);
                      border-radius: 1.5rem;
                      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
                    }
                    .icon-container {
                      display: inline-flex;
                      align-items: center;
                      justify-content: center;
                      width: 6rem;
                      height: 6rem;
                      margin-bottom: 2rem;
                      background: rgba(255, 255, 255, 0.1);
                      backdrop-filter: blur(10px);
                      -webkit-backdrop-filter: blur(10px);
                      border-radius: 50%;
                    }
                    .cross {
                      font-size: 4rem;
                      color: #fff;
                      line-height: 1;
                    }
                    h1 {
                      color: #fff;
                      margin: 0 0 1rem 0;
                      font-size: 2.5rem;
                      font-weight: 700;
                      letter-spacing: -0.025em;
                    }
                    p {
                      color: rgba(255, 255, 255, 0.8);
                      margin: 0;
                      font-size: 1.125rem;
                      line-height: 1.5;
                    }
                  </style>
                </head>
                <body>
                  <div class="container">
                    <div class="icon-container">
                      <div class="cross">\u2717</div>
                    </div>
                    <h1>Login Failed</h1>
                    <p>No token received. Please try again.</p>
                  </div>
                </body>
              </html>
            `);
        }
      }
    });
    server.listen(port, () => {
      resolve({ server, token: tokenPromise });
    });
    server.on("error", reject);
  });
}
async function loginCommand() {
  try {
    if (await isLoggedIn()) {
      console.log(
        source_default.yellow(
          "\u26A0\uFE0F  You are already logged in. Run 'mcp-use logout' first if you want to login with a different account."
        )
      );
      return;
    }
    console.log(source_default.cyan.bold("\u{1F510} Logging in to mcp-use cloud...\n"));
    const port = await findAvailablePort();
    const redirectUri = `http://localhost:${port}/callback`;
    console.log(source_default.gray(`Starting local server on port ${port}...`));
    const { server, token } = await startCallbackServer(port);
    const webUrl = await getWebUrl();
    const loginUrl = `${webUrl}/auth/cli?redirect_uri=${encodeURIComponent(redirectUri)}`;
    console.log(source_default.gray(`Opening browser to ${webUrl}/auth/cli...
`));
    console.log(
      source_default.white(
        "If the browser doesn't open automatically, please visit:\n" + source_default.cyan(loginUrl)
      )
    );
    await open_default(loginUrl);
    console.log(
      source_default.gray("\nWaiting for authentication... (this may take a moment)")
    );
    const jwtToken = await Promise.race([
      token,
      new Promise(
        (_, reject) => setTimeout(
          () => reject(new Error("Login timeout - please try again")),
          LOGIN_TIMEOUT
        )
      )
    ]);
    server.close();
    console.log(
      source_default.gray("Received authentication token, creating API key...")
    );
    const api = await McpUseAPI.create();
    const apiKeyResponse = await api.createApiKey(jwtToken, "CLI");
    await writeConfig({
      apiKey: apiKeyResponse.api_key
    });
    console.log(source_default.green.bold("\n\u2713 Successfully logged in!"));
    console.log(
      source_default.gray(
        `
Your API key has been saved to ${source_default.white("~/.mcp-use/config.json")}`
      )
    );
    console.log(
      source_default.gray(
        "You can now deploy your MCP servers with " + source_default.white("mcp-use deploy")
      )
    );
    process.exit(0);
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Login failed:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}
async function logoutCommand() {
  try {
    if (!await isLoggedIn()) {
      console.log(source_default.yellow("\u26A0\uFE0F  You are not logged in."));
      return;
    }
    console.log(source_default.cyan.bold("\u{1F513} Logging out...\n"));
    await deleteConfig();
    console.log(source_default.green.bold("\u2713 Successfully logged out!"));
    console.log(
      source_default.gray(
        "\nYour local config has been deleted. The API key will remain active until revoked from the web interface."
      )
    );
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Logout failed:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}
async function whoamiCommand() {
  try {
    if (!await isLoggedIn()) {
      console.log(source_default.yellow("\u26A0\uFE0F  You are not logged in."));
      console.log(
        source_default.gray("Run " + source_default.white("mcp-use login") + " to get started.")
      );
      return;
    }
    console.log(source_default.cyan.bold("\u{1F464} Current user:\n"));
    const api = await McpUseAPI.create();
    const authInfo = await api.testAuth();
    console.log(source_default.white("Email:   ") + source_default.cyan(authInfo.email));
    console.log(source_default.white("User ID: ") + source_default.gray(authInfo.user_id));
    const apiKey = await getApiKey();
    if (apiKey) {
      const masked = apiKey.substring(0, 6) + "...";
      console.log(source_default.white("API Key: ") + source_default.gray(masked));
    }
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Failed to get user info:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}

// src/commands/deploy.ts
import { promises as fs8 } from "fs";
import path4 from "path";
import os4 from "os";
import { exec as exec2 } from "child_process";
import { promisify as promisify8 } from "util";

// src/utils/git.ts
import { exec } from "child_process";
import { promisify as promisify7 } from "util";
var execAsync = promisify7(exec);
async function gitCommand(command, cwd = process.cwd()) {
  try {
    const { stdout } = await execAsync(command, { cwd });
    return stdout.trim();
  } catch (error) {
    return null;
  }
}
async function isGitRepo(cwd = process.cwd()) {
  const result = await gitCommand("git rev-parse --is-inside-work-tree", cwd);
  return result === "true";
}
async function getRemoteUrl(cwd = process.cwd()) {
  return gitCommand("git config --get remote.origin.url", cwd);
}
function parseGitHubUrl(url) {
  const sshMatch = url.match(/git@github\.com:([^/]+)\/(.+?)(?:\.git)?$/);
  const httpsMatch = url.match(
    /https:\/\/github\.com\/([^/]+)\/(.+?)(?:\.git)?$/
  );
  const match = sshMatch || httpsMatch;
  if (!match) return null;
  return {
    owner: match[1],
    repo: match[2]
  };
}
async function getCurrentBranch(cwd = process.cwd()) {
  return gitCommand("git rev-parse --abbrev-ref HEAD", cwd);
}
async function getCommitSha(cwd = process.cwd()) {
  return gitCommand("git rev-parse HEAD", cwd);
}
async function getCommitMessage(cwd = process.cwd()) {
  return gitCommand("git log -1 --pretty=%B", cwd);
}
async function getGitInfo(cwd = process.cwd()) {
  const isRepo = await isGitRepo(cwd);
  if (!isRepo) {
    return { isGitRepo: false };
  }
  const remoteUrl = await getRemoteUrl(cwd);
  const branch = await getCurrentBranch(cwd);
  const commitSha = await getCommitSha(cwd);
  const commitMessage = await getCommitMessage(cwd);
  let owner;
  let repo;
  if (remoteUrl) {
    const parsed = parseGitHubUrl(remoteUrl);
    if (parsed) {
      owner = parsed.owner;
      repo = parsed.repo;
    }
  }
  return {
    isGitRepo: true,
    remoteUrl: remoteUrl || void 0,
    owner,
    repo,
    branch: branch || void 0,
    commitSha: commitSha || void 0,
    commitMessage: commitMessage || void 0
  };
}
function isGitHubUrl(url) {
  try {
    const parsedUrl = new URL(url);
    return parsedUrl.hostname === "github.com" || parsedUrl.hostname === "www.github.com";
  } catch {
    const sshMatch = url.match(/^git@([^:/]+)[:/]/);
    if (sshMatch) {
      const host = sshMatch[1];
      return host === "github.com" || host === "www.github.com";
    }
  }
  return false;
}

// src/commands/deploy.ts
var execAsync2 = promisify8(exec2);
async function isMcpProject(cwd = process.cwd()) {
  try {
    const packageJsonPath = path4.join(cwd, "package.json");
    const content = await fs8.readFile(packageJsonPath, "utf-8");
    const packageJson2 = JSON.parse(content);
    const hasMcpDeps = packageJson2.dependencies?.["mcp-use"] || packageJson2.dependencies?.["@modelcontextprotocol/sdk"] || packageJson2.devDependencies?.["mcp-use"] || packageJson2.devDependencies?.["@modelcontextprotocol/sdk"];
    const hasMcpScripts = packageJson2.scripts?.mcp || packageJson2.scripts?.["mcp:dev"];
    return !!(hasMcpDeps || hasMcpScripts);
  } catch {
    return false;
  }
}
async function getProjectName(cwd = process.cwd()) {
  try {
    const packageJsonPath = path4.join(cwd, "package.json");
    const content = await fs8.readFile(packageJsonPath, "utf-8");
    const packageJson2 = JSON.parse(content);
    if (packageJson2.name) {
      return packageJson2.name;
    }
  } catch {
  }
  return path4.basename(cwd);
}
async function detectBuildCommand(cwd = process.cwd()) {
  try {
    const packageJsonPath = path4.join(cwd, "package.json");
    const content = await fs8.readFile(packageJsonPath, "utf-8");
    const packageJson2 = JSON.parse(content);
    if (packageJson2.scripts?.build) {
      return "npm run build";
    }
  } catch {
  }
  return void 0;
}
async function detectStartCommand(cwd = process.cwd()) {
  try {
    const packageJsonPath = path4.join(cwd, "package.json");
    const content = await fs8.readFile(packageJsonPath, "utf-8");
    const packageJson2 = JSON.parse(content);
    if (packageJson2.scripts?.start) {
      return "npm start";
    }
    if (packageJson2.main) {
      return `node ${packageJson2.main}`;
    }
  } catch {
  }
  return void 0;
}
async function detectRuntime(cwd = process.cwd()) {
  try {
    const pythonFiles = ["requirements.txt", "pyproject.toml", "setup.py"];
    for (const file of pythonFiles) {
      try {
        await fs8.access(path4.join(cwd, file));
        return "python";
      } catch {
        continue;
      }
    }
    try {
      await fs8.access(path4.join(cwd, "package.json"));
      return "node";
    } catch {
    }
  } catch {
  }
  return "node";
}
async function prompt(question, defaultValue = "n") {
  const readline = await import("readline");
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  const defaultIndicator = defaultValue === "y" ? "Y/n" : "y/N";
  const questionWithDefault = question.replace(
    /(\(y\/n\):)/,
    `(${defaultIndicator}):`
  );
  return new Promise((resolve) => {
    rl.question(questionWithDefault, (answer) => {
      rl.close();
      const trimmedAnswer = answer.trim().toLowerCase();
      if (trimmedAnswer === "") {
        resolve(defaultValue === "y");
      } else {
        resolve(trimmedAnswer === "y" || trimmedAnswer === "yes");
      }
    });
  });
}
async function createTarball(cwd) {
  const tmpDir = os4.tmpdir();
  const tarballPath = path4.join(tmpDir, `mcp-deploy-${Date.now()}.tar.gz`);
  const excludePatterns = [
    "node_modules",
    ".git",
    "dist",
    "build",
    ".next",
    ".venv",
    "__pycache__",
    "*.pyc",
    ".DS_Store",
    "._*",
    // macOS resource fork files
    ".mcp-use",
    // Build artifacts directory
    ".env",
    ".env.local",
    "*.log"
  ];
  const excludeFlags = excludePatterns.map((pattern) => `--exclude=${pattern}`).join(" ");
  const command = `tar ${excludeFlags} -czf "${tarballPath}" -C "${cwd}" . 2>&1 || true`;
  try {
    await execAsync2(command);
    return tarballPath;
  } catch (error) {
    throw new Error(
      `Failed to create tarball: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
function formatFileSize(bytes) {
  if (bytes === 0) return "0 B";
  const k = 1024;
  const sizes = ["B", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
}
async function displayDeploymentProgress(api, deployment) {
  const frames = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
  let frameIndex = 0;
  let spinnerInterval = null;
  let lastStep = "";
  const startSpinner = (message) => {
    if (spinnerInterval) {
      clearInterval(spinnerInterval);
    }
    process.stdout.write("\r\x1B[K");
    spinnerInterval = setInterval(() => {
      const frame = frames[frameIndex];
      frameIndex = (frameIndex + 1) % frames.length;
      process.stdout.write(
        "\r" + source_default.cyan(frame) + " " + source_default.gray(message)
      );
    }, 80);
  };
  const stopSpinner = () => {
    if (spinnerInterval) {
      clearInterval(spinnerInterval);
      spinnerInterval = null;
      process.stdout.write("\r\x1B[K");
    }
  };
  console.log();
  startSpinner("Deploying...");
  try {
    for await (const log of api.streamDeploymentLogs(deployment.id)) {
      try {
        const logData = JSON.parse(log);
        if (logData.step && logData.step !== lastStep) {
          lastStep = logData.step;
          const stepMessages = {
            clone: "Preparing source code...",
            analyze: "Analyzing project...",
            build: "Building container image...",
            deploy: "Deploying to cloud..."
          };
          const message = stepMessages[logData.step] || "Deploying...";
          startSpinner(message);
        }
        if (logData.line) {
          stopSpinner();
          const levelColor = logData.level === "error" ? source_default.red : logData.level === "warn" ? source_default.yellow : source_default.gray;
          const stepPrefix = logData.step ? source_default.cyan(`[${logData.step}]`) + " " : "";
          console.log(stepPrefix + levelColor(logData.line));
        }
      } catch {
      }
    }
  } catch (error) {
    stopSpinner();
  }
  let checkCount = 0;
  const maxChecks = 60;
  let delay = 3e3;
  const maxDelay = 1e4;
  let lastDisplayedLogLength = 0;
  while (checkCount < maxChecks) {
    const currentDelay = delay;
    await new Promise((resolve) => setTimeout(resolve, currentDelay));
    const finalDeployment = await api.getDeployment(deployment.id);
    if (finalDeployment.buildLogs && finalDeployment.buildLogs.length > lastDisplayedLogLength) {
      const newLogs = finalDeployment.buildLogs.substring(
        lastDisplayedLogLength
      );
      const logLines = newLogs.split("\n").filter((l) => l.trim());
      for (const line of logLines) {
        try {
          const logData = JSON.parse(line);
          if (logData.line) {
            stopSpinner();
            const levelColor = logData.level === "error" ? source_default.red : logData.level === "warn" ? source_default.yellow : source_default.gray;
            const stepPrefix = logData.step ? source_default.cyan(`[${logData.step}]`) + " " : "";
            console.log(stepPrefix + levelColor(logData.line));
          }
        } catch {
        }
      }
      lastDisplayedLogLength = finalDeployment.buildLogs.length;
    }
    if (finalDeployment.status === "running") {
      const mcpUrl = `https://${finalDeployment.domain}/mcp`;
      const inspectorUrl = `https://inspector.mcp-use.com/inspector?autoConnect=${encodeURIComponent(mcpUrl)}`;
      console.log(source_default.green.bold("\u2713 Deployment successful!\n"));
      console.log(source_default.white("\u{1F310} MCP Server URL:"));
      console.log(source_default.cyan.bold(`   ${mcpUrl}
`));
      console.log(source_default.white("\u{1F50D} Inspector URL:"));
      console.log(source_default.cyan.bold(`   ${inspectorUrl}
`));
      if (finalDeployment.customDomain) {
        const customMcpUrl = `https://${finalDeployment.customDomain}/mcp`;
        const customInspectorUrl = `https://inspector.mcp-use.com/inspect?autoConnect=${encodeURIComponent(customMcpUrl)}`;
        console.log(source_default.white("\u{1F517} Custom Domain:"));
        console.log(source_default.cyan.bold(`   ${customMcpUrl}
`));
        console.log(source_default.white("\u{1F50D} Custom Inspector:"));
        console.log(source_default.cyan.bold(`   ${customInspectorUrl}
`));
      }
      console.log(
        source_default.gray("Deployment ID: ") + source_default.white(finalDeployment.id)
      );
      return;
    } else if (finalDeployment.status === "failed") {
      console.log(source_default.red.bold("\u2717 Deployment failed\n"));
      if (finalDeployment.error) {
        console.log(source_default.red("Error: ") + finalDeployment.error);
      }
      if (finalDeployment.buildLogs) {
        console.log(source_default.gray("\nBuild logs:"));
        try {
          const logs = finalDeployment.buildLogs.split("\n").filter((l) => l.trim());
          for (const log of logs) {
            try {
              const logData = JSON.parse(log);
              if (logData.line) {
                console.log(source_default.gray(`  ${logData.line}`));
              }
            } catch {
              console.log(source_default.gray(`  ${log}`));
            }
          }
        } catch {
          console.log(source_default.gray(finalDeployment.buildLogs));
        }
      }
      process.exit(1);
    } else if (finalDeployment.status === "building") {
      startSpinner("Building and deploying...");
      checkCount++;
      delay = Math.min(delay * 1.2, maxDelay);
    } else {
      console.log(
        source_default.yellow("\u26A0\uFE0F  Deployment status: ") + finalDeployment.status
      );
      return;
    }
  }
  stopSpinner();
  console.log(source_default.yellow("\u26A0\uFE0F  Deployment is taking longer than expected."));
  console.log(
    source_default.gray("Check status with: ") + source_default.white(`mcp-use status ${deployment.id}`)
  );
}
async function deployCommand(options) {
  try {
    const cwd = process.cwd();
    if (!await isLoggedIn()) {
      console.log(source_default.red("\u2717 You are not logged in."));
      console.log(
        source_default.gray("Run " + source_default.white("mcp-use login") + " to get started.")
      );
      process.exit(1);
    }
    console.log(source_default.cyan.bold("\u{1F680} Deploying to mcp-use cloud...\n"));
    const isMcp = await isMcpProject(cwd);
    if (!isMcp) {
      console.log(
        source_default.yellow(
          "\u26A0\uFE0F  This doesn't appear to be an MCP server project (no mcp-use or @modelcontextprotocol/sdk dependency found)."
        )
      );
      const shouldContinue = await prompt(
        source_default.white("Continue anyway? (y/n): ")
      );
      if (!shouldContinue) {
        console.log(source_default.gray("Deployment cancelled."));
        process.exit(0);
      }
      console.log();
    }
    const gitInfo = await getGitInfo(cwd);
    if (!options.fromSource && gitInfo.isGitRepo && gitInfo.remoteUrl && isGitHubUrl(gitInfo.remoteUrl)) {
      if (!gitInfo.owner || !gitInfo.repo) {
        console.log(
          source_default.red(
            "\u2717 Could not parse GitHub repository information from remote URL."
          )
        );
        process.exit(1);
      }
      console.log(source_default.white("GitHub repository detected:"));
      console.log(
        source_default.gray(`  Repository: `) + source_default.cyan(`${gitInfo.owner}/${gitInfo.repo}`)
      );
      console.log(
        source_default.gray(`  Branch:     `) + source_default.cyan(gitInfo.branch || "main")
      );
      if (gitInfo.commitSha) {
        console.log(
          source_default.gray(`  Commit:     `) + source_default.gray(gitInfo.commitSha.substring(0, 7))
        );
      }
      if (gitInfo.commitMessage) {
        console.log(
          source_default.gray(`  Message:    `) + source_default.gray(gitInfo.commitMessage.split("\n")[0])
        );
      }
      console.log();
      const shouldDeploy = await prompt(
        source_default.white(
          `Deploy from GitHub repository ${gitInfo.owner}/${gitInfo.repo}? (y/n): `
        )
      );
      if (!shouldDeploy) {
        console.log(source_default.gray("Deployment cancelled."));
        process.exit(0);
      }
      const projectName = options.name || await getProjectName(cwd);
      const runtime = options.runtime || await detectRuntime(cwd);
      const port = options.port || 3e3;
      const buildCommand = await detectBuildCommand(cwd);
      const startCommand = await detectStartCommand(cwd);
      console.log();
      console.log(source_default.white("Deployment configuration:"));
      console.log(source_default.gray(`  Name:          `) + source_default.cyan(projectName));
      console.log(source_default.gray(`  Runtime:       `) + source_default.cyan(runtime));
      console.log(source_default.gray(`  Port:          `) + source_default.cyan(port));
      if (buildCommand) {
        console.log(source_default.gray(`  Build command: `) + source_default.cyan(buildCommand));
      }
      if (startCommand) {
        console.log(source_default.gray(`  Start command: `) + source_default.cyan(startCommand));
      }
      console.log();
      const deploymentRequest = {
        name: projectName,
        source: {
          type: "github",
          repo: `${gitInfo.owner}/${gitInfo.repo}`,
          branch: gitInfo.branch || "main",
          runtime,
          port,
          buildCommand,
          startCommand
        },
        healthCheckPath: "/healthz"
      };
      console.log(source_default.gray("Creating deployment..."));
      const api = await McpUseAPI.create();
      const deployment = await api.createDeployment(deploymentRequest);
      console.log(
        source_default.green("\u2713 Deployment created: ") + source_default.gray(deployment.id)
      );
      await displayDeploymentProgress(api, deployment);
      if (options.open && deployment.domain) {
        console.log();
        console.log(source_default.gray("Opening deployment in browser..."));
        await open_default(`https://${deployment.domain}`);
      }
    } else {
      if (options.fromSource) {
        console.log(
          source_default.white("\u{1F4E6} Deploying from local source code (--from-source)...")
        );
      } else {
        console.log(
          source_default.yellow(
            "\u26A0\uFE0F  This is not a GitHub repository or no remote is configured."
          )
        );
        console.log(source_default.white("Deploying from local source code instead..."));
      }
      console.log();
      const projectName = options.name || await getProjectName(cwd);
      const runtime = options.runtime || await detectRuntime(cwd);
      const port = options.port || 3e3;
      const buildCommand = await detectBuildCommand(cwd);
      const startCommand = await detectStartCommand(cwd);
      console.log(source_default.white("Deployment configuration:"));
      console.log(source_default.gray(`  Name:          `) + source_default.cyan(projectName));
      console.log(source_default.gray(`  Runtime:       `) + source_default.cyan(runtime));
      console.log(source_default.gray(`  Port:          `) + source_default.cyan(port));
      if (buildCommand) {
        console.log(source_default.gray(`  Build command: `) + source_default.cyan(buildCommand));
      }
      if (startCommand) {
        console.log(source_default.gray(`  Start command: `) + source_default.cyan(startCommand));
      }
      console.log();
      const shouldDeploy = await prompt(
        source_default.white("Deploy from local source? (y/n): "),
        "y"
      );
      if (!shouldDeploy) {
        console.log(source_default.gray("Deployment cancelled."));
        process.exit(0);
      }
      console.log();
      console.log(source_default.gray("Packaging source code..."));
      const tarballPath = await createTarball(cwd);
      const stats = await fs8.stat(tarballPath);
      console.log(
        source_default.green("\u2713 Packaged: ") + source_default.gray(formatFileSize(stats.size))
      );
      const maxSize = 2 * 1024 * 1024;
      if (stats.size > maxSize) {
        console.log(
          source_default.red(
            `\u2717 File size (${formatFileSize(stats.size)}) exceeds maximum of 2MB`
          )
        );
        await fs8.unlink(tarballPath);
        process.exit(1);
      }
      const deploymentRequest = {
        name: projectName,
        source: {
          type: "upload",
          runtime,
          port,
          buildCommand,
          startCommand
        },
        healthCheckPath: "/healthz"
      };
      console.log(source_default.gray("Creating deployment..."));
      const api = await McpUseAPI.create();
      const deployment = await api.createDeploymentWithUpload(
        deploymentRequest,
        tarballPath
      );
      await fs8.unlink(tarballPath);
      console.log(
        source_default.green("\u2713 Deployment created: ") + source_default.gray(deployment.id)
      );
      await displayDeploymentProgress(api, deployment);
      if (options.open && deployment.domain) {
        console.log();
        console.log(source_default.gray("Opening deployment in browser..."));
        await open_default(`https://${deployment.domain}`);
      }
    }
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Deployment failed:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}

// src/commands/client.ts
import { Command } from "commander";
import { createInterface } from "readline";
import { MCPClient } from "mcp-use/client";

// src/utils/session-storage.ts
import { homedir } from "os";
import { join } from "path";
import { readFile, writeFile, mkdir } from "fs/promises";
import { existsSync } from "fs";
var SESSION_FILE_PATH = join(homedir(), ".mcp-use", "cli-sessions.json");
async function ensureSessionDir() {
  const dir = join(homedir(), ".mcp-use");
  if (!existsSync(dir)) {
    await mkdir(dir, { recursive: true });
  }
}
async function loadSessions() {
  try {
    await ensureSessionDir();
    if (!existsSync(SESSION_FILE_PATH)) {
      return { activeSession: null, sessions: {} };
    }
    const content = await readFile(SESSION_FILE_PATH, "utf-8");
    return JSON.parse(content);
  } catch (error) {
    return { activeSession: null, sessions: {} };
  }
}
async function saveSessions(storage) {
  await ensureSessionDir();
  await writeFile(SESSION_FILE_PATH, JSON.stringify(storage, null, 2), "utf-8");
}
async function saveSession(name, config) {
  const storage = await loadSessions();
  storage.sessions[name] = {
    ...config,
    lastUsed: (/* @__PURE__ */ new Date()).toISOString()
  };
  if (!storage.activeSession) {
    storage.activeSession = name;
  }
  await saveSessions(storage);
}
async function getActiveSession() {
  const storage = await loadSessions();
  if (!storage.activeSession || !storage.sessions[storage.activeSession]) {
    return null;
  }
  return {
    name: storage.activeSession,
    config: storage.sessions[storage.activeSession]
  };
}
async function getSession(name) {
  const storage = await loadSessions();
  return storage.sessions[name] || null;
}
async function setActiveSession(name) {
  const storage = await loadSessions();
  if (!storage.sessions[name]) {
    throw new Error(`Session '${name}' not found`);
  }
  storage.activeSession = name;
  storage.sessions[name].lastUsed = (/* @__PURE__ */ new Date()).toISOString();
  await saveSessions(storage);
}
async function listAllSessions() {
  const storage = await loadSessions();
  return Object.entries(storage.sessions).map(([name, config]) => ({
    name,
    config,
    isActive: name === storage.activeSession
  }));
}
async function updateSessionInfo(name, serverInfo, capabilities) {
  const storage = await loadSessions();
  if (storage.sessions[name]) {
    storage.sessions[name].serverInfo = serverInfo;
    storage.sessions[name].capabilities = capabilities;
    storage.sessions[name].lastUsed = (/* @__PURE__ */ new Date()).toISOString();
    await saveSessions(storage);
  }
}

// src/utils/format.ts
function formatTable(data, columns) {
  if (data.length === 0) {
    return source_default.gray("No items found");
  }
  const widths = columns.map((col) => {
    const maxDataWidth = Math.max(
      ...data.map((row) => String(row[col.key] || "").length)
    );
    const headerWidth = col.header.length;
    return col.width || Math.max(maxDataWidth, headerWidth, 10);
  });
  const createRow = (values, bold = false) => {
    const cells = values.map((val, i) => {
      const padded = val.padEnd(widths[i]);
      return bold ? source_default.bold(padded) : padded;
    });
    return `\u2502 ${cells.join(" \u2502 ")} \u2502`;
  };
  const separator = (char) => {
    const parts = widths.map((w) => char.repeat(w + 2));
    if (char === "\u2500") {
      return `\u251C${parts.join("\u253C")}\u2524`;
    }
    return `\u2514${parts.join("\u2534")}\u2518`;
  };
  const lines = [];
  lines.push(`\u250C${widths.map((w) => "\u2500".repeat(w + 2)).join("\u252C")}\u2510`);
  lines.push(
    createRow(
      columns.map((c) => c.header),
      true
    )
  );
  lines.push(separator("\u2500"));
  data.forEach((row) => {
    lines.push(createRow(columns.map((c) => String(row[c.key] || ""))));
  });
  lines.push(separator("\u2500"));
  return lines.join("\n");
}
function formatJson(data, pretty = true) {
  if (pretty) {
    return JSON.stringify(data, null, 2);
  }
  return JSON.stringify(data);
}
function formatToolCall(result) {
  const lines = [];
  if (result.isError) {
    lines.push(source_default.red("\u2717 Tool execution failed"));
    lines.push("");
  } else {
    lines.push(source_default.green("\u2713 Tool executed successfully"));
    lines.push("");
  }
  if (result.content && result.content.length > 0) {
    result.content.forEach((item, index) => {
      if (result.content.length > 1) {
        lines.push(source_default.bold(`Content ${index + 1}:`));
      }
      if (item.type === "text") {
        lines.push(item.text);
      } else if (item.type === "image") {
        lines.push(source_default.cyan(`[Image: ${item.mimeType || "unknown type"}]`));
        if (item.data) {
          lines.push(source_default.gray(`Data: ${item.data.substring(0, 50)}...`));
        }
      } else if (item.type === "resource") {
        lines.push(source_default.cyan(`[Resource]`));
        if (item.resource?.uri) {
          lines.push(source_default.gray(`URI: ${item.resource.uri}`));
        }
        if (item.resource && "text" in item.resource && item.resource.text) {
          lines.push(item.resource.text);
        }
      } else {
        lines.push(source_default.gray(`[Unknown content type: ${item.type}]`));
      }
      if (index < result.content.length - 1) {
        lines.push("");
      }
    });
  }
  return lines.join("\n");
}
function formatResourceContent(content) {
  if (!content || !content.contents) {
    return source_default.gray("No content");
  }
  const lines = [];
  content.contents.forEach((item, index) => {
    if (content.contents.length > 1) {
      lines.push(source_default.bold(`Content ${index + 1}:`));
    }
    if (item.uri) {
      lines.push(source_default.gray(`URI: ${item.uri}`));
    }
    if (item.mimeType) {
      lines.push(source_default.gray(`Type: ${item.mimeType}`));
    }
    if ("text" in item && item.text) {
      lines.push("");
      lines.push(item.text);
    } else if ("blob" in item && item.blob) {
      lines.push("");
      lines.push(source_default.cyan(`[Binary data: ${item.blob.length} bytes]`));
    }
    if (index < content.contents.length - 1) {
      lines.push("");
      lines.push(source_default.gray("\u2500".repeat(50)));
      lines.push("");
    }
  });
  return lines.join("\n");
}
function formatSchema(schema, indent = 0) {
  if (!schema) {
    return source_default.gray("No schema");
  }
  const lines = [];
  const pad = "  ".repeat(indent);
  if (schema.type === "object" && schema.properties) {
    Object.entries(schema.properties).forEach(([key, value]) => {
      const required = schema.required?.includes(key);
      const type = value.type || "any";
      const desc = value.description || "";
      const keyStr = required ? source_default.bold(key) : key;
      const typeStr = source_default.cyan(`(${type})`);
      const requiredStr = required ? source_default.red(" *required") : "";
      lines.push(`${pad}${keyStr} ${typeStr}${requiredStr}`);
      if (desc) {
        lines.push(`${pad}  ${source_default.gray(desc)}`);
      }
      if (value.type === "object" && value.properties) {
        lines.push(formatSchema(value, indent + 1));
      }
      if (value.type === "array" && value.items) {
        lines.push(`${pad}  ${source_default.gray("Items:")}`);
        if (value.items.type === "object") {
          lines.push(formatSchema(value.items, indent + 2));
        } else {
          lines.push(
            `${pad}    ${source_default.cyan(`(${value.items.type || "any"})`)}`
          );
        }
      }
    });
  } else {
    lines.push(`${pad}${source_default.cyan(`Type: ${schema.type || "any"}`)}`);
    if (schema.description) {
      lines.push(`${pad}${source_default.gray(schema.description)}`);
    }
  }
  return lines.join("\n");
}
function formatError(error) {
  const message = typeof error === "string" ? error : error.message;
  return source_default.red(`\u2717 Error: ${message}`);
}
function formatSuccess(message) {
  return source_default.green(`\u2713 ${message}`);
}
function formatInfo(message) {
  return source_default.cyan(message);
}
function formatWarning(message) {
  return source_default.yellow(`\u26A0 ${message}`);
}
function formatHeader(text) {
  return source_default.bold.white(text);
}
function formatKeyValue(pairs) {
  const maxKeyLength = Math.max(...Object.keys(pairs).map((k) => k.length), 0);
  return Object.entries(pairs).map(([key, value]) => {
    const paddedKey = key.padEnd(maxKeyLength);
    return `  ${source_default.gray(paddedKey)}: ${value}`;
  }).join("\n");
}
function formatPromptMessages(messages) {
  if (!messages || messages.length === 0) {
    return source_default.gray("No messages");
  }
  const lines = [];
  messages.forEach((msg, index) => {
    const role = msg.role || "unknown";
    const roleStr = role === "user" ? source_default.blue("[User]") : role === "assistant" ? source_default.green("[Assistant]") : source_default.gray(`[${role}]`);
    lines.push(`${roleStr}`);
    if (msg.content) {
      if (typeof msg.content === "string") {
        lines.push(msg.content);
      } else if (msg.content.type === "text") {
        lines.push(msg.content.text);
      } else if (msg.content.type === "image") {
        lines.push(source_default.cyan(`[Image: ${msg.content.mimeType}]`));
      } else if (msg.content.type === "resource") {
        lines.push(source_default.cyan(`[Resource: ${msg.content.resource?.uri}]`));
        if (msg.content.resource?.text) {
          lines.push(msg.content.resource.text);
        }
      }
    }
    if (index < messages.length - 1) {
      lines.push("");
    }
  });
  return lines.join("\n");
}

// src/commands/client.ts
var activeSessions = /* @__PURE__ */ new Map();
async function getOrRestoreSession(sessionName) {
  if (!sessionName) {
    const active = await getActiveSession();
    if (!active) {
      console.error(
        formatError("No active session. Connect to a server first.")
      );
      console.error(
        formatInfo("Use: npx mcp-use client connect <url> --name <name>")
      );
      return null;
    }
    sessionName = active.name;
  }
  if (activeSessions.has(sessionName)) {
    const { session } = activeSessions.get(sessionName);
    return { name: sessionName, session };
  }
  const config = await getSession(sessionName);
  if (!config) {
    console.error(formatError(`Session '${sessionName}' not found`));
    return null;
  }
  try {
    const client = new MCPClient();
    if (config.type === "http") {
      client.addServer(sessionName, {
        url: config.url,
        headers: config.authToken ? { Authorization: `Bearer ${config.authToken}` } : void 0
      });
    } else if (config.type === "stdio") {
      client.addServer(sessionName, {
        command: config.command,
        args: config.args || [],
        env: config.env
      });
    } else {
      console.error(formatError(`Unknown session type: ${config.type}`));
      return null;
    }
    const session = await client.createSession(sessionName);
    activeSessions.set(sessionName, { client, session });
    console.error(formatInfo(`Reconnected to session '${sessionName}'`));
    return { name: sessionName, session };
  } catch (error) {
    console.error(formatError(`Failed to restore session: ${error.message}`));
    return null;
  }
}
async function connectCommand(urlOrCommand, options) {
  try {
    const sessionName = options.name || `session-${Date.now()}`;
    const client = new MCPClient();
    let session;
    if (options.stdio) {
      const parts = urlOrCommand.split(" ");
      const command = parts[0];
      const args = parts.slice(1);
      console.error(
        formatInfo(`Connecting to stdio server: ${command} ${args.join(" ")}`)
      );
      client.addServer(sessionName, {
        command,
        args
      });
      session = await client.createSession(sessionName);
      await saveSession(sessionName, {
        type: "stdio",
        command,
        args,
        lastUsed: (/* @__PURE__ */ new Date()).toISOString()
      });
    } else {
      console.error(formatInfo(`Connecting to ${urlOrCommand}...`));
      client.addServer(sessionName, {
        url: urlOrCommand,
        headers: options.auth ? { Authorization: `Bearer ${options.auth}` } : void 0
      });
      session = await client.createSession(sessionName);
      await saveSession(sessionName, {
        type: "http",
        url: urlOrCommand,
        authToken: options.auth,
        lastUsed: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
    activeSessions.set(sessionName, { client, session });
    const serverInfo = session.serverInfo;
    const capabilities = session.serverCapabilities;
    if (serverInfo) {
      await updateSessionInfo(sessionName, serverInfo, capabilities);
    }
    console.log(formatSuccess(`Connected to ${sessionName}`));
    if (serverInfo) {
      console.log("");
      console.log(formatHeader("Server Information:"));
      console.log(
        formatKeyValue({
          Name: serverInfo.name,
          Version: serverInfo.version || "unknown"
        })
      );
    }
    if (capabilities) {
      console.log("");
      console.log(formatHeader("Capabilities:"));
      const caps = Object.keys(capabilities).join(", ");
      console.log(`  ${caps || "none"}`);
    }
    const tools = session.tools;
    console.log("");
    console.log(
      formatInfo(
        `Available: ${tools.length} tool${tools.length !== 1 ? "s" : ""}`
      )
    );
  } catch (error) {
    console.error(formatError(`Connection failed: ${error.message}`));
    process.exit(1);
  }
}
async function disconnectCommand(sessionName, options) {
  try {
    if (options?.all) {
      for (const [name, { client }] of activeSessions.entries()) {
        await client.closeAllSessions();
        activeSessions.delete(name);
        console.log(formatSuccess(`Disconnected from ${name}`));
      }
      return;
    }
    if (!sessionName) {
      const active = await getActiveSession();
      if (!active) {
        console.error(formatError("No active session to disconnect"));
        return;
      }
      sessionName = active.name;
    }
    const sessionData = activeSessions.get(sessionName);
    if (sessionData) {
      await sessionData.client.closeAllSessions();
      activeSessions.delete(sessionName);
      console.log(formatSuccess(`Disconnected from ${sessionName}`));
    } else {
      console.log(formatInfo(`Session '${sessionName}' is not connected`));
    }
  } catch (error) {
    console.error(formatError(`Failed to disconnect: ${error.message}`));
    process.exit(1);
  }
}
async function listSessionsCommand() {
  try {
    const sessions = await listAllSessions();
    if (sessions.length === 0) {
      console.log(formatInfo("No saved sessions"));
      console.log(
        formatInfo("Connect to a server with: npx mcp-use client connect <url>")
      );
      return;
    }
    console.log(formatHeader("Saved Sessions:"));
    console.log("");
    const tableData = sessions.map((s) => ({
      name: s.isActive ? source_default.green.bold(`${s.name} *`) : s.name,
      type: s.config.type,
      target: s.config.type === "http" ? s.config.url || "" : `${s.config.command} ${(s.config.args || []).join(" ")}`,
      server: s.config.serverInfo?.name || "unknown",
      status: activeSessions.has(s.name) ? source_default.green("connected") : source_default.gray("disconnected")
    }));
    console.log(
      formatTable(tableData, [
        { key: "name", header: "Name" },
        { key: "type", header: "Type" },
        { key: "target", header: "Target", width: 40 },
        { key: "server", header: "Server" },
        { key: "status", header: "Status" }
      ])
    );
    console.log("");
    console.log(source_default.gray("* = active session"));
  } catch (error) {
    console.error(formatError(`Failed to list sessions: ${error.message}`));
    process.exit(1);
  }
}
async function switchSessionCommand(name) {
  try {
    await setActiveSession(name);
    console.log(formatSuccess(`Switched to session '${name}'`));
  } catch (error) {
    console.error(formatError(`Failed to switch session: ${error.message}`));
    process.exit(1);
  }
}
async function listToolsCommand(options) {
  try {
    const result = await getOrRestoreSession(options.session || null);
    if (!result) return;
    const { session } = result;
    const tools = await session.listTools();
    if (options.json) {
      console.log(formatJson(tools));
      return;
    }
    if (tools.length === 0) {
      console.log(formatInfo("No tools available"));
      return;
    }
    console.log(formatHeader(`Available Tools (${tools.length}):`));
    console.log("");
    const tableData = tools.map((tool) => ({
      name: source_default.bold(tool.name),
      description: tool.description || source_default.gray("No description")
    }));
    console.log(
      formatTable(tableData, [
        { key: "name", header: "Tool", width: 25 },
        { key: "description", header: "Description", width: 50 }
      ])
    );
  } catch (error) {
    console.error(formatError(`Failed to list tools: ${error.message}`));
    process.exit(1);
  }
}
async function describeToolCommand(toolName, options) {
  try {
    const result = await getOrRestoreSession(options.session || null);
    if (!result) return;
    const { session } = result;
    const tools = session.tools;
    const tool = tools.find((t) => t.name === toolName);
    if (!tool) {
      console.error(formatError(`Tool '${toolName}' not found`));
      console.log("");
      console.log(formatInfo("Available tools:"));
      tools.forEach((t) => console.log(`  \u2022 ${t.name}`));
      return;
    }
    console.log(formatHeader(`Tool: ${tool.name}`));
    console.log("");
    if (tool.description) {
      console.log(tool.description);
      console.log("");
    }
    if (tool.inputSchema) {
      console.log(formatHeader("Input Schema:"));
      console.log(formatSchema(tool.inputSchema));
    }
  } catch (error) {
    console.error(formatError(`Failed to describe tool: ${error.message}`));
    process.exit(1);
  }
}
async function callToolCommand(toolName, argsJson, options) {
  try {
    const result = await getOrRestoreSession(options?.session || null);
    if (!result) return;
    const { session } = result;
    let args = {};
    if (argsJson) {
      try {
        args = JSON.parse(argsJson);
      } catch (error) {
        console.error(formatError("Invalid JSON arguments"));
        return;
      }
    } else {
      const tools = session.tools;
      const tool = tools.find((t) => t.name === toolName);
      if (tool?.inputSchema?.required && tool.inputSchema.required.length > 0) {
        console.error(
          formatError(
            "This tool requires arguments. Provide them as a JSON string."
          )
        );
        console.log("");
        console.log(formatInfo("Example:"));
        console.log(
          `  npx mcp-use client tools call ${toolName} '{"param": "value"}'`
        );
        console.log("");
        console.log(formatInfo("Tool schema:"));
        console.log(formatSchema(tool.inputSchema));
        return;
      }
    }
    console.error(formatInfo(`Calling tool '${toolName}'...`));
    const callResult = await session.callTool(toolName, args, {
      timeout: options?.timeout
    });
    if (options?.json) {
      console.log(formatJson(callResult));
    } else {
      console.log(formatToolCall(callResult));
    }
  } catch (error) {
    console.error(formatError(`Failed to call tool: ${error.message}`));
    process.exit(1);
  }
}
async function listResourcesCommand(options) {
  try {
    const result = await getOrRestoreSession(options.session || null);
    if (!result) return;
    const { session } = result;
    const resourcesResult = await session.listAllResources();
    const resources = resourcesResult.resources;
    if (options.json) {
      console.log(formatJson(resources));
      return;
    }
    if (resources.length === 0) {
      console.log(formatInfo("No resources available"));
      return;
    }
    console.log(formatHeader(`Available Resources (${resources.length}):`));
    console.log("");
    const tableData = resources.map((resource) => ({
      uri: resource.uri,
      name: resource.name || source_default.gray("(no name)"),
      type: resource.mimeType || source_default.gray("unknown")
    }));
    console.log(
      formatTable(tableData, [
        { key: "uri", header: "URI", width: 40 },
        { key: "name", header: "Name", width: 20 },
        { key: "type", header: "Type", width: 15 }
      ])
    );
  } catch (error) {
    console.error(formatError(`Failed to list resources: ${error.message}`));
    process.exit(1);
  }
}
async function readResourceCommand(uri, options) {
  try {
    const result = await getOrRestoreSession(options.session || null);
    if (!result) return;
    const { session } = result;
    console.error(formatInfo(`Reading resource: ${uri}`));
    const resource = await session.readResource(uri);
    if (options.json) {
      console.log(formatJson(resource));
    } else {
      console.log(formatResourceContent(resource));
    }
  } catch (error) {
    console.error(formatError(`Failed to read resource: ${error.message}`));
    process.exit(1);
  }
}
async function subscribeResourceCommand(uri, options) {
  try {
    const result = await getOrRestoreSession(options.session || null);
    if (!result) return;
    const { session } = result;
    await session.subscribeToResource(uri);
    console.log(formatSuccess(`Subscribed to resource: ${uri}`));
    session.on("notification", async (notification) => {
      if (notification.method === "notifications/resources/updated") {
        console.log("");
        console.log(formatInfo("Resource updated:"));
        console.log(formatJson(notification.params));
      }
    });
    console.log(formatInfo("Listening for updates... (Press Ctrl+C to stop)"));
    await new Promise(() => {
    });
  } catch (error) {
    console.error(
      formatError(`Failed to subscribe to resource: ${error.message}`)
    );
    process.exit(1);
  }
}
async function unsubscribeResourceCommand(uri, options) {
  try {
    const result = await getOrRestoreSession(options.session || null);
    if (!result) return;
    const { session } = result;
    await session.unsubscribeFromResource(uri);
    console.log(formatSuccess(`Unsubscribed from resource: ${uri}`));
  } catch (error) {
    console.error(
      formatError(`Failed to unsubscribe from resource: ${error.message}`)
    );
    process.exit(1);
  }
}
async function listPromptsCommand(options) {
  try {
    const result = await getOrRestoreSession(options.session || null);
    if (!result) return;
    const { session } = result;
    const promptsResult = await session.listPrompts();
    const prompts = promptsResult.prompts;
    if (options.json) {
      console.log(formatJson(prompts));
      return;
    }
    if (prompts.length === 0) {
      console.log(formatInfo("No prompts available"));
      return;
    }
    console.log(formatHeader(`Available Prompts (${prompts.length}):`));
    console.log("");
    const tableData = prompts.map((prompt2) => ({
      name: source_default.bold(prompt2.name),
      description: prompt2.description || source_default.gray("No description")
    }));
    console.log(
      formatTable(tableData, [
        { key: "name", header: "Prompt", width: 25 },
        { key: "description", header: "Description", width: 50 }
      ])
    );
  } catch (error) {
    console.error(formatError(`Failed to list prompts: ${error.message}`));
    process.exit(1);
  }
}
async function getPromptCommand(promptName, argsJson, options) {
  try {
    const result = await getOrRestoreSession(options?.session || null);
    if (!result) return;
    const { session } = result;
    let args = {};
    if (argsJson) {
      try {
        args = JSON.parse(argsJson);
      } catch (error) {
        console.error(formatError("Invalid JSON arguments"));
        return;
      }
    }
    console.error(formatInfo(`Getting prompt '${promptName}'...`));
    const prompt2 = await session.getPrompt(promptName, args);
    if (options?.json) {
      console.log(formatJson(prompt2));
    } else {
      console.log(formatHeader(`Prompt: ${promptName}`));
      console.log("");
      if (prompt2.description) {
        console.log(prompt2.description);
        console.log("");
      }
      if (prompt2.messages) {
        console.log(formatHeader("Messages:"));
        console.log("");
        console.log(formatPromptMessages(prompt2.messages));
      }
    }
  } catch (error) {
    console.error(formatError(`Failed to get prompt: ${error.message}`));
    process.exit(1);
  }
}
async function interactiveCommand(options) {
  try {
    const result = await getOrRestoreSession(options.session || null);
    if (!result) return;
    const { name: sessionName, session } = result;
    console.log(formatHeader("MCP Interactive Mode"));
    console.log("");
    console.log(formatInfo(`Connected to: ${sessionName}`));
    console.log("");
    console.log(source_default.gray("Commands:"));
    console.log(source_default.gray("  tools list              - List available tools"));
    console.log(
      source_default.gray(
        "  tools call <name>       - Call a tool (will prompt for args)"
      )
    );
    console.log(source_default.gray("  tools describe <name>   - Show tool details"));
    console.log(
      source_default.gray("  resources list          - List available resources")
    );
    console.log(source_default.gray("  resources read <uri>    - Read a resource"));
    console.log(
      source_default.gray("  prompts list            - List available prompts")
    );
    console.log(source_default.gray("  prompts get <name>      - Get a prompt"));
    console.log(source_default.gray("  sessions list           - List all sessions"));
    console.log(
      source_default.gray("  sessions switch <name>  - Switch to another session")
    );
    console.log(
      source_default.gray("  exit, quit              - Exit interactive mode")
    );
    console.log("");
    const rl = createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt: source_default.cyan("mcp> ")
    });
    rl.prompt();
    rl.on("line", async (line) => {
      const trimmed = line.trim();
      if (!trimmed) {
        rl.prompt();
        return;
      }
      if (trimmed === "exit" || trimmed === "quit") {
        console.log(formatInfo("Goodbye!"));
        rl.close();
        process.exit(0);
      }
      const parts = trimmed.split(" ");
      const scope = parts[0];
      const command = parts[1];
      const arg = parts[2];
      try {
        if (scope === "tools") {
          if (command === "list") {
            const tools = await session.listTools();
            console.log(
              formatInfo(
                `Available tools: ${tools.map((t) => t.name).join(", ")}`
              )
            );
          } else if (command === "call" && arg) {
            rl.question(
              "Arguments (JSON, or press Enter for none): ",
              async (argsInput) => {
                try {
                  const args = argsInput.trim() ? JSON.parse(argsInput) : {};
                  const result2 = await session.callTool(arg, args);
                  console.log(formatToolCall(result2));
                } catch (error) {
                  console.error(formatError(error.message));
                }
                rl.prompt();
              }
            );
            return;
          } else if (command === "describe" && arg) {
            const tools = session.tools;
            const tool = tools.find((t) => t.name === arg);
            if (tool) {
              console.log(formatHeader(`Tool: ${tool.name}`));
              if (tool.description) console.log(tool.description);
              if (tool.inputSchema) {
                console.log("");
                console.log(formatSchema(tool.inputSchema));
              }
            } else {
              console.error(formatError(`Tool '${arg}' not found`));
            }
          } else {
            console.error(
              formatError(
                "Invalid command. Try: tools list, tools call <name>, tools describe <name>"
              )
            );
          }
        } else if (scope === "resources") {
          if (command === "list") {
            const result2 = await session.listAllResources();
            const resources = result2.resources;
            console.log(
              formatInfo(
                `Available resources: ${resources.map((r) => r.uri).join(", ")}`
              )
            );
          } else if (command === "read" && arg) {
            const resource = await session.readResource(arg);
            console.log(formatResourceContent(resource));
          } else {
            console.error(
              formatError(
                "Invalid command. Try: resources list, resources read <uri>"
              )
            );
          }
        } else if (scope === "prompts") {
          if (command === "list") {
            const result2 = await session.listPrompts();
            const prompts = result2.prompts;
            console.log(
              formatInfo(
                `Available prompts: ${prompts.map((p) => p.name).join(", ")}`
              )
            );
          } else if (command === "get" && arg) {
            rl.question(
              "Arguments (JSON, or press Enter for none): ",
              async (argsInput) => {
                try {
                  const args = argsInput.trim() ? JSON.parse(argsInput) : {};
                  const prompt2 = await session.getPrompt(arg, args);
                  console.log(formatPromptMessages(prompt2.messages));
                } catch (error) {
                  console.error(formatError(error.message));
                }
                rl.prompt();
              }
            );
            return;
          } else {
            console.error(
              formatError(
                "Invalid command. Try: prompts list, prompts get <name>"
              )
            );
          }
        } else if (scope === "sessions") {
          if (command === "list") {
            await listSessionsCommand();
          } else if (command === "switch" && arg) {
            console.log(
              formatWarning(
                "Session switching in interactive mode will be available in a future version"
              )
            );
          } else {
            console.error(formatError("Invalid command. Try: sessions list"));
          }
        } else {
          console.error(
            formatError(
              "Unknown command. Type a valid scope: tools, resources, prompts, sessions"
            )
          );
        }
      } catch (error) {
        console.error(formatError(error.message));
      }
      rl.prompt();
    });
    rl.on("close", () => {
      console.log("");
      console.log(formatInfo("Goodbye!"));
      process.exit(0);
    });
  } catch (error) {
    console.error(
      formatError(`Failed to start interactive mode: ${error.message}`)
    );
    process.exit(1);
  }
}
function createClientCommand() {
  const clientCommand = new Command("client").description(
    "Interactive MCP client for terminal usage"
  );
  clientCommand.command("connect <url>").description("Connect to an MCP server").option("--name <name>", "Session name").option("--stdio", "Use stdio connector instead of HTTP").option("--auth <token>", "Authentication token").action(connectCommand);
  clientCommand.command("disconnect [session]").description("Disconnect from a session").option("--all", "Disconnect all sessions").action(disconnectCommand);
  const sessionsCommand = new Command("sessions").description(
    "Manage CLI sessions"
  );
  sessionsCommand.command("list").description("List all saved sessions").action(listSessionsCommand);
  sessionsCommand.command("switch <name>").description("Switch to a different session").action(switchSessionCommand);
  clientCommand.addCommand(sessionsCommand);
  const toolsCommand = new Command("tools").description(
    "Interact with MCP tools"
  );
  toolsCommand.command("list").description("List available tools").option("--session <name>", "Use specific session").option("--json", "Output as JSON").action(listToolsCommand);
  toolsCommand.command("call <name> [args]").description("Call a tool with arguments (JSON string)").option("--session <name>", "Use specific session").option("--timeout <ms>", "Request timeout in milliseconds", parseInt).option("--json", "Output as JSON").action(callToolCommand);
  toolsCommand.command("describe <name>").description("Show tool details and schema").option("--session <name>", "Use specific session").action(describeToolCommand);
  clientCommand.addCommand(toolsCommand);
  const resourcesCommand = new Command("resources").description(
    "Interact with MCP resources"
  );
  resourcesCommand.command("list").description("List available resources").option("--session <name>", "Use specific session").option("--json", "Output as JSON").action(listResourcesCommand);
  resourcesCommand.command("read <uri>").description("Read a resource by URI").option("--session <name>", "Use specific session").option("--json", "Output as JSON").action(readResourceCommand);
  resourcesCommand.command("subscribe <uri>").description("Subscribe to resource updates").option("--session <name>", "Use specific session").action(subscribeResourceCommand);
  resourcesCommand.command("unsubscribe <uri>").description("Unsubscribe from resource updates").option("--session <name>", "Use specific session").action(unsubscribeResourceCommand);
  clientCommand.addCommand(resourcesCommand);
  const promptsCommand = new Command("prompts").description(
    "Interact with MCP prompts"
  );
  promptsCommand.command("list").description("List available prompts").option("--session <name>", "Use specific session").option("--json", "Output as JSON").action(listPromptsCommand);
  promptsCommand.command("get <name> [args]").description("Get a prompt with arguments (JSON string)").option("--session <name>", "Use specific session").option("--json", "Output as JSON").action(getPromptCommand);
  clientCommand.addCommand(promptsCommand);
  clientCommand.command("interactive").description("Start interactive REPL mode").option("--session <name>", "Use specific session").action(interactiveCommand);
  return clientCommand;
}

// src/index.ts
import { toJSONSchema } from "zod";
var program = new Command2();
var packageContent = readFileSync(
  path5.join(__dirname, "../package.json"),
  "utf-8"
);
var packageJson = JSON.parse(packageContent);
var packageVersion = packageJson.version || "unknown";
program.name("mcp-use").description("Create and run MCP servers with ui resources widgets").version(packageVersion);
async function isPortAvailable(port, host = "localhost") {
  try {
    await fetch(`http://${host}:${port}`);
    return false;
  } catch {
    return true;
  }
}
async function findAvailablePort2(startPort, host = "localhost") {
  for (let port = startPort; port < startPort + 100; port++) {
    if (await isPortAvailable(port, host)) {
      return port;
    }
  }
  throw new Error("No available ports found");
}
async function waitForServer(port, host = "localhost", maxAttempts = 30) {
  for (let i = 0; i < maxAttempts; i++) {
    const controller = new AbortController();
    try {
      const response = await fetch(`http://${host}:${port}/inspector/health`, {
        signal: controller.signal
      });
      if (response.ok) {
        return true;
      }
    } catch {
    } finally {
      controller.abort();
    }
    await new Promise((resolve) => setTimeout(resolve, 1e3));
  }
  return false;
}
function runCommand(command, args, cwd, env2, filterStderr = false) {
  const proc = spawn(command, args, {
    cwd,
    stdio: filterStderr ? ["inherit", "inherit", "pipe"] : "inherit",
    shell: false,
    env: env2 ? { ...process.env, ...env2 } : process.env
  });
  if (filterStderr && proc.stderr) {
    proc.stderr.on("data", (data) => {
      const text = data.toString();
      if (!text.includes("Previous process hasn't exited yet") && !text.includes("Force killing")) {
        process.stderr.write(data);
      }
    });
  }
  const promise = new Promise((resolve, reject) => {
    proc.on("error", reject);
    proc.on("exit", (code) => {
      if (code === 0 || code === 130 || code === 143) {
        resolve();
      } else {
        reject(new Error(`Command failed with exit code ${code}`));
      }
    });
  });
  return { promise, process: proc };
}
async function startTunnel(port, subdomain) {
  return new Promise((resolve, reject) => {
    console.log(source_default.gray(`Starting tunnel for port ${port}...`));
    const tunnelArgs = ["--yes", "@mcp-use/tunnel", String(port)];
    if (subdomain) {
      tunnelArgs.push("--subdomain", subdomain);
    }
    const proc = spawn("npx", tunnelArgs, {
      stdio: ["ignore", "pipe", "pipe"],
      shell: false
    });
    let resolved = false;
    let isShuttingDown = false;
    proc.stdout?.on("data", (data) => {
      const text = data.toString();
      const isShutdownMessage = text.includes("Shutting down") || text.includes("\u{1F6D1}");
      if (!isShuttingDown && !isShutdownMessage) {
        process.stdout.write(text);
      }
      const urlMatch = text.match(/https?:\/\/([a-z0-9-]+\.[a-z0-9.-]+)/i);
      if (urlMatch && !resolved) {
        const url = urlMatch[0];
        const fullDomain = urlMatch[1];
        const subdomainMatch = fullDomain.match(/^([a-z0-9-]+)\./i);
        let extractedSubdomain = subdomainMatch ? subdomainMatch[1] : fullDomain.split(".")[0];
        if (!/^[a-z0-9-]+$/i.test(extractedSubdomain)) {
          console.warn(
            source_default.yellow(
              `Warning: Extracted subdomain "${extractedSubdomain}" does not match expected format.`
            )
          );
          extractedSubdomain = "";
        }
        resolved = true;
        clearTimeout(setupTimeout);
        console.log(source_default.green.bold(`\u2713 Tunnel established: ${url}/mcp`));
        resolve({ url, subdomain: extractedSubdomain, process: proc });
      }
    });
    proc.stderr?.on("data", (data) => {
      const text = data.toString();
      if (!isShuttingDown && !text.includes("INFO") && !text.includes("bore_cli") && !text.includes("Shutting down")) {
        process.stderr.write(data);
      }
    });
    proc.on("error", (error) => {
      if (!resolved) {
        clearTimeout(setupTimeout);
        reject(new Error(`Failed to start tunnel: ${error.message}`));
      }
    });
    proc.on("exit", (code) => {
      if (code !== 0 && !resolved) {
        clearTimeout(setupTimeout);
        reject(new Error(`Tunnel process exited with code ${code}`));
      }
    });
    proc.markShutdown = () => {
      isShuttingDown = true;
    };
    const setupTimeout = setTimeout(() => {
      if (!resolved) {
        proc.kill();
        reject(new Error("Tunnel setup timed out"));
      }
    }, 3e4);
  });
}
async function findServerFile(projectPath) {
  const candidates = ["index.ts", "src/index.ts", "server.ts", "src/server.ts"];
  for (const candidate of candidates) {
    try {
      await access(path5.join(projectPath, candidate));
      return candidate;
    } catch {
      continue;
    }
  }
  throw new Error("No server file found");
}
async function buildWidgets(projectPath) {
  const { promises: fs9 } = await import("fs");
  const { build } = await import("vite");
  const resourcesDir = path5.join(projectPath, "resources");
  const mcpUrl = process.env.MCP_URL;
  try {
    await access(resourcesDir);
  } catch {
    console.log(
      source_default.gray("No resources/ directory found - skipping widget build")
    );
    return [];
  }
  const entries = [];
  try {
    const files = await fs9.readdir(resourcesDir, { withFileTypes: true });
    for (const dirent of files) {
      if (dirent.name.startsWith("._") || dirent.name.startsWith(".DS_Store")) {
        continue;
      }
      if (dirent.isFile() && (dirent.name.endsWith(".tsx") || dirent.name.endsWith(".ts"))) {
        entries.push({
          name: dirent.name.replace(/\.tsx?$/, ""),
          path: path5.join(resourcesDir, dirent.name)
        });
      } else if (dirent.isDirectory()) {
        const widgetPath = path5.join(resourcesDir, dirent.name, "widget.tsx");
        try {
          await fs9.access(widgetPath);
          entries.push({
            name: dirent.name,
            path: widgetPath
          });
        } catch {
        }
      }
    }
  } catch (error) {
    console.log(source_default.gray("No widgets found in resources/ directory"));
    return [];
  }
  if (entries.length === 0) {
    console.log(source_default.gray("No widgets found in resources/ directory"));
    return [];
  }
  console.log(source_default.gray(`Building ${entries.length} widget(s)...`));
  const react = (await import("@vitejs/plugin-react")).default;
  const tailwindcss = (await import("@tailwindcss/vite")).default;
  const packageJsonPath = path5.join(projectPath, "package.json");
  let favicon = "";
  try {
    const pkgContent = await fs9.readFile(packageJsonPath, "utf-8");
    const pkg = JSON.parse(pkgContent);
    favicon = pkg.mcpUse?.favicon || "";
  } catch {
  }
  const builtWidgets = [];
  for (const entry of entries) {
    const widgetName = entry.name;
    const entryPath = entry.path;
    console.log(source_default.gray(`  - Building ${widgetName}...`));
    const tempDir = path5.join(projectPath, ".mcp-use", widgetName);
    await fs9.mkdir(tempDir, { recursive: true });
    const relativeResourcesPath = path5.relative(tempDir, resourcesDir).replace(/\\/g, "/");
    const mcpUsePath = path5.join(projectPath, "node_modules", "mcp-use");
    const relativeMcpUsePath = path5.relative(tempDir, mcpUsePath).replace(/\\/g, "/");
    const cssContent = `@import "tailwindcss";

/* Configure Tailwind to scan the resources directory and mcp-use package */
@source "${relativeResourcesPath}";
@source "${relativeMcpUsePath}/**/*.{ts,tsx,js,jsx}";
`;
    await fs9.writeFile(path5.join(tempDir, "styles.css"), cssContent, "utf8");
    const entryContent = `import React from 'react'
import { createRoot } from 'react-dom/client'
import './styles.css'
import Component from '${entryPath}'

const container = document.getElementById('widget-root')
if (container && Component) {
  const root = createRoot(container)
  root.render(<Component />)
}
`;
    const htmlContent = `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>${widgetName} Widget</title>${favicon ? `
    <link rel="icon" href="/mcp-use/public/${favicon}" />` : ""}
  </head>
  <body>
    <div id="widget-root"></div>
    <script type="module" src="/entry.tsx"></script>
  </body>
</html>`;
    await fs9.writeFile(path5.join(tempDir, "entry.tsx"), entryContent, "utf8");
    await fs9.writeFile(path5.join(tempDir, "index.html"), htmlContent, "utf8");
    const outDir = path5.join(
      projectPath,
      "dist",
      "resources",
      "widgets",
      widgetName
    );
    const baseUrl = mcpUrl ? `${mcpUrl}/${widgetName}/` : `/mcp-use/widgets/${widgetName}/`;
    let widgetMetadata = {};
    try {
      const metadataTempDir = path5.join(
        projectPath,
        ".mcp-use",
        `${widgetName}-metadata`
      );
      await fs9.mkdir(metadataTempDir, { recursive: true });
      const { createServer: createServer2 } = await import("vite");
      const nodeStubsPlugin = {
        name: "node-stubs",
        enforce: "pre",
        resolveId(id) {
          if (id === "posthog-node" || id.startsWith("posthog-node/")) {
            return "\0virtual:posthog-node-stub";
          }
          return null;
        },
        load(id) {
          if (id === "\0virtual:posthog-node-stub") {
            return `
export class PostHog {
  constructor() {}
  capture() {}
  identify() {}
  alias() {}
  flush() { return Promise.resolve(); }
  shutdown() { return Promise.resolve(); }
}
export default PostHog;
`;
          }
          return null;
        }
      };
      const metadataServer = await createServer2({
        root: metadataTempDir,
        cacheDir: path5.join(metadataTempDir, ".vite-cache"),
        plugins: [nodeStubsPlugin, tailwindcss(), react()],
        resolve: {
          alias: {
            "@": resourcesDir
          }
        },
        server: {
          middlewareMode: true
        },
        optimizeDeps: {
          // Exclude Node.js-only packages from browser bundling
          exclude: ["posthog-node"]
        },
        ssr: {
          // Force Vite to transform these packages in SSR instead of using external requires
          noExternal: ["@openai/apps-sdk-ui", "react-router"],
          // Mark Node.js-only packages as external in SSR mode
          external: ["posthog-node"]
        },
        define: {
          // Define process.env for SSR context
          "process.env.NODE_ENV": JSON.stringify(
            process.env.NODE_ENV || "development"
          ),
          "import.meta.env.DEV": true,
          "import.meta.env.PROD": false,
          "import.meta.env.MODE": JSON.stringify("development"),
          "import.meta.env.SSR": true
        },
        clearScreen: false,
        logLevel: "silent",
        customLogger: {
          info: () => {
          },
          warn: () => {
          },
          error: () => {
          },
          clearScreen: () => {
          },
          hasErrorLogged: () => false,
          hasWarned: false,
          warnOnce: () => {
          }
        }
      });
      try {
        const mod = await metadataServer.ssrLoadModule(entryPath);
        if (mod.widgetMetadata) {
          const schemaField = mod.widgetMetadata.props || mod.widgetMetadata.inputs;
          let inputsValue = schemaField || {};
          if (schemaField && typeof schemaField === "object" && "~standard" in schemaField) {
            try {
              inputsValue = toJSONSchema(schemaField);
            } catch (conversionError) {
              console.warn(
                source_default.yellow(
                  `    \u26A0 Could not convert schema for ${widgetName}, using raw schema`
                )
              );
            }
          }
          const {
            props: _rawProps,
            inputs: _rawInputs,
            ...restMetadata
          } = mod.widgetMetadata;
          widgetMetadata = {
            ...restMetadata,
            title: mod.widgetMetadata.title || widgetName,
            description: mod.widgetMetadata.description,
            // Store the converted JSON Schema (props field is used by production mount)
            props: inputsValue,
            inputs: inputsValue
          };
        }
        await new Promise((resolve) => setTimeout(resolve, 50));
      } catch (error) {
        console.warn(
          source_default.yellow(`    \u26A0 Could not extract metadata for ${widgetName}`)
        );
      } finally {
        await metadataServer.close();
        try {
          await fs9.rm(metadataTempDir, { recursive: true, force: true });
        } catch {
        }
      }
    } catch (error) {
    }
    try {
      const buildNodeStubsPlugin = {
        name: "node-stubs-build",
        enforce: "pre",
        resolveId(id) {
          if (id === "posthog-node" || id.startsWith("posthog-node/")) {
            return "\0virtual:posthog-node-stub";
          }
          if (id === "path" || id === "node:path") {
            return "\0virtual:path-stub";
          }
          return null;
        },
        load(id) {
          if (id === "\0virtual:posthog-node-stub") {
            return `
export class PostHog {
  constructor() {}
  capture() {}
  identify() {}
  alias() {}
  flush() { return Promise.resolve(); }
  shutdown() { return Promise.resolve(); }
}
export default PostHog;
`;
          }
          if (id === "\0virtual:path-stub") {
            return `
export function join(...paths) {
  return paths.filter(Boolean).join("/").replace(/\\/\\//g, "/").replace(/\\/$/, "");
}
export function resolve(...paths) {
  return join(...paths);
}
export function dirname(filepath) {
  const parts = filepath.split("/");
  parts.pop();
  return parts.join("/") || "/";
}
export function basename(filepath, ext) {
  const parts = filepath.split("/");
  let name = parts[parts.length - 1] || "";
  if (ext && name.endsWith(ext)) {
    name = name.slice(0, -ext.length);
  }
  return name;
}
export function extname(filepath) {
  const name = basename(filepath);
  const index = name.lastIndexOf(".");
  return index > 0 ? name.slice(index) : "";
}
export function normalize(filepath) {
  return filepath.replace(/\\/\\//g, "/");
}
export function isAbsolute(filepath) {
  return filepath.startsWith("/");
}
export const sep = "/";
export const delimiter = ":";
export const posix = {
  join,
  resolve,
  dirname,
  basename,
  extname,
  normalize,
  isAbsolute,
  sep,
  delimiter,
};
export default {
  join,
  resolve,
  dirname,
  basename,
  extname,
  normalize,
  isAbsolute,
  sep,
  delimiter,
  posix,
};
`;
          }
          return null;
        }
      };
      await build({
        root: tempDir,
        base: baseUrl,
        plugins: [buildNodeStubsPlugin, tailwindcss(), react()],
        experimental: {
          renderBuiltUrl: (filename, { hostType }) => {
            if (["js", "css"].includes(hostType)) {
              return {
                runtime: `window.__getFile(${JSON.stringify(filename)})`
              };
            } else {
              return { relative: true };
            }
          }
        },
        resolve: {
          alias: {
            "@": resourcesDir
          }
        },
        optimizeDeps: {
          // Exclude Node.js-only packages from browser bundling
          exclude: ["posthog-node"]
        },
        build: {
          outDir,
          emptyOutDir: true,
          rollupOptions: {
            input: path5.join(tempDir, "index.html"),
            external: (id) => {
              return false;
            }
          }
        }
      });
      const mcpServerUrl = process.env.MCP_SERVER_URL;
      if (mcpServerUrl) {
        try {
          const htmlPath = path5.join(outDir, "index.html");
          let html = await fs9.readFile(htmlPath, "utf8");
          const injectionScript = `<script>window.__getFile = (filename) => { return "${mcpUrl}/${widgetName}/"+filename }; window.__mcpPublicUrl = "${mcpServerUrl}/mcp-use/public"; window.__mcpPublicAssetsUrl = "${mcpUrl}/public";</script>`;
          if (!html.includes("window.__mcpPublicUrl")) {
            html = html.replace(
              /<head[^>]*>/i,
              `<head>
    ${injectionScript}`
            );
          }
          if (/<base\s+[^>]*\/?>/i.test(html)) {
            html = html.replace(
              /<base\s+[^>]*\/?>/i,
              `<base href="${mcpServerUrl}">`
            );
          } else {
            html = html.replace(
              injectionScript,
              `${injectionScript}
    <base href="${mcpServerUrl}">`
            );
          }
          await fs9.writeFile(htmlPath, html, "utf8");
          console.log(
            source_default.gray(`    \u2192 Injected MCP_SERVER_URL into ${widgetName}`)
          );
        } catch (error) {
          console.warn(
            source_default.yellow(
              `    \u26A0 Failed to post-process HTML for ${widgetName}:`,
              error
            )
          );
        }
      }
      builtWidgets.push({
        name: widgetName,
        metadata: widgetMetadata
      });
      console.log(source_default.green(`    \u2713 Built ${widgetName}`));
    } catch (error) {
      console.error(source_default.red(`    \u2717 Failed to build ${widgetName}:`), error);
    }
  }
  return builtWidgets;
}
program.command("build").description("Build TypeScript and MCP UI widgets").option("-p, --path <path>", "Path to project directory", process.cwd()).option("--with-inspector", "Include inspector in production build").action(async (options) => {
  try {
    const projectPath = path5.resolve(options.path);
    const { promises: fs9 } = await import("fs");
    console.log(source_default.cyan.bold(`mcp-use v${packageJson.version}`));
    const builtWidgets = await buildWidgets(projectPath);
    console.log(source_default.gray("Building TypeScript..."));
    await runCommand("npx", ["tsc"], projectPath);
    console.log(source_default.green("\u2713 TypeScript build complete!"));
    const publicDir = path5.join(projectPath, "public");
    try {
      await fs9.access(publicDir);
      console.log(source_default.gray("Copying public assets..."));
      await fs9.cp(publicDir, path5.join(projectPath, "dist", "public"), {
        recursive: true
      });
      console.log(source_default.green("\u2713 Public assets copied"));
    } catch {
    }
    const manifestPath = path5.join(projectPath, "dist", "mcp-use.json");
    let existingManifest = {};
    try {
      const existingContent = await fs9.readFile(manifestPath, "utf-8");
      existingManifest = JSON.parse(existingContent);
    } catch {
    }
    const widgetsData = {};
    for (const widget of builtWidgets) {
      widgetsData[widget.name] = widget.metadata;
    }
    const includeInspector = !!options.withInspector;
    const buildTime = (/* @__PURE__ */ new Date()).toISOString();
    const { createHash } = await import("crypto");
    const buildId = createHash("sha256").update(buildTime + Math.random().toString()).digest("hex").substring(0, 16);
    const manifest = {
      ...existingManifest,
      // Preserve existing fields like tunnel
      includeInspector,
      buildTime,
      buildId,
      widgets: widgetsData
    };
    await fs9.mkdir(path5.dirname(manifestPath), { recursive: true });
    await fs9.writeFile(
      manifestPath,
      JSON.stringify(manifest, null, 2),
      "utf8"
    );
    console.log(source_default.green("\u2713 Build manifest created"));
    console.log(source_default.green.bold(`
\u2713 Build complete!`));
    if (builtWidgets.length > 0) {
      console.log(source_default.gray(`  ${builtWidgets.length} widget(s) built`));
    }
    if (options.withInspector) {
      console.log(source_default.gray("  Inspector included"));
    }
  } catch (error) {
    console.error(source_default.red("Build failed:"), error);
    process.exit(1);
  }
});
program.command("dev").description("Run development server with auto-reload and inspector").option("-p, --path <path>", "Path to project directory", process.cwd()).option("--port <port>", "Server port", "3000").option("--host <host>", "Server host", "localhost").option("--no-open", "Do not auto-open inspector").action(async (options) => {
  try {
    const projectPath = path5.resolve(options.path);
    let port = parseInt(options.port, 10);
    const host = options.host;
    console.log(source_default.cyan.bold(`mcp-use v${packageJson.version}`));
    if (!await isPortAvailable(port, host)) {
      console.log(source_default.yellow.bold(`\u26A0\uFE0F  Port ${port} is already in use`));
      const availablePort = await findAvailablePort2(port, host);
      console.log(source_default.green.bold(`\u2713 Using port ${availablePort} instead`));
      port = availablePort;
    }
    const serverFile = await findServerFile(projectPath);
    const processes = [];
    const env2 = {
      PORT: String(port),
      HOST: host,
      NODE_ENV: "development"
    };
    const serverCommand = runCommand(
      "npx",
      ["tsx", "watch", serverFile],
      projectPath,
      env2,
      true
    );
    processes.push(serverCommand.process);
    if (options.open !== false) {
      const startTime = Date.now();
      const ready = await waitForServer(port, host);
      if (ready) {
        const mcpEndpoint = `http://${host}:${port}/mcp`;
        const inspectorUrl = `http://${host}:${port}/inspector?autoConnect=${encodeURIComponent(mcpEndpoint)}`;
        const readyTime = Date.now() - startTime;
        console.log(source_default.green.bold(`\u2713 Ready in ${readyTime}ms`));
        console.log(source_default.whiteBright(`Local:    http://${host}:${port}`));
        console.log(source_default.whiteBright(`Network:  http://${host}:${port}`));
        console.log(source_default.whiteBright(`MCP:      ${mcpEndpoint}`));
        console.log(source_default.whiteBright(`Inspector: ${inspectorUrl}
`));
        await open_default(inspectorUrl);
      }
    }
    const cleanup = () => {
      console.log(source_default.gray("\n\nShutting down..."));
      const processesToKill = processes.length;
      let killedCount = 0;
      const checkAndExit = () => {
        killedCount++;
        if (killedCount >= processesToKill) {
          process.exit(0);
        }
      };
      processes.forEach((proc) => {
        if (proc && typeof proc.kill === "function") {
          proc.on("exit", checkAndExit);
          proc.kill("SIGINT");
        } else {
          checkAndExit();
        }
      });
      setTimeout(() => {
        processes.forEach((proc) => {
          if (proc && typeof proc.kill === "function" && proc.exitCode === null) {
            proc.kill("SIGKILL");
          }
        });
        process.exit(0);
      }, 1e3);
    };
    process.on("SIGINT", cleanup);
    process.on("SIGTERM", cleanup);
    await new Promise(() => {
    });
  } catch (error) {
    console.error(source_default.red("Dev mode failed:"), error);
    process.exit(1);
  }
});
program.command("start").description("Start production server").option("-p, --path <path>", "Path to project directory", process.cwd()).option("--port <port>", "Server port", "3000").option("--tunnel", "Expose server through a tunnel").action(async (options) => {
  try {
    const projectPath = path5.resolve(options.path);
    const port = parseInt(options.port, 10);
    console.log(
      `\x1B[36m\x1B[1mmcp-use\x1B[0m \x1B[90mVersion: ${packageJson.version}\x1B[0m
`
    );
    let mcpUrl;
    let tunnelProcess = void 0;
    let tunnelSubdomain = void 0;
    if (options.tunnel) {
      try {
        const manifestPath = path5.join(projectPath, "dist", "mcp-use.json");
        let existingSubdomain;
        try {
          const manifestContent = await readFile2(manifestPath, "utf-8");
          const manifest = JSON.parse(manifestContent);
          existingSubdomain = manifest.tunnel?.subdomain;
          if (existingSubdomain) {
            console.log(
              source_default.gray(`Found existing subdomain: ${existingSubdomain}`)
            );
          }
        } catch (error) {
          console.debug(
            source_default.gray(
              `Debug: Failed to read or parse mcp-use.json: ${error instanceof Error ? error.message : String(error)}`
            )
          );
        }
        const tunnelInfo = await startTunnel(port, existingSubdomain);
        mcpUrl = tunnelInfo.url;
        tunnelProcess = tunnelInfo.process;
        const subdomain = tunnelInfo.subdomain;
        tunnelSubdomain = subdomain;
        try {
          let manifest = {};
          try {
            const manifestContent = await readFile2(manifestPath, "utf-8");
            manifest = JSON.parse(manifestContent);
          } catch {
          }
          if (!manifest.tunnel) {
            manifest.tunnel = {};
          }
          manifest.tunnel.subdomain = subdomain;
          await mkdir2(path5.dirname(manifestPath), { recursive: true });
          await writeFile2(
            manifestPath,
            JSON.stringify(manifest, null, 2),
            "utf-8"
          );
        } catch (error) {
          console.warn(
            source_default.yellow(
              `\u26A0\uFE0F  Failed to save subdomain to mcp-use.json: ${error instanceof Error ? error.message : "Unknown error"}`
            )
          );
        }
      } catch (error) {
        console.error(source_default.red("Failed to start tunnel:"), error);
        process.exit(1);
      }
    }
    let serverFile = "dist/index.js";
    try {
      await access(path5.join(projectPath, serverFile));
    } catch {
      serverFile = "dist/server.js";
    }
    console.log("Starting production server...");
    const env2 = {
      ...process.env,
      PORT: String(port),
      NODE_ENV: "production"
    };
    if (mcpUrl) {
      env2.MCP_URL = mcpUrl;
      console.log(source_default.whiteBright(`Tunnel:   ${mcpUrl}/mcp`));
    }
    const serverProc = spawn("node", [serverFile], {
      cwd: projectPath,
      stdio: "inherit",
      env: env2
    });
    let cleanupInProgress = false;
    const cleanup = async () => {
      if (cleanupInProgress) {
        return;
      }
      cleanupInProgress = true;
      console.log(source_default.gray("\n\nShutting down..."));
      if (tunnelProcess && typeof tunnelProcess.markShutdown === "function") {
        tunnelProcess.markShutdown();
      }
      if (tunnelSubdomain) {
        try {
          const apiBase = process.env.MCP_USE_API || "https://local.mcp-use.run";
          await fetch(`${apiBase}/api/tunnels/${tunnelSubdomain}`, {
            method: "DELETE"
          });
        } catch (err) {
        }
      }
      const processesToKill = 1 + (tunnelProcess ? 1 : 0);
      let killedCount = 0;
      const checkAndExit = () => {
        killedCount++;
        if (killedCount >= processesToKill) {
          process.exit(0);
        }
      };
      serverProc.on("exit", checkAndExit);
      serverProc.kill("SIGTERM");
      if (tunnelProcess && typeof tunnelProcess.kill === "function") {
        tunnelProcess.on("exit", checkAndExit);
        tunnelProcess.kill("SIGINT");
      } else {
        checkAndExit();
      }
      setTimeout(() => {
        if (serverProc.exitCode === null) {
          serverProc.kill("SIGKILL");
        }
        if (tunnelProcess && tunnelProcess.exitCode === null) {
          tunnelProcess.kill("SIGKILL");
        }
        process.exit(0);
      }, 2e3);
    };
    process.on("SIGINT", cleanup);
    process.on("SIGTERM", cleanup);
    serverProc.on("exit", (code) => {
      process.exit(code || 0);
    });
  } catch (error) {
    console.error("Start failed:", error);
    process.exit(1);
  }
});
program.command("login").description("Login to mcp-use cloud").action(async () => {
  await loginCommand();
});
program.command("logout").description("Logout from mcp-use cloud").action(async () => {
  await logoutCommand();
});
program.command("whoami").description("Show current user information").action(async () => {
  await whoamiCommand();
});
program.command("deploy").description("Deploy MCP server to mcp-use cloud").option("--open", "Open deployment in browser after successful deploy").option("--name <name>", "Custom deployment name").option("--port <port>", "Server port", "3000").option("--runtime <runtime>", "Runtime (node or python)").option(
  "--from-source",
  "Deploy from local source code (even for GitHub repos)"
).action(async (options) => {
  await deployCommand({
    open: options.open,
    name: options.name,
    port: options.port ? parseInt(options.port, 10) : void 0,
    runtime: options.runtime,
    fromSource: options.fromSource
  });
});
program.addCommand(createClientCommand());
program.parse();
//# sourceMappingURL=index.js.map