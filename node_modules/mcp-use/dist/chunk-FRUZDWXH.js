import {
  __name,
  __require
} from "./chunk-3GQAWCBQ.js";

// src/logging.ts
async function getNodeModules() {
  if (typeof process !== "undefined" && process.platform) {
    try {
      const fs = await import("fs");
      const path = await import("path");
      return { fs: fs.default, path: path.default };
    } catch {
      return { fs: null, path: null };
    }
  }
  return { fs: null, path: null };
}
__name(getNodeModules, "getNodeModules");
var winston = null;
function loadWinstonSync() {
  if (typeof __require !== "undefined") {
    try {
      winston = __require("winston");
    } catch {
    }
  }
}
__name(loadWinstonSync, "loadWinstonSync");
async function getWinston() {
  if (!winston) {
    winston = await import("winston");
  }
  return winston;
}
__name(getWinston, "getWinston");
var DEFAULT_LOGGER_NAME = "mcp-use";
function isNodeJSEnvironment() {
  try {
    if (typeof navigator !== "undefined" && navigator.userAgent?.includes("Cloudflare-Workers")) {
      return false;
    }
    if (typeof globalThis.EdgeRuntime !== "undefined" || typeof globalThis.Deno !== "undefined") {
      return false;
    }
    const hasNodeGlobals = typeof process !== "undefined" && typeof process.platform !== "undefined" && typeof __dirname !== "undefined";
    return hasNodeGlobals;
  } catch {
    return false;
  }
}
__name(isNodeJSEnvironment, "isNodeJSEnvironment");
var SimpleConsoleLogger = class {
  static {
    __name(this, "SimpleConsoleLogger");
  }
  _level;
  name;
  constructor(name = DEFAULT_LOGGER_NAME, level = "info") {
    this.name = name;
    this._level = level;
  }
  shouldLog(level) {
    const levels = [
      "error",
      "warn",
      "info",
      "http",
      "verbose",
      "debug",
      "silly"
    ];
    const currentIndex = levels.indexOf(this._level);
    const messageIndex = levels.indexOf(level);
    return messageIndex <= currentIndex;
  }
  formatMessage(level, message) {
    const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", { hour12: false });
    return `${timestamp} [${this.name}] ${level}: ${message}`;
  }
  error(message) {
    if (this.shouldLog("error")) {
      console.error(this.formatMessage("error", message));
    }
  }
  warn(message) {
    if (this.shouldLog("warn")) {
      console.warn(this.formatMessage("warn", message));
    }
  }
  info(message) {
    if (this.shouldLog("info")) {
      console.info(this.formatMessage("info", message));
    }
  }
  debug(message) {
    if (this.shouldLog("debug")) {
      console.debug(this.formatMessage("debug", message));
    }
  }
  http(message) {
    if (this.shouldLog("http")) {
      console.log(this.formatMessage("http", message));
    }
  }
  verbose(message) {
    if (this.shouldLog("verbose")) {
      console.log(this.formatMessage("verbose", message));
    }
  }
  silly(message) {
    if (this.shouldLog("silly")) {
      console.log(this.formatMessage("silly", message));
    }
  }
  // Make it compatible with Winston interface
  get level() {
    return this._level;
  }
  set level(newLevel) {
    this._level = newLevel;
  }
};
function resolveLevel(env) {
  const envValue = typeof process !== "undefined" && process.env ? env : void 0;
  switch (envValue?.trim()) {
    case "2":
      return "debug";
    case "1":
      return "info";
    default:
      return "info";
  }
}
__name(resolveLevel, "resolveLevel");
var Logger = class {
  static {
    __name(this, "Logger");
  }
  static instances = {};
  static simpleInstances = {};
  static currentFormat = "minimal";
  static get(name = DEFAULT_LOGGER_NAME) {
    if (!isNodeJSEnvironment()) {
      if (!this.simpleInstances[name]) {
        const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
        this.simpleInstances[name] = new SimpleConsoleLogger(
          name,
          resolveLevel(debugEnv)
        );
      }
      return this.simpleInstances[name];
    }
    if (!this.instances[name]) {
      if (!winston) {
        throw new Error("Winston not loaded - call Logger.configure() first");
      }
      const { createLogger, format } = winston;
      const { combine, timestamp, label, colorize, splat } = format;
      this.instances[name] = createLogger({
        level: resolveLevel(process.env.DEBUG),
        format: combine(
          colorize(),
          splat(),
          label({ label: name }),
          timestamp({ format: "HH:mm:ss" }),
          this.getFormatter()
        ),
        transports: [new winston.transports.Console()]
      });
    }
    return this.instances[name];
  }
  static getFormatter() {
    if (!winston) {
      throw new Error("Winston not loaded");
    }
    const { format } = winston;
    const { printf } = format;
    const minimalFormatter = printf(({ level, message, label, timestamp }) => {
      return `${timestamp} [${label}] ${level}: ${message}`;
    });
    const detailedFormatter = printf(({ level, message, label, timestamp }) => {
      return `${timestamp} [${label}] ${level.toUpperCase()}: ${message}`;
    });
    const emojiFormatter = printf(({ level, message, label, timestamp }) => {
      return `${timestamp} [${label}] ${level.toUpperCase()}: ${message}`;
    });
    switch (this.currentFormat) {
      case "minimal":
        return minimalFormatter;
      case "detailed":
        return detailedFormatter;
      case "emoji":
        return emojiFormatter;
      default:
        return minimalFormatter;
    }
  }
  static async configure(options = {}) {
    const { level, console: console2 = true, file, format = "minimal" } = options;
    const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
    const resolvedLevel = level ?? resolveLevel(debugEnv);
    this.currentFormat = format;
    if (!isNodeJSEnvironment()) {
      Object.values(this.simpleInstances).forEach((logger2) => {
        logger2.level = resolvedLevel;
      });
      return;
    }
    await getWinston();
    if (!winston) {
      throw new Error("Failed to load winston");
    }
    const root = this.get();
    root.level = resolvedLevel;
    const winstonRoot = root;
    winstonRoot.clear();
    if (console2) {
      winstonRoot.add(new winston.transports.Console());
    }
    if (file) {
      const { fs: nodeFs, path: nodePath } = await getNodeModules();
      if (nodeFs && nodePath) {
        const dir = nodePath.dirname(nodePath.resolve(file));
        if (!nodeFs.existsSync(dir)) {
          nodeFs.mkdirSync(dir, { recursive: true });
        }
        winstonRoot.add(new winston.transports.File({ filename: file }));
      }
    }
    const { format: winstonFormat } = winston;
    const { combine, timestamp, label, colorize, splat } = winstonFormat;
    Object.values(this.instances).forEach((logger2) => {
      if (logger2 && "format" in logger2) {
        logger2.level = resolvedLevel;
        logger2.format = combine(
          colorize(),
          splat(),
          label({ label: DEFAULT_LOGGER_NAME }),
          timestamp({ format: "HH:mm:ss" }),
          this.getFormatter()
        );
      }
    });
  }
  static setDebug(enabled) {
    let level;
    if (enabled === 2 || enabled === true) level = "debug";
    else if (enabled === 1) level = "info";
    else level = "info";
    Object.values(this.simpleInstances).forEach((logger2) => {
      logger2.level = level;
    });
    Object.values(this.instances).forEach((logger2) => {
      if (logger2) {
        logger2.level = level;
      }
    });
    if (typeof process !== "undefined" && process.env) {
      process.env.DEBUG = enabled ? enabled === true ? "2" : String(enabled) : "0";
    }
  }
  static setFormat(format) {
    this.currentFormat = format;
    this.configure({ format });
  }
};
if (isNodeJSEnvironment()) {
  loadWinstonSync();
  if (winston) {
    Logger.configure();
  }
}
var logger = Logger.get();

export {
  Logger,
  logger
};
