"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/telemetry/events.ts
function createServerRunEventData(server, transport) {
  const toolRegistrations = Array.from(server.registrations.tools.values());
  const promptRegistrations = Array.from(server.registrations.prompts.values());
  const resourceRegistrations = Array.from(
    server.registrations.resources.values()
  );
  const templateRegistrations = Array.from(
    server.registrations.resourceTemplates.values()
  );
  const allResources = resourceRegistrations.map((r) => ({
    name: r.config.name,
    title: r.config.title ?? null,
    description: r.config.description ?? null,
    uri: r.config.uri ?? null,
    mime_type: r.config.mimeType ?? null
  }));
  const appsSdkResources = allResources.filter(
    (r) => r.mime_type === "text/html+skybridge"
  );
  const mcpUiResources = allResources.filter(
    (r) => r.mime_type === "text/uri-list" || r.mime_type === "text/html"
  );
  const mcpAppsResources = allResources.filter(
    (r) => r.mime_type === "text/html+mcp"
  );
  return {
    transport,
    toolsNumber: server.registeredTools.length,
    resourcesNumber: server.registeredResources.length,
    promptsNumber: server.registeredPrompts.length,
    auth: !!server.oauthProvider,
    name: server.config.name,
    description: server.config.description ?? null,
    baseUrl: server.serverBaseUrl ?? null,
    toolNames: server.registeredTools.length > 0 ? server.registeredTools : null,
    resourceNames: server.registeredResources.length > 0 ? server.registeredResources : null,
    promptNames: server.registeredPrompts.length > 0 ? server.registeredPrompts : null,
    tools: toolRegistrations.length > 0 ? toolRegistrations.map((r) => ({
      name: r.config.name,
      title: r.config.title ?? null,
      description: r.config.description ?? null,
      input_schema: r.config.schema ? JSON.stringify(r.config.schema) : null,
      output_schema: r.config.outputSchema ? JSON.stringify(r.config.outputSchema) : null
    })) : null,
    resources: allResources.length > 0 ? allResources : null,
    prompts: promptRegistrations.length > 0 ? promptRegistrations.map((r) => ({
      name: r.config.name,
      title: r.config.title ?? null,
      description: r.config.description ?? null,
      args: r.config.args ? JSON.stringify(r.config.args) : null
    })) : null,
    templates: templateRegistrations.length > 0 ? templateRegistrations.map((r) => ({
      name: r.config.name,
      title: r.config.title ?? null,
      description: r.config.description ?? null
    })) : null,
    capabilities: {
      logging: true,
      resources: { subscribe: true, listChanged: true }
    },
    appsSdkResources: appsSdkResources.length > 0 ? appsSdkResources : null,
    appsSdkResourcesNumber: appsSdkResources.length,
    mcpUiResources: mcpUiResources.length > 0 ? mcpUiResources : null,
    mcpUiResourcesNumber: mcpUiResources.length,
    mcpAppsResources: mcpAppsResources.length > 0 ? mcpAppsResources : null,
    mcpAppsResourcesNumber: mcpAppsResources.length
  };
}
var BaseTelemetryEvent, MCPAgentExecutionEvent, ServerRunEvent, ServerInitializeEvent, ServerToolCallEvent, ServerResourceCallEvent, ServerPromptCallEvent, ServerContextEvent, MCPClientInitEvent, ConnectorInitEvent, ClientAddServerEvent, ClientRemoveServerEvent;
var init_events = __esm({
  "src/telemetry/events.ts"() {
    "use strict";
    BaseTelemetryEvent = class {
      static {
        __name(this, "BaseTelemetryEvent");
      }
    };
    MCPAgentExecutionEvent = class extends BaseTelemetryEvent {
      constructor(data) {
        super();
        this.data = data;
      }
      static {
        __name(this, "MCPAgentExecutionEvent");
      }
      get name() {
        return "mcp_agent_execution";
      }
      get properties() {
        return {
          // Core execution info
          execution_method: this.data.executionMethod,
          query: this.data.query,
          query_length: this.data.query.length,
          success: this.data.success,
          // Agent configuration
          model_provider: this.data.modelProvider,
          model_name: this.data.modelName,
          server_count: this.data.serverCount,
          server_identifiers: this.data.serverIdentifiers,
          total_tools_available: this.data.totalToolsAvailable,
          tools_available_names: this.data.toolsAvailableNames,
          max_steps_configured: this.data.maxStepsConfigured,
          memory_enabled: this.data.memoryEnabled,
          use_server_manager: this.data.useServerManager,
          // Execution parameters (always include, even if null)
          max_steps_used: this.data.maxStepsUsed,
          manage_connector: this.data.manageConnector,
          external_history_used: this.data.externalHistoryUsed,
          // Execution results (always include, even if null)
          steps_taken: this.data.stepsTaken ?? null,
          tools_used_count: this.data.toolsUsedCount ?? null,
          tools_used_names: this.data.toolsUsedNames ?? null,
          response: this.data.response ?? null,
          response_length: this.data.response ? this.data.response.length : null,
          execution_time_ms: this.data.executionTimeMs ?? null,
          error_type: this.data.errorType ?? null,
          conversation_history_length: this.data.conversationHistoryLength ?? null
        };
      }
    };
    __name(createServerRunEventData, "createServerRunEventData");
    ServerRunEvent = class extends BaseTelemetryEvent {
      constructor(data) {
        super();
        this.data = data;
      }
      static {
        __name(this, "ServerRunEvent");
      }
      get name() {
        return "server_run";
      }
      get properties() {
        return {
          transport: this.data.transport,
          tools_number: this.data.toolsNumber,
          resources_number: this.data.resourcesNumber,
          prompts_number: this.data.promptsNumber,
          auth: this.data.auth,
          name: this.data.name,
          description: this.data.description ?? null,
          base_url: this.data.baseUrl ?? null,
          tool_names: this.data.toolNames ?? null,
          resource_names: this.data.resourceNames ?? null,
          prompt_names: this.data.promptNames ?? null,
          tools: this.data.tools ?? null,
          resources: this.data.resources ?? null,
          prompts: this.data.prompts ?? null,
          templates: this.data.templates ?? null,
          capabilities: this.data.capabilities ? JSON.stringify(this.data.capabilities) : null,
          apps_sdk_resources: this.data.appsSdkResources ? JSON.stringify(this.data.appsSdkResources) : null,
          apps_sdk_resources_number: this.data.appsSdkResourcesNumber ?? 0,
          mcp_ui_resources: this.data.mcpUiResources ? JSON.stringify(this.data.mcpUiResources) : null,
          mcp_ui_resources_number: this.data.mcpUiResourcesNumber ?? 0,
          mcp_apps_resources: this.data.mcpAppsResources ? JSON.stringify(this.data.mcpAppsResources) : null,
          mcp_apps_resources_number: this.data.mcpAppsResourcesNumber ?? 0
        };
      }
    };
    ServerInitializeEvent = class extends BaseTelemetryEvent {
      constructor(data) {
        super();
        this.data = data;
      }
      static {
        __name(this, "ServerInitializeEvent");
      }
      get name() {
        return "server_initialize_call";
      }
      get properties() {
        return {
          protocol_version: this.data.protocolVersion,
          client_info: JSON.stringify(this.data.clientInfo),
          client_capabilities: JSON.stringify(this.data.clientCapabilities),
          session_id: this.data.sessionId ?? null
        };
      }
    };
    ServerToolCallEvent = class extends BaseTelemetryEvent {
      constructor(data) {
        super();
        this.data = data;
      }
      static {
        __name(this, "ServerToolCallEvent");
      }
      get name() {
        return "server_tool_call";
      }
      get properties() {
        return {
          tool_name: this.data.toolName,
          length_input_argument: this.data.lengthInputArgument,
          success: this.data.success,
          error_type: this.data.errorType ?? null,
          execution_time_ms: this.data.executionTimeMs ?? null
        };
      }
    };
    ServerResourceCallEvent = class extends BaseTelemetryEvent {
      constructor(data) {
        super();
        this.data = data;
      }
      static {
        __name(this, "ServerResourceCallEvent");
      }
      get name() {
        return "server_resource_call";
      }
      get properties() {
        return {
          name: this.data.name,
          description: this.data.description,
          contents: this.data.contents,
          success: this.data.success,
          error_type: this.data.errorType ?? null
        };
      }
    };
    ServerPromptCallEvent = class extends BaseTelemetryEvent {
      constructor(data) {
        super();
        this.data = data;
      }
      static {
        __name(this, "ServerPromptCallEvent");
      }
      get name() {
        return "server_prompt_call";
      }
      get properties() {
        return {
          name: this.data.name,
          description: this.data.description,
          success: this.data.success,
          error_type: this.data.errorType ?? null
        };
      }
    };
    ServerContextEvent = class extends BaseTelemetryEvent {
      constructor(data) {
        super();
        this.data = data;
      }
      static {
        __name(this, "ServerContextEvent");
      }
      get name() {
        return `server_context_${this.data.contextType}`;
      }
      get properties() {
        return {
          context_type: this.data.contextType,
          notification_type: this.data.notificationType ?? null
        };
      }
    };
    MCPClientInitEvent = class extends BaseTelemetryEvent {
      constructor(data) {
        super();
        this.data = data;
      }
      static {
        __name(this, "MCPClientInitEvent");
      }
      get name() {
        return "mcpclient_init";
      }
      get properties() {
        return {
          code_mode: this.data.codeMode,
          sandbox: this.data.sandbox,
          all_callbacks: this.data.allCallbacks,
          verify: this.data.verify,
          servers: this.data.servers,
          num_servers: this.data.numServers,
          is_browser: this.data.isBrowser
        };
      }
    };
    ConnectorInitEvent = class extends BaseTelemetryEvent {
      constructor(data) {
        super();
        this.data = data;
      }
      static {
        __name(this, "ConnectorInitEvent");
      }
      get name() {
        return "connector_init";
      }
      get properties() {
        return {
          connector_type: this.data.connectorType,
          server_command: this.data.serverCommand ?? null,
          server_args: this.data.serverArgs ?? null,
          server_url: this.data.serverUrl ?? null,
          public_identifier: this.data.publicIdentifier ?? null
        };
      }
    };
    ClientAddServerEvent = class extends BaseTelemetryEvent {
      constructor(data) {
        super();
        this.data = data;
      }
      static {
        __name(this, "ClientAddServerEvent");
      }
      get name() {
        return "client_add_server";
      }
      get properties() {
        const { serverName, serverConfig } = this.data;
        const url = serverConfig.url;
        return {
          server_name: serverName,
          server_url_domain: url ? this._extractHostname(url) : null,
          transport: serverConfig.transport ?? null,
          has_auth: !!(serverConfig.authToken || serverConfig.authProvider)
        };
      }
      _extractHostname(url) {
        try {
          return new URL(url).hostname;
        } catch {
          return null;
        }
      }
    };
    ClientRemoveServerEvent = class extends BaseTelemetryEvent {
      constructor(data) {
        super();
        this.data = data;
      }
      static {
        __name(this, "ClientRemoveServerEvent");
      }
      get name() {
        return "client_remove_server";
      }
      get properties() {
        return {
          server_name: this.data.serverName
        };
      }
    };
  }
});

// src/server/utils/runtime.ts
function getEnv(key) {
  if (isDeno) {
    return globalThis.Deno.env.get(key);
  }
  return process.env[key];
}
function getCwd() {
  if (isDeno) {
    return globalThis.Deno.cwd();
  }
  return process.cwd();
}
function generateUUID() {
  return globalThis.crypto.randomUUID();
}
var isDeno, fsHelpers, pathHelpers;
var init_runtime = __esm({
  "src/server/utils/runtime.ts"() {
    "use strict";
    isDeno = typeof globalThis.Deno !== "undefined";
    __name(getEnv, "getEnv");
    __name(getCwd, "getCwd");
    fsHelpers = {
      async readFileSync(path, encoding = "utf8") {
        if (isDeno) {
          return await globalThis.Deno.readTextFile(path);
        }
        const { readFileSync: readFileSync2 } = await import("fs");
        const result = readFileSync2(path, encoding);
        return typeof result === "string" ? result : result.toString(encoding);
      },
      async readFile(path) {
        if (isDeno) {
          const data = await globalThis.Deno.readFile(path);
          return data.buffer;
        }
        const { readFileSync: readFileSync2 } = await import("fs");
        const buffer = readFileSync2(path);
        return buffer.buffer.slice(
          buffer.byteOffset,
          buffer.byteOffset + buffer.byteLength
        );
      },
      async existsSync(path) {
        if (isDeno) {
          try {
            await globalThis.Deno.stat(path);
            return true;
          } catch {
            return false;
          }
        }
        const { existsSync: existsSync2 } = await import("fs");
        return existsSync2(path);
      },
      async readdirSync(path) {
        if (isDeno) {
          const entries = [];
          for await (const entry of globalThis.Deno.readDir(path)) {
            entries.push(entry.name);
          }
          return entries;
        }
        const { readdirSync } = await import("fs");
        return readdirSync(path);
      }
    };
    pathHelpers = {
      join(...paths) {
        if (isDeno) {
          return paths.join("/").replace(/\/+/g, "/");
        }
        return paths.join("/").replace(/\/+/g, "/");
      },
      relative(from, to) {
        const fromParts = from.split("/").filter((p) => p);
        const toParts = to.split("/").filter((p) => p);
        let i = 0;
        while (i < fromParts.length && i < toParts.length && fromParts[i] === toParts[i]) {
          i++;
        }
        const upCount = fromParts.length - i;
        const relativeParts = [...Array(upCount).fill(".."), ...toParts.slice(i)];
        return relativeParts.join("/");
      }
    };
    __name(generateUUID, "generateUUID");
  }
});

// src/logging.ts
async function getNodeModules() {
  if (typeof process !== "undefined" && process.platform) {
    try {
      const fs = await import("fs");
      const path = await import("path");
      return { fs: fs.default, path: path.default };
    } catch {
      return { fs: null, path: null };
    }
  }
  return { fs: null, path: null };
}
function loadWinstonSync() {
  if (typeof require !== "undefined") {
    try {
      winston = require("winston");
    } catch {
    }
  }
}
async function getWinston() {
  if (!winston) {
    winston = await import("winston");
  }
  return winston;
}
function isNodeJSEnvironment() {
  try {
    if (typeof navigator !== "undefined" && navigator.userAgent?.includes("Cloudflare-Workers")) {
      return false;
    }
    if (typeof globalThis.EdgeRuntime !== "undefined" || typeof globalThis.Deno !== "undefined") {
      return false;
    }
    const hasNodeGlobals = typeof process !== "undefined" && typeof process.platform !== "undefined" && typeof __dirname !== "undefined";
    return hasNodeGlobals;
  } catch {
    return false;
  }
}
function resolveLevel(env) {
  const envValue = typeof process !== "undefined" && process.env ? env : void 0;
  switch (envValue?.trim()) {
    case "2":
      return "debug";
    case "1":
      return "info";
    default:
      return "info";
  }
}
var winston, DEFAULT_LOGGER_NAME, SimpleConsoleLogger, Logger, logger;
var init_logging = __esm({
  "src/logging.ts"() {
    "use strict";
    __name(getNodeModules, "getNodeModules");
    winston = null;
    __name(loadWinstonSync, "loadWinstonSync");
    __name(getWinston, "getWinston");
    DEFAULT_LOGGER_NAME = "mcp-use";
    __name(isNodeJSEnvironment, "isNodeJSEnvironment");
    SimpleConsoleLogger = class {
      static {
        __name(this, "SimpleConsoleLogger");
      }
      _level;
      name;
      constructor(name = DEFAULT_LOGGER_NAME, level = "info") {
        this.name = name;
        this._level = level;
      }
      shouldLog(level) {
        const levels = [
          "error",
          "warn",
          "info",
          "http",
          "verbose",
          "debug",
          "silly"
        ];
        const currentIndex = levels.indexOf(this._level);
        const messageIndex = levels.indexOf(level);
        return messageIndex <= currentIndex;
      }
      formatMessage(level, message) {
        const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", { hour12: false });
        return `${timestamp} [${this.name}] ${level}: ${message}`;
      }
      error(message) {
        if (this.shouldLog("error")) {
          console.error(this.formatMessage("error", message));
        }
      }
      warn(message) {
        if (this.shouldLog("warn")) {
          console.warn(this.formatMessage("warn", message));
        }
      }
      info(message) {
        if (this.shouldLog("info")) {
          console.info(this.formatMessage("info", message));
        }
      }
      debug(message) {
        if (this.shouldLog("debug")) {
          console.debug(this.formatMessage("debug", message));
        }
      }
      http(message) {
        if (this.shouldLog("http")) {
          console.log(this.formatMessage("http", message));
        }
      }
      verbose(message) {
        if (this.shouldLog("verbose")) {
          console.log(this.formatMessage("verbose", message));
        }
      }
      silly(message) {
        if (this.shouldLog("silly")) {
          console.log(this.formatMessage("silly", message));
        }
      }
      // Make it compatible with Winston interface
      get level() {
        return this._level;
      }
      set level(newLevel) {
        this._level = newLevel;
      }
    };
    __name(resolveLevel, "resolveLevel");
    Logger = class {
      static {
        __name(this, "Logger");
      }
      static instances = {};
      static simpleInstances = {};
      static currentFormat = "minimal";
      static get(name = DEFAULT_LOGGER_NAME) {
        if (!isNodeJSEnvironment()) {
          if (!this.simpleInstances[name]) {
            const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
            this.simpleInstances[name] = new SimpleConsoleLogger(
              name,
              resolveLevel(debugEnv)
            );
          }
          return this.simpleInstances[name];
        }
        if (!this.instances[name]) {
          if (!winston) {
            throw new Error("Winston not loaded - call Logger.configure() first");
          }
          const { createLogger, format } = winston;
          const { combine, timestamp, label, colorize, splat } = format;
          this.instances[name] = createLogger({
            level: resolveLevel(process.env.DEBUG),
            format: combine(
              colorize(),
              splat(),
              label({ label: name }),
              timestamp({ format: "HH:mm:ss" }),
              this.getFormatter()
            ),
            transports: [new winston.transports.Console()]
          });
        }
        return this.instances[name];
      }
      static getFormatter() {
        if (!winston) {
          throw new Error("Winston not loaded");
        }
        const { format } = winston;
        const { printf } = format;
        const minimalFormatter = printf(({ level, message, label, timestamp }) => {
          return `${timestamp} [${label}] ${level}: ${message}`;
        });
        const detailedFormatter = printf(({ level, message, label, timestamp }) => {
          return `${timestamp} [${label}] ${level.toUpperCase()}: ${message}`;
        });
        const emojiFormatter = printf(({ level, message, label, timestamp }) => {
          return `${timestamp} [${label}] ${level.toUpperCase()}: ${message}`;
        });
        switch (this.currentFormat) {
          case "minimal":
            return minimalFormatter;
          case "detailed":
            return detailedFormatter;
          case "emoji":
            return emojiFormatter;
          default:
            return minimalFormatter;
        }
      }
      static async configure(options = {}) {
        const { level, console: console2 = true, file, format = "minimal" } = options;
        const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
        const resolvedLevel = level ?? resolveLevel(debugEnv);
        this.currentFormat = format;
        if (!isNodeJSEnvironment()) {
          Object.values(this.simpleInstances).forEach((logger2) => {
            logger2.level = resolvedLevel;
          });
          return;
        }
        await getWinston();
        if (!winston) {
          throw new Error("Failed to load winston");
        }
        const root = this.get();
        root.level = resolvedLevel;
        const winstonRoot = root;
        winstonRoot.clear();
        if (console2) {
          winstonRoot.add(new winston.transports.Console());
        }
        if (file) {
          const { fs: nodeFs, path: nodePath } = await getNodeModules();
          if (nodeFs && nodePath) {
            const dir = nodePath.dirname(nodePath.resolve(file));
            if (!nodeFs.existsSync(dir)) {
              nodeFs.mkdirSync(dir, { recursive: true });
            }
            winstonRoot.add(new winston.transports.File({ filename: file }));
          }
        }
        const { format: winstonFormat } = winston;
        const { combine, timestamp, label, colorize, splat } = winstonFormat;
        Object.values(this.instances).forEach((logger2) => {
          if (logger2 && "format" in logger2) {
            logger2.level = resolvedLevel;
            logger2.format = combine(
              colorize(),
              splat(),
              label({ label: DEFAULT_LOGGER_NAME }),
              timestamp({ format: "HH:mm:ss" }),
              this.getFormatter()
            );
          }
        });
      }
      static setDebug(enabled) {
        let level;
        if (enabled === 2 || enabled === true) level = "debug";
        else if (enabled === 1) level = "info";
        else level = "info";
        Object.values(this.simpleInstances).forEach((logger2) => {
          logger2.level = level;
        });
        Object.values(this.instances).forEach((logger2) => {
          if (logger2) {
            logger2.level = level;
          }
        });
        if (typeof process !== "undefined" && process.env) {
          process.env.DEBUG = enabled ? enabled === true ? "2" : String(enabled) : "0";
        }
      }
      static setFormat(format) {
        this.currentFormat = format;
        this.configure({ format });
      }
    };
    if (isNodeJSEnvironment()) {
      loadWinstonSync();
      if (winston) {
        Logger.configure();
      }
    }
    logger = Logger.get();
  }
});

// src/version.ts
function getPackageVersion() {
  return VERSION;
}
var VERSION;
var init_version = __esm({
  "src/version.ts"() {
    "use strict";
    VERSION = "1.11.1";
    __name(getPackageVersion, "getPackageVersion");
  }
});

// src/telemetry/utils.ts
var init_utils = __esm({
  "src/telemetry/utils.ts"() {
    "use strict";
    init_version();
  }
});

// src/telemetry/telemetry.ts
function secureRandomString() {
  if (typeof window !== "undefined" && window.crypto && typeof window.crypto.getRandomValues === "function") {
    const array2 = new Uint8Array(8);
    window.crypto.getRandomValues(array2);
    return Array.from(array2, (v) => v.toString(16).padStart(2, "0")).join("");
  }
  try {
    const crypto = require("crypto");
    return crypto.randomBytes(8).toString("hex");
  } catch (e) {
    return Math.random().toString(36).substring(2, 15);
  }
}
function detectRuntimeEnvironment() {
  try {
    if (typeof globalThis.Bun !== "undefined") {
      return "bun";
    }
    if (typeof globalThis.Deno !== "undefined") {
      return "deno";
    }
    if (typeof navigator !== "undefined" && navigator.userAgent?.includes("Cloudflare-Workers")) {
      return "cloudflare-workers";
    }
    if (typeof globalThis.EdgeRuntime !== "undefined") {
      return "edge";
    }
    if (typeof window !== "undefined" && typeof document !== "undefined") {
      return "browser";
    }
    if (typeof process !== "undefined" && typeof process.versions?.node !== "undefined") {
      return "node";
    }
    return "unknown";
  } catch {
    return "unknown";
  }
}
function getStorageCapability(env) {
  switch (env) {
    case "node":
    case "bun":
      return "filesystem";
    case "browser":
      try {
        if (typeof localStorage !== "undefined") {
          localStorage.setItem("__mcp_use_test__", "1");
          localStorage.removeItem("__mcp_use_test__");
          return "localStorage";
        }
      } catch {
      }
      return "session-only";
    case "deno":
      return "session-only";
    default:
      return "session-only";
  }
}
function getRuntimeEnvironment() {
  if (cachedEnvironment === null) {
    cachedEnvironment = detectRuntimeEnvironment();
  }
  return cachedEnvironment;
}
var USER_ID_STORAGE_KEY, cachedEnvironment, ScarfEventLogger, Telemetry;
var init_telemetry = __esm({
  "src/telemetry/telemetry.ts"() {
    "use strict";
    init_runtime();
    init_logging();
    init_events();
    init_utils();
    __name(secureRandomString, "secureRandomString");
    USER_ID_STORAGE_KEY = "mcp_use_user_id";
    __name(detectRuntimeEnvironment, "detectRuntimeEnvironment");
    __name(getStorageCapability, "getStorageCapability");
    cachedEnvironment = null;
    __name(getRuntimeEnvironment, "getRuntimeEnvironment");
    ScarfEventLogger = class {
      static {
        __name(this, "ScarfEventLogger");
      }
      endpoint;
      timeout;
      constructor(endpoint, timeout = 3e3) {
        this.endpoint = endpoint;
        this.timeout = timeout;
      }
      async logEvent(properties) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), this.timeout);
          const response = await fetch(this.endpoint, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(properties),
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
        } catch (error2) {
          logger.debug(`Failed to send Scarf event: ${error2}`);
        }
      }
    };
    Telemetry = class _Telemetry {
      static {
        __name(this, "Telemetry");
      }
      static instance = null;
      PROJECT_API_KEY = "phc_lyTtbYwvkdSbrcMQNPiKiiRWrrM1seyKIMjycSvItEI";
      HOST = "https://eu.i.posthog.com";
      SCARF_GATEWAY_URL = "https://mcpuse.gateway.scarf.sh/events-ts";
      UNKNOWN_USER_ID = "UNKNOWN_USER_ID";
      _currUserId = null;
      _posthogNodeClient = null;
      _posthogBrowserClient = null;
      _posthogLoading = null;
      _scarfClient = null;
      _runtimeEnvironment;
      _storageCapability;
      _source;
      // Node.js specific paths (lazily computed)
      _userIdPath = null;
      _versionDownloadPath = null;
      constructor() {
        this._runtimeEnvironment = getRuntimeEnvironment();
        this._storageCapability = getStorageCapability(this._runtimeEnvironment);
        this._source = typeof process !== "undefined" && process.env?.MCP_USE_TELEMETRY_SOURCE || this._runtimeEnvironment;
        const telemetryDisabled = this._checkTelemetryDisabled();
        const canSupportTelemetry = this._runtimeEnvironment !== "unknown";
        if (telemetryDisabled) {
          this._posthogNodeClient = null;
          this._posthogBrowserClient = null;
          this._scarfClient = null;
          logger.debug("Telemetry disabled via environment/localStorage");
        } else if (!canSupportTelemetry) {
          this._posthogNodeClient = null;
          this._posthogBrowserClient = null;
          this._scarfClient = null;
          logger.debug(
            `Telemetry disabled - unknown environment: ${this._runtimeEnvironment}`
          );
        } else {
          logger.info(
            "Anonymized telemetry enabled. Set MCP_USE_ANONYMIZED_TELEMETRY=false to disable."
          );
          this._posthogLoading = this._initPostHog();
          if (this._runtimeEnvironment !== "browser") {
            try {
              this._scarfClient = new ScarfEventLogger(
                this.SCARF_GATEWAY_URL,
                3e3
              );
            } catch (e) {
              logger.warn(`Failed to initialize Scarf telemetry: ${e}`);
              this._scarfClient = null;
            }
          } else {
            this._scarfClient = null;
          }
          if (this._storageCapability === "filesystem" && this._scarfClient) {
            setTimeout(() => {
              this.trackPackageDownload({ triggered_by: "initialization" }).catch(
                (e) => logger.debug(`Failed to track package download: ${e}`)
              );
            }, 0);
          }
        }
      }
      _checkTelemetryDisabled() {
        if (typeof process !== "undefined" && process.env?.MCP_USE_ANONYMIZED_TELEMETRY?.toLowerCase() === "false") {
          return true;
        }
        if (typeof localStorage !== "undefined" && localStorage.getItem("MCP_USE_ANONYMIZED_TELEMETRY") === "false") {
          return true;
        }
        return false;
      }
      async _initPostHog() {
        const isBrowser = this._runtimeEnvironment === "browser";
        if (isBrowser) {
          await this._initPostHogBrowser();
        } else {
          await this._initPostHogNode();
        }
      }
      async _initPostHogBrowser() {
        try {
          const posthogModule = await import("posthog-js");
          const posthog = posthogModule.default || posthogModule.posthog;
          if (!posthog || typeof posthog.init !== "function") {
            throw new Error("posthog-js module did not export expected interface");
          }
          posthog.init(this.PROJECT_API_KEY, {
            api_host: this.HOST,
            persistence: "localStorage",
            autocapture: false,
            // We only want explicit captures
            capture_pageview: false,
            // We don't want automatic pageview tracking
            disable_session_recording: true,
            // No session recording
            loaded: /* @__PURE__ */ __name(() => {
              logger.debug("PostHog browser client initialized");
            }, "loaded")
          });
          this._posthogBrowserClient = posthog;
        } catch (e) {
          logger.warn(`Failed to initialize PostHog browser telemetry: ${e}`);
          this._posthogBrowserClient = null;
        }
      }
      async _initPostHogNode() {
        try {
          const { PostHog } = await import("posthog-node");
          const isServerlessEnvironment = [
            "cloudflare-workers",
            "edge",
            "deno"
          ].includes(this._runtimeEnvironment);
          const posthogOptions = {
            host: this.HOST,
            disableGeoip: false
          };
          if (isServerlessEnvironment) {
            posthogOptions.flushAt = 1;
            posthogOptions.flushInterval = 0;
          }
          this._posthogNodeClient = new PostHog(
            this.PROJECT_API_KEY,
            posthogOptions
          );
          logger.debug("PostHog Node.js client initialized");
        } catch (e) {
          logger.warn(`Failed to initialize PostHog Node.js telemetry: ${e}`);
          this._posthogNodeClient = null;
        }
      }
      /**
       * Get the detected runtime environment
       */
      get runtimeEnvironment() {
        return this._runtimeEnvironment;
      }
      /**
       * Get the storage capability for this environment
       */
      get storageCapability() {
        return this._storageCapability;
      }
      static getInstance() {
        if (!_Telemetry.instance) {
          _Telemetry.instance = new _Telemetry();
        }
        return _Telemetry.instance;
      }
      /**
       * Set the source identifier for telemetry events.
       * This allows tracking usage from different applications.
       * @param source - The source identifier (e.g., "my-app", "cli", "vs-code-extension")
       */
      setSource(source) {
        this._source = source;
        logger.debug(`Telemetry source set to: ${source}`);
      }
      /**
       * Get the current source identifier.
       */
      getSource() {
        return this._source;
      }
      /**
       * Check if telemetry is enabled.
       */
      get isEnabled() {
        return this._posthogNodeClient !== null || this._posthogBrowserClient !== null || this._scarfClient !== null;
      }
      get userId() {
        if (this._currUserId) {
          return this._currUserId;
        }
        try {
          switch (this._storageCapability) {
            case "filesystem":
              this._currUserId = this._getUserIdFromFilesystem();
              break;
            case "localStorage":
              this._currUserId = this._getUserIdFromLocalStorage();
              break;
            case "session-only":
            default:
              try {
                this._currUserId = `session-${generateUUID()}`;
              } catch (uuidError) {
                this._currUserId = `session-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
              }
              break;
          }
        } catch (e) {
          this._currUserId = this.UNKNOWN_USER_ID;
        }
        return this._currUserId;
      }
      /**
       * Get or create user ID from filesystem (Node.js/Bun)
       * Falls back to session ID if filesystem operations fail
       */
      _getUserIdFromFilesystem() {
        try {
          let fs, os, path;
          try {
            fs = require("fs");
            os = require("os");
            path = require("path");
          } catch (requireError) {
            try {
              const sessionId = `session-${generateUUID()}`;
              return sessionId;
            } catch (uuidError) {
              return `session-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
            }
          }
          if (!this._userIdPath) {
            this._userIdPath = path.join(
              this._getCacheHome(os, path),
              "mcp_use_3",
              "telemetry_user_id"
            );
          }
          const isFirstTime = !fs.existsSync(this._userIdPath);
          if (isFirstTime) {
            fs.mkdirSync(path.dirname(this._userIdPath), { recursive: true });
            let newUserId;
            try {
              newUserId = generateUUID();
            } catch (uuidError) {
              newUserId = `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
            }
            fs.writeFileSync(this._userIdPath, newUserId);
            return newUserId;
          }
          const userId = fs.readFileSync(this._userIdPath, "utf-8").trim();
          return userId;
        } catch (e) {
          try {
            return `session-${generateUUID()}`;
          } catch (uuidError) {
            return `session-${Date.now()}-${secureRandomString()}`;
          }
        }
      }
      /**
       * Get or create user ID from localStorage (Browser)
       */
      _getUserIdFromLocalStorage() {
        try {
          let userId = localStorage.getItem(USER_ID_STORAGE_KEY);
          if (!userId) {
            try {
              userId = generateUUID();
            } catch (uuidError) {
              userId = `${Date.now()}-${secureRandomString()}`;
            }
            localStorage.setItem(USER_ID_STORAGE_KEY, userId);
          }
          return userId;
        } catch (e) {
          let sessionId;
          try {
            sessionId = `session-${generateUUID()}`;
          } catch (uuidError) {
            sessionId = `session-${Date.now()}-${secureRandomString()}`;
          }
          return sessionId;
        }
      }
      _getCacheHome(os, path) {
        const envVar = process.env.XDG_CACHE_HOME;
        if (envVar && path.isAbsolute(envVar)) {
          return envVar;
        }
        const platform = process.platform;
        const homeDir = os.homedir();
        if (platform === "win32") {
          const appdata = process.env.LOCALAPPDATA || process.env.APPDATA;
          if (appdata) {
            return appdata;
          }
          return path.join(homeDir, "AppData", "Local");
        } else if (platform === "darwin") {
          return path.join(homeDir, "Library", "Caches");
        } else {
          return path.join(homeDir, ".cache");
        }
      }
      async capture(event) {
        if (this._posthogLoading) {
          await this._posthogLoading;
        }
        if (!this._posthogNodeClient && !this._posthogBrowserClient && !this._scarfClient) {
          return;
        }
        const currentUserId = this.userId;
        const properties = { ...event.properties };
        properties.mcp_use_version = getPackageVersion();
        properties.language = "typescript";
        properties.source = this._source;
        properties.runtime = this._runtimeEnvironment;
        if (this._posthogNodeClient) {
          try {
            this._posthogNodeClient.capture({
              distinctId: currentUserId,
              event: event.name,
              properties
            });
          } catch (e) {
            logger.debug(`Failed to track PostHog Node event ${event.name}: ${e}`);
          }
        }
        if (this._posthogBrowserClient) {
          try {
            this._posthogBrowserClient.capture(event.name, {
              ...properties,
              distinct_id: currentUserId
            });
          } catch (e) {
            logger.debug(
              `Failed to track PostHog Browser event ${event.name}: ${e}`
            );
          }
        }
        if (this._scarfClient) {
          try {
            const scarfProperties = {
              ...properties,
              user_id: currentUserId,
              event: event.name
            };
            await this._scarfClient.logEvent(scarfProperties);
          } catch (e) {
            logger.debug(`Failed to track Scarf event ${event.name}: ${e}`);
          }
        }
      }
      // ============================================================================
      // Package Download Tracking (Node.js only)
      // ============================================================================
      /**
       * Track package download event.
       * This is a public wrapper that safely accesses userId.
       */
      async trackPackageDownload(properties) {
        return this._trackPackageDownloadInternal(this.userId, properties);
      }
      /**
       * Internal method to track package download with explicit userId.
       */
      async _trackPackageDownloadInternal(userId, properties) {
        if (!this._scarfClient) {
          return;
        }
        if (this._storageCapability !== "filesystem") {
          return;
        }
        try {
          const fs = require("fs");
          const path = require("path");
          const os = require("os");
          if (!this._versionDownloadPath) {
            this._versionDownloadPath = path.join(
              this._getCacheHome(os, path),
              "mcp_use",
              "download_version"
            );
          }
          const currentVersion = getPackageVersion();
          let shouldTrack = false;
          let firstDownload = false;
          if (!fs.existsSync(this._versionDownloadPath)) {
            shouldTrack = true;
            firstDownload = true;
            fs.mkdirSync(path.dirname(this._versionDownloadPath), {
              recursive: true
            });
            fs.writeFileSync(this._versionDownloadPath, currentVersion);
          } else {
            const savedVersion = fs.readFileSync(this._versionDownloadPath, "utf-8").trim();
            if (currentVersion > savedVersion) {
              shouldTrack = true;
              firstDownload = false;
              fs.writeFileSync(this._versionDownloadPath, currentVersion);
            }
          }
          if (shouldTrack) {
            logger.debug(
              `Tracking package download event with properties: ${JSON.stringify(properties)}`
            );
            const eventProperties = { ...properties || {} };
            eventProperties.mcp_use_version = currentVersion;
            eventProperties.user_id = userId;
            eventProperties.event = "package_download";
            eventProperties.first_download = firstDownload;
            eventProperties.language = "typescript";
            eventProperties.source = this._source;
            eventProperties.runtime = this._runtimeEnvironment;
            await this._scarfClient.logEvent(eventProperties);
          }
        } catch (e) {
          logger.debug(`Failed to track Scarf package_download event: ${e}`);
        }
      }
      // ============================================================================
      // Agent Events
      // ============================================================================
      async trackAgentExecution(data) {
        if (!this.isEnabled) return;
        const event = new MCPAgentExecutionEvent(data);
        await this.capture(event);
      }
      // ============================================================================
      // Server Events
      // ============================================================================
      /**
       * Track server run event directly from an MCPServer instance.
       */
      async trackServerRunFromServer(server, transport) {
        if (!this.isEnabled) return;
        const data = createServerRunEventData(server, transport);
        const event = new ServerRunEvent(data);
        await this.capture(event);
      }
      async trackServerInitialize(data) {
        if (!this.isEnabled) return;
        const event = new ServerInitializeEvent(data);
        await this.capture(event);
      }
      async trackServerToolCall(data) {
        if (!this.isEnabled) return;
        const event = new ServerToolCallEvent(data);
        await this.capture(event);
      }
      async trackServerResourceCall(data) {
        if (!this.isEnabled) return;
        const event = new ServerResourceCallEvent(data);
        await this.capture(event);
      }
      async trackServerPromptCall(data) {
        if (!this.isEnabled) return;
        const event = new ServerPromptCallEvent(data);
        await this.capture(event);
      }
      async trackServerContext(data) {
        if (!this.isEnabled) return;
        const event = new ServerContextEvent(data);
        await this.capture(event);
      }
      // ============================================================================
      // Client Events
      // ============================================================================
      async trackMCPClientInit(data) {
        if (!this.isEnabled) return;
        const event = new MCPClientInitEvent(data);
        await this.capture(event);
      }
      async trackConnectorInit(data) {
        if (!this.isEnabled) return;
        const event = new ConnectorInitEvent(data);
        await this.capture(event);
      }
      async trackClientAddServer(serverName, serverConfig) {
        if (!this.isEnabled) return;
        const event = new ClientAddServerEvent({ serverName, serverConfig });
        await this.capture(event);
      }
      async trackClientRemoveServer(serverName) {
        if (!this.isEnabled) return;
        const event = new ClientRemoveServerEvent({ serverName });
        await this.capture(event);
      }
      // ============================================================================
      // React Hook / Browser specific events
      // ============================================================================
      async trackUseMcpConnection(data) {
        if (!this.isEnabled) return;
        await this.capture({
          name: "usemcp_connection",
          properties: {
            url_domain: new URL(data.url).hostname,
            // Only domain for privacy
            transport_type: data.transportType,
            success: data.success,
            error_type: data.errorType ?? null,
            connection_time_ms: data.connectionTimeMs ?? null,
            has_oauth: data.hasOAuth,
            has_sampling: data.hasSampling,
            has_elicitation: data.hasElicitation
          }
        });
      }
      async trackUseMcpToolCall(data) {
        if (!this.isEnabled) return;
        await this.capture({
          name: "usemcp_tool_call",
          properties: {
            tool_name: data.toolName,
            success: data.success,
            error_type: data.errorType ?? null,
            execution_time_ms: data.executionTimeMs ?? null
          }
        });
      }
      async trackUseMcpResourceRead(data) {
        if (!this.isEnabled) return;
        await this.capture({
          name: "usemcp_resource_read",
          properties: {
            resource_uri_scheme: data.resourceUri.split(":")[0],
            // Only scheme for privacy
            success: data.success,
            error_type: data.errorType ?? null
          }
        });
      }
      // ============================================================================
      // Browser-specific Methods
      // ============================================================================
      /**
       * Identify the current user (useful for linking sessions)
       * Browser only - no-op in Node.js
       */
      identify(userId, properties) {
        if (this._posthogBrowserClient) {
          try {
            this._posthogBrowserClient.identify(userId, properties);
          } catch (e) {
            logger.debug(`Failed to identify user: ${e}`);
          }
        }
      }
      /**
       * Reset the user identity (useful for logout)
       * Browser only - no-op in Node.js
       */
      reset() {
        if (this._posthogBrowserClient) {
          try {
            this._posthogBrowserClient.reset();
          } catch (e) {
            logger.debug(`Failed to reset user: ${e}`);
          }
        }
        this._currUserId = null;
      }
      // ============================================================================
      // Node.js-specific Methods
      // ============================================================================
      /**
       * Flush the telemetry queue (Node.js only)
       */
      flush() {
        if (this._posthogNodeClient) {
          try {
            this._posthogNodeClient.flush();
            logger.debug("PostHog client telemetry queue flushed");
          } catch (e) {
            logger.debug(`Failed to flush PostHog client: ${e}`);
          }
        }
      }
      /**
       * Shutdown the telemetry client (Node.js only)
       */
      shutdown() {
        if (this._posthogNodeClient) {
          try {
            this._posthogNodeClient.shutdown();
            logger.debug("PostHog client shutdown successfully");
          } catch (e) {
            logger.debug(`Error shutting down PostHog client: ${e}`);
          }
        }
      }
    };
  }
});

// src/telemetry/index.ts
var init_telemetry2 = __esm({
  "src/telemetry/index.ts"() {
    "use strict";
    init_events();
    init_telemetry();
    init_utils();
  }
});

// src/server/context-storage.ts
var context_storage_exports = {};
__export(context_storage_exports, {
  getRequestContext: () => getRequestContext,
  getSessionId: () => getSessionId,
  hasRequestContext: () => hasRequestContext,
  runWithContext: () => runWithContext
});
async function runWithContext(context, fn, sessionId) {
  return requestContextStorage.run({ honoContext: context, sessionId }, fn);
}
function getRequestContext() {
  return requestContextStorage.getStore()?.honoContext;
}
function getSessionId() {
  return requestContextStorage.getStore()?.sessionId;
}
function hasRequestContext() {
  return requestContextStorage.getStore() !== void 0;
}
var import_node_async_hooks, requestContextStorage;
var init_context_storage = __esm({
  "src/server/context-storage.ts"() {
    "use strict";
    import_node_async_hooks = require("async_hooks");
    requestContextStorage = new import_node_async_hooks.AsyncLocalStorage();
    __name(runWithContext, "runWithContext");
    __name(getRequestContext, "getRequestContext");
    __name(getSessionId, "getSessionId");
    __name(hasRequestContext, "hasRequestContext");
  }
});

// src/errors.ts
var ElicitationValidationError;
var init_errors = __esm({
  "src/errors.ts"() {
    "use strict";
    ElicitationValidationError = class _ElicitationValidationError extends Error {
      constructor(message, cause) {
        super(message);
        this.cause = cause;
        this.name = "ElicitationValidationError";
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _ElicitationValidationError);
        }
      }
      static {
        __name(this, "ElicitationValidationError");
      }
    };
  }
});

// src/server/tools/tool-execution-helpers.ts
var tool_execution_helpers_exports = {};
__export(tool_execution_helpers_exports, {
  VALID_LOG_LEVELS: () => VALID_LOG_LEVELS,
  createElicitMethod: () => createElicitMethod,
  createEnhancedContext: () => createEnhancedContext,
  createReportProgressMethod: () => createReportProgressMethod,
  createSampleMethod: () => createSampleMethod,
  findSessionContext: () => findSessionContext,
  isValidLogLevel: () => isValidLogLevel,
  parseElicitParams: () => parseElicitParams,
  sendProgressNotification: () => sendProgressNotification,
  shouldLogMessage: () => shouldLogMessage,
  withTimeout: () => withTimeout
});
function findSessionContext(sessions, initialRequestContext, extraProgressToken, extraSendNotification) {
  let requestContext = initialRequestContext;
  let session;
  let progressToken = extraProgressToken;
  let sendNotification2 = extraSendNotification;
  if (!requestContext) {
    for (const [, s] of sessions.entries()) {
      if (s.context) {
        requestContext = s.context;
        break;
      }
    }
  }
  if (!progressToken || !sendNotification2) {
    if (requestContext) {
      for (const [, s] of sessions.entries()) {
        if (s.context === requestContext) {
          session = s;
          break;
        }
      }
    } else {
      const firstSession = sessions.values().next().value;
      if (firstSession) {
        session = firstSession;
      }
    }
    if (session) {
      if (!progressToken && session.progressToken) {
        progressToken = session.progressToken;
      }
      if (!sendNotification2 && session.sendNotification) {
        sendNotification2 = session.sendNotification;
      }
    }
  }
  return { requestContext, session, progressToken, sendNotification: sendNotification2 };
}
async function sendProgressNotification(sendNotification2, progressToken, progress, total, message) {
  if (sendNotification2 && progressToken !== void 0) {
    try {
      await sendNotification2({
        method: "notifications/progress",
        params: {
          progressToken,
          progress,
          total,
          message
        }
      });
    } catch {
    }
  }
}
async function withTimeout(promise, timeout, errorMessage) {
  if (timeout && timeout !== Infinity) {
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error(errorMessage)), timeout);
    });
    return await Promise.race([promise, timeoutPromise]);
  }
  return await promise;
}
function parseElicitParams(messageOrParams, schemaOrUrlOrOptions, maybeOptions) {
  let sdkParams;
  let zodSchema = null;
  let options;
  if (typeof messageOrParams === "string") {
    const message = messageOrParams;
    if (typeof schemaOrUrlOrOptions === "string") {
      options = maybeOptions;
      const elicitationId = `elicit-${generateUUID()}`;
      sdkParams = {
        mode: "url",
        message,
        url: schemaOrUrlOrOptions,
        elicitationId
      };
    } else if (schemaOrUrlOrOptions && typeof schemaOrUrlOrOptions === "object" && "_def" in schemaOrUrlOrOptions) {
      options = maybeOptions;
      zodSchema = schemaOrUrlOrOptions;
      const jsonSchema = (0, import_zod_json_schema_compat.toJsonSchemaCompat)(schemaOrUrlOrOptions);
      sdkParams = {
        mode: "form",
        message,
        requestedSchema: jsonSchema
      };
    } else {
      throw new Error(
        "Invalid elicit signature: second parameter must be a Zod schema or URL string"
      );
    }
  } else {
    options = schemaOrUrlOrOptions;
    const params = messageOrParams;
    if (params.mode === "url") {
      const elicitationId = `elicit-${generateUUID()}`;
      sdkParams = {
        mode: "url",
        message: params.message,
        url: params.url,
        elicitationId
      };
    } else {
      sdkParams = {
        mode: "form",
        message: params.message,
        requestedSchema: params.requestedSchema
      };
    }
  }
  return { sdkParams, zodSchema, options };
}
function createSampleMethod(createMessage, progressToken, sendNotification2) {
  return async (promptOrParams, options) => {
    let sampleParams;
    if (typeof promptOrParams === "string") {
      sampleParams = {
        messages: [
          {
            role: "user",
            content: {
              type: "text",
              text: promptOrParams
            }
          }
        ],
        maxTokens: options?.maxTokens || 1e3,
        ...options?.modelPreferences && {
          modelPreferences: options.modelPreferences
        },
        ...options?.systemPrompt && { systemPrompt: options.systemPrompt },
        ...options?.temperature !== void 0 && {
          temperature: options.temperature
        },
        ...options?.stopSequences && { stopSequences: options.stopSequences },
        ...options?.metadata && { metadata: options.metadata }
      };
    } else {
      sampleParams = promptOrParams;
    }
    const { timeout, progressIntervalMs = 5e3, onProgress } = options ?? {};
    let progressCount = 0;
    let completed = false;
    let progressInterval = null;
    if (progressToken !== void 0 && sendNotification2) {
      progressInterval = setInterval(async () => {
        if (completed) return;
        progressCount++;
        const progressData = {
          progress: progressCount,
          total: void 0,
          message: `Waiting for LLM response... (${progressCount * Math.round(progressIntervalMs / 1e3)}s elapsed)`
        };
        if (onProgress) {
          try {
            onProgress(progressData);
          } catch {
          }
        }
        await sendProgressNotification(
          sendNotification2,
          progressToken,
          progressData.progress,
          progressData.total,
          progressData.message
        );
      }, progressIntervalMs);
    }
    try {
      console.log("[SAMPLING DEBUG] Calling createMessage...");
      const sdkTimeout = timeout && timeout !== Infinity ? timeout : 2147483647;
      const samplePromise = createMessage(sampleParams, {
        timeout: sdkTimeout
      });
      console.log("[SAMPLING DEBUG] Waiting for response...");
      const result = await withTimeout(
        samplePromise,
        timeout,
        `Sampling timed out after ${timeout}ms`
      );
      console.log("[SAMPLING DEBUG] Got result:", result);
      Telemetry.getInstance().trackServerContext({
        contextType: "sample"
      }).catch((e) => console.debug(`Failed to track sample context: ${e}`));
      return result;
    } catch (error2) {
      console.error("[SAMPLING DEBUG] Error during sampling:", error2);
      throw error2;
    } finally {
      completed = true;
      if (progressInterval) {
        clearInterval(progressInterval);
      }
    }
  };
}
function createElicitMethod(elicitInput) {
  return async (messageOrParams, schemaOrUrlOrOptions, maybeOptions) => {
    const { sdkParams, zodSchema, options } = parseElicitParams(
      messageOrParams,
      schemaOrUrlOrOptions,
      maybeOptions
    );
    const { timeout } = options ?? {};
    const sdkTimeout = timeout && timeout !== Infinity ? timeout : 2147483647;
    const result = await elicitInput(sdkParams, { timeout: sdkTimeout });
    Telemetry.getInstance().trackServerContext({
      contextType: "elicit"
    }).catch((e) => console.debug(`Failed to track elicit context: ${e}`));
    if (zodSchema && result.action === "accept" && result.data) {
      try {
        const validatedData = zodSchema.parse(result.data);
        return {
          ...result,
          data: validatedData
        };
      } catch (error2) {
        const err = error2;
        throw new ElicitationValidationError(
          `Elicitation data validation failed: ${err.message}`,
          err
        );
      }
    }
    return result;
  };
}
function createReportProgressMethod(progressToken, sendNotification2) {
  if (progressToken !== void 0 && sendNotification2) {
    return async (progress, total, message) => {
      await sendProgressNotification(
        sendNotification2,
        progressToken,
        progress,
        total,
        message
      );
    };
  }
  return void 0;
}
function isValidLogLevel(level) {
  return VALID_LOG_LEVELS.includes(level);
}
function shouldLogMessage(messageLevel, minLevel) {
  if (!minLevel) {
    return true;
  }
  if (!isValidLogLevel(messageLevel) || !isValidLogLevel(minLevel)) {
    return true;
  }
  return LOG_LEVELS[messageLevel] >= LOG_LEVELS[minLevel];
}
function createLogMethod(sendNotification2, minLogLevel) {
  if (!sendNotification2) {
    return void 0;
  }
  return async (level, message, logger2) => {
    if (!shouldLogMessage(level, minLogLevel)) {
      return;
    }
    await sendNotification2({
      method: "notifications/message",
      params: {
        level,
        data: message,
        logger: logger2 || "tool"
      }
    });
    Telemetry.getInstance().trackServerContext({
      contextType: "notification",
      notificationType: "message"
    }).catch(
      (e) => console.debug(`Failed to track notification context: ${e}`)
    );
  };
}
function createClientCapabilityChecker(clientCapabilities) {
  const caps = clientCapabilities || {};
  return {
    can(capability) {
      return capability in caps;
    },
    capabilities() {
      return { ...caps };
    }
  };
}
function createSendNotificationMethod(sessionId, sessions) {
  if (!sessionId || !sessions) {
    return void 0;
  }
  return async (method, params) => {
    const session = sessions.get(sessionId);
    if (!session?.sendNotification) {
      console.warn(
        `[MCP] Cannot send notification to session ${sessionId} - no sendNotification function`
      );
      return;
    }
    try {
      await session.sendNotification({
        method,
        params: params || {}
      });
    } catch (error2) {
      console.error(
        `[MCP] Error sending notification to session ${sessionId}:`,
        error2
      );
    }
  };
}
function createSendNotificationToSessionMethod(sessions) {
  if (!sessions) {
    return void 0;
  }
  return async (sessionId, method, params) => {
    const session = sessions.get(sessionId);
    if (!session?.sendNotification) {
      return false;
    }
    try {
      await session.sendNotification({
        method,
        params: params || {}
      });
      return true;
    } catch (error2) {
      console.error(
        `[MCP] Error sending notification to session ${sessionId}:`,
        error2
      );
      return false;
    }
  };
}
function createEnhancedContext(baseContext, createMessage, elicitInput, progressToken, sendNotification2, minLogLevel, clientCapabilities, sessionId, sessions) {
  const enhancedContext = baseContext ? Object.create(baseContext) : {};
  enhancedContext.sample = createSampleMethod(
    createMessage,
    progressToken,
    sendNotification2
  );
  enhancedContext.elicit = createElicitMethod(elicitInput);
  enhancedContext.reportProgress = createReportProgressMethod(
    progressToken,
    sendNotification2
  );
  enhancedContext.log = createLogMethod(sendNotification2, minLogLevel);
  enhancedContext.client = createClientCapabilityChecker(clientCapabilities);
  if (sessionId) {
    enhancedContext.session = {
      sessionId
    };
  }
  const sendNotificationMethod = createSendNotificationMethod(
    sessionId,
    sessions
  );
  if (sendNotificationMethod) {
    enhancedContext.sendNotification = sendNotificationMethod;
  }
  const sendNotificationToSessionMethod = createSendNotificationToSessionMethod(sessions);
  if (sendNotificationToSessionMethod) {
    enhancedContext.sendNotificationToSession = sendNotificationToSessionMethod;
  }
  return enhancedContext;
}
var import_zod_json_schema_compat, LOG_LEVELS, VALID_LOG_LEVELS;
var init_tool_execution_helpers = __esm({
  "src/server/tools/tool-execution-helpers.ts"() {
    "use strict";
    import_zod_json_schema_compat = require("@mcp-use/modelcontextprotocol-sdk/server/zod-json-schema-compat.js");
    init_errors();
    init_runtime();
    init_telemetry2();
    __name(findSessionContext, "findSessionContext");
    __name(sendProgressNotification, "sendProgressNotification");
    __name(withTimeout, "withTimeout");
    __name(parseElicitParams, "parseElicitParams");
    __name(createSampleMethod, "createSampleMethod");
    __name(createElicitMethod, "createElicitMethod");
    __name(createReportProgressMethod, "createReportProgressMethod");
    LOG_LEVELS = {
      debug: 0,
      info: 1,
      notice: 2,
      warning: 3,
      error: 4,
      critical: 5,
      alert: 6,
      emergency: 7
    };
    VALID_LOG_LEVELS = [
      "debug",
      "info",
      "notice",
      "warning",
      "error",
      "critical",
      "alert",
      "emergency"
    ];
    __name(isValidLogLevel, "isValidLogLevel");
    __name(shouldLogMessage, "shouldLogMessage");
    __name(createLogMethod, "createLogMethod");
    __name(createClientCapabilityChecker, "createClientCapabilityChecker");
    __name(createSendNotificationMethod, "createSendNotificationMethod");
    __name(createSendNotificationToSessionMethod, "createSendNotificationToSessionMethod");
    __name(createEnhancedContext, "createEnhancedContext");
  }
});

// src/server/resources/conversion.ts
var conversion_exports = {};
__export(conversion_exports, {
  convertToolResultToResourceResult: () => convertToolResultToResourceResult
});
function isReadResourceResult(result) {
  return "contents" in result && Array.isArray(result.contents);
}
function extractMimeType(result) {
  if (result._meta && typeof result._meta === "object") {
    const meta = result._meta;
    if (meta.mimeType && typeof meta.mimeType === "string") {
      return meta.mimeType;
    }
  }
  if (result.content && result.content.length > 0) {
    const firstContent = result.content[0];
    if (firstContent.type === "image") {
      return firstContent.mimeType || "image/png";
    }
    if (firstContent.type === "text") {
      return "text/plain";
    }
    if (firstContent.type === "resource") {
      const resourceData = firstContent.resource;
      return resourceData?.mimeType || "application/octet-stream";
    }
  }
  return "text/plain";
}
function isBinaryContent(result) {
  if (result._meta && typeof result._meta === "object") {
    const meta = result._meta;
    return meta.isBinary === true || meta.isImage === true;
  }
  return false;
}
function convertToolResultToResourceResult(uri, result) {
  if (isReadResourceResult(result)) {
    return result;
  }
  const mimeType = extractMimeType(result);
  const isBinary = isBinaryContent(result);
  const contents = [];
  if (result.content && result.content.length > 0) {
    for (const content of result.content) {
      if (content.type === "text") {
        const textContent = content;
        if (isBinary) {
          contents.push({
            uri,
            mimeType,
            blob: textContent.text
          });
        } else {
          contents.push({
            uri,
            mimeType,
            text: textContent.text
          });
        }
      } else if (content.type === "image") {
        const imageContent = content;
        contents.push({
          uri,
          mimeType: imageContent.mimeType || mimeType,
          blob: imageContent.data
        });
      } else if (content.type === "resource") {
        const resourceContent = content;
        const resourceData = resourceContent.resource;
        if (resourceData.text !== void 0) {
          contents.push({
            uri: resourceData.uri,
            mimeType: resourceData.mimeType || mimeType,
            text: resourceData.text
          });
        } else if (resourceData.blob !== void 0) {
          contents.push({
            uri: resourceData.uri,
            mimeType: resourceData.mimeType || mimeType,
            blob: resourceData.blob
          });
        } else {
          contents.push({
            uri: resourceData.uri,
            mimeType: resourceData.mimeType || mimeType,
            text: ""
          });
        }
      }
    }
  }
  if (contents.length === 0) {
    contents.push({
      uri,
      mimeType: "text/plain",
      text: ""
    });
  }
  return { contents };
}
var init_conversion = __esm({
  "src/server/resources/conversion.ts"() {
    "use strict";
    __name(isReadResourceResult, "isReadResourceResult");
    __name(extractMimeType, "extractMimeType");
    __name(isBinaryContent, "isBinaryContent");
    __name(convertToolResultToResourceResult, "convertToolResultToResourceResult");
  }
});

// src/server/prompts/conversion.ts
var conversion_exports2 = {};
__export(conversion_exports2, {
  convertToolResultToPromptResult: () => convertToolResultToPromptResult
});
function isGetPromptResult(result) {
  return "messages" in result && Array.isArray(result.messages);
}
function convertToolResultToPromptResult(result) {
  if (isGetPromptResult(result)) {
    return result;
  }
  const messages = [];
  if (result.content && result.content.length > 0) {
    for (const content of result.content) {
      if (content.type === "text") {
        const textContent = content;
        messages.push({
          role: "user",
          content: {
            type: "text",
            text: textContent.text
          }
        });
      } else if (content.type === "image") {
        const imageContent = content;
        messages.push({
          role: "user",
          content: {
            type: "image",
            data: imageContent.data,
            mimeType: imageContent.mimeType || "image/png"
          }
        });
      } else if (content.type === "resource") {
        const resourceContent = content;
        const resourceData = resourceContent.resource;
        const embeddedResource = {
          type: "resource",
          resource: {
            uri: resourceData.uri,
            mimeType: resourceData.mimeType
          }
        };
        if (resourceData.text) {
          embeddedResource.resource.text = resourceData.text;
        } else if (resourceData.blob) {
          embeddedResource.resource.blob = resourceData.blob;
        }
        messages.push({
          role: "user",
          content: embeddedResource
        });
      }
    }
  }
  if (messages.length === 0) {
    messages.push({
      role: "user",
      content: {
        type: "text",
        text: ""
      }
    });
  }
  return {
    messages,
    description: result._meta?.description
  };
}
var init_conversion2 = __esm({
  "src/server/prompts/conversion.ts"() {
    "use strict";
    __name(isGetPromptResult, "isGetPromptResult");
    __name(convertToolResultToPromptResult, "convertToolResultToPromptResult");
  }
});

// src/server/utils/jsonrpc-helpers.ts
function createNotification(method, params) {
  return {
    jsonrpc: "2.0",
    method,
    ...params && { params }
  };
}
function createRequest(id, method, params) {
  return {
    jsonrpc: "2.0",
    id,
    method,
    ...params && { params }
  };
}
var init_jsonrpc_helpers = __esm({
  "src/server/utils/jsonrpc-helpers.ts"() {
    "use strict";
    __name(createNotification, "createNotification");
    __name(createRequest, "createRequest");
  }
});

// src/server/sessions/notifications.ts
var notifications_exports = {};
__export(notifications_exports, {
  sendNotificationToAll: () => sendNotificationToAll,
  sendNotificationToSession: () => sendNotificationToSession
});
async function sendNotificationToAll(sessions, method, params) {
  const notification = createNotification(method, params);
  for (const [sessionId, session] of sessions.entries()) {
    try {
      await session.transport.send(notification);
    } catch (error2) {
      console.warn(
        `[MCP] Failed to send notification to session ${sessionId}:`,
        error2
      );
    }
  }
}
async function sendNotificationToSession(sessions, sessionId, method, params) {
  const session = sessions.get(sessionId);
  if (!session) {
    return false;
  }
  const notification = createNotification(method, params);
  try {
    await session.transport.send(notification);
    return true;
  } catch (error2) {
    console.warn(
      `[MCP] Failed to send notification to session ${sessionId}:`,
      error2
    );
    return false;
  }
}
var init_notifications = __esm({
  "src/server/sessions/notifications.ts"() {
    "use strict";
    init_jsonrpc_helpers();
    __name(sendNotificationToAll, "sendNotificationToAll");
    __name(sendNotificationToSession, "sendNotificationToSession");
  }
});

// src/server/index.ts
var server_exports = {};
__export(server_exports, {
  FileSystemSessionStore: () => FileSystemSessionStore,
  InMemorySessionStore: () => InMemorySessionStore,
  InMemoryStreamManager: () => InMemoryStreamManager,
  MCPServer: () => MCPServer,
  RedisSessionStore: () => RedisSessionStore,
  RedisStreamManager: () => RedisStreamManager,
  VERSION: () => VERSION,
  adaptConnectMiddleware: () => adaptConnectMiddleware,
  adaptMiddleware: () => adaptMiddleware,
  array: () => array,
  audio: () => audio,
  binary: () => binary,
  buildWidgetUrl: () => buildWidgetUrl,
  createExternalUrlResource: () => createExternalUrlResource,
  createMCPServer: () => createMCPServer,
  createRawHtmlResource: () => createRawHtmlResource,
  createRemoteDomResource: () => createRemoteDomResource,
  createUIResourceFromDefinition: () => createUIResourceFromDefinition,
  css: () => css,
  error: () => error,
  getAuth: () => getAuth,
  getPackageVersion: () => getPackageVersion,
  getRequestContext: () => getRequestContext,
  hasAnyScope: () => hasAnyScope,
  hasRequestContext: () => hasRequestContext,
  hasScope: () => hasScope,
  html: () => html,
  image: () => image,
  isExpressMiddleware: () => isExpressMiddleware,
  javascript: () => javascript,
  markdown: () => markdown,
  mix: () => mix,
  oauthAuth0Provider: () => oauthAuth0Provider,
  oauthCustomProvider: () => oauthCustomProvider,
  oauthKeycloakProvider: () => oauthKeycloakProvider,
  oauthSupabaseProvider: () => oauthSupabaseProvider,
  oauthWorkOSProvider: () => oauthWorkOSProvider,
  object: () => object,
  requireAnyScope: () => requireAnyScope,
  requireScope: () => requireScope,
  resource: () => resource,
  runWithContext: () => runWithContext,
  text: () => text,
  widget: () => widget,
  xml: () => xml
});
module.exports = __toCommonJS(server_exports);

// src/server/mcp-server.ts
var import_mcp2 = require("@mcp-use/modelcontextprotocol-sdk/server/mcp.js");
var import_types2 = require("@mcp-use/modelcontextprotocol-sdk/types.js");
var import_zod3 = require("zod");
init_telemetry2();
init_version();

// src/server/widgets/index.ts
init_runtime();

// src/server/utils/response-helpers.ts
init_runtime();
function text(content) {
  return {
    content: [
      {
        type: "text",
        text: content
      }
    ],
    _meta: {
      mimeType: "text/plain"
    }
  };
}
__name(text, "text");
function image(data, mimeType = "image/png") {
  return {
    content: [
      {
        type: "image",
        data,
        mimeType
      }
    ],
    _meta: {
      mimeType,
      isImage: true
    }
  };
}
__name(image, "image");
function getAudioMimeType(filename) {
  const ext = filename.split(".").pop()?.toLowerCase();
  switch (ext) {
    case "wav":
      return "audio/wav";
    case "mp3":
      return "audio/mpeg";
    case "ogg":
      return "audio/ogg";
    case "m4a":
      return "audio/mp4";
    case "webm":
      return "audio/webm";
    case "flac":
      return "audio/flac";
    case "aac":
      return "audio/aac";
    default:
      return "audio/wav";
  }
}
__name(getAudioMimeType, "getAudioMimeType");
function arrayBufferToBase64(buffer) {
  if (isDeno) {
    const bytes = new Uint8Array(buffer);
    let binary2 = "";
    for (let i = 0; i < bytes.length; i++) {
      binary2 += String.fromCharCode(bytes[i]);
    }
    return btoa(binary2);
  } else {
    return Buffer.from(buffer).toString("base64");
  }
}
__name(arrayBufferToBase64, "arrayBufferToBase64");
function audio(dataOrPath, mimeType) {
  const isFilePath = dataOrPath.includes("/") || dataOrPath.includes("\\") || dataOrPath.includes(".");
  if (isFilePath && dataOrPath.length < 1e3) {
    return (async () => {
      const buffer = await fsHelpers.readFile(dataOrPath);
      const base64Data = arrayBufferToBase64(buffer);
      const inferredMimeType = mimeType || getAudioMimeType(dataOrPath);
      return {
        content: [
          {
            type: "audio",
            data: base64Data,
            mimeType: inferredMimeType
          }
        ],
        _meta: {
          mimeType: inferredMimeType,
          isAudio: true
        }
      };
    })();
  }
  const finalMimeType = mimeType || "audio/wav";
  return {
    content: [
      {
        type: "audio",
        data: dataOrPath,
        mimeType: finalMimeType
      }
    ],
    _meta: {
      mimeType: finalMimeType,
      isAudio: true
    }
  };
}
__name(audio, "audio");
function resource(uri, mimeTypeOrContent, text2) {
  if (typeof mimeTypeOrContent === "object" && mimeTypeOrContent !== null && "content" in mimeTypeOrContent) {
    const contentResult = mimeTypeOrContent;
    let extractedText;
    let extractedMimeType;
    if (contentResult._meta && typeof contentResult._meta === "object") {
      const meta = contentResult._meta;
      if (meta.mimeType && typeof meta.mimeType === "string") {
        extractedMimeType = meta.mimeType;
      }
    }
    if (contentResult.content && contentResult.content.length > 0) {
      const firstContent = contentResult.content[0];
      if (firstContent.type === "text" && "text" in firstContent) {
        extractedText = firstContent.text;
      }
    }
    const resourceContent2 = {
      type: "resource",
      resource: {
        uri,
        ...extractedMimeType && { mimeType: extractedMimeType },
        ...extractedText && { text: extractedText }
      }
    };
    return {
      content: [resourceContent2]
    };
  }
  const mimeType = mimeTypeOrContent;
  const resourceContent = {
    type: "resource",
    resource: {
      uri,
      ...mimeType && { mimeType },
      ...text2 && { text: text2 }
    }
  };
  return {
    content: [resourceContent]
  };
}
__name(resource, "resource");
function error(message) {
  return {
    isError: true,
    content: [
      {
        type: "text",
        text: message
      }
    ]
  };
}
__name(error, "error");
function object(data) {
  return Array.isArray(data) ? array(data) : {
    content: [
      {
        type: "text",
        text: JSON.stringify(data, null, 2)
      }
    ],
    structuredContent: data,
    _meta: {
      mimeType: "application/json"
    }
  };
}
__name(object, "object");
function array(data) {
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify(data, null, 2)
      }
    ],
    structuredContent: { data }
  };
}
__name(array, "array");
function html(content) {
  return {
    content: [
      {
        type: "text",
        text: content
      }
    ],
    _meta: {
      mimeType: "text/html"
    }
  };
}
__name(html, "html");
function markdown(content) {
  return {
    content: [
      {
        type: "text",
        text: content
      }
    ],
    _meta: {
      mimeType: "text/markdown"
    }
  };
}
__name(markdown, "markdown");
function xml(content) {
  return {
    content: [
      {
        type: "text",
        text: content
      }
    ],
    _meta: {
      mimeType: "text/xml"
    }
  };
}
__name(xml, "xml");
function css(content) {
  return {
    content: [
      {
        type: "text",
        text: content
      }
    ],
    _meta: {
      mimeType: "text/css"
    }
  };
}
__name(css, "css");
function javascript(content) {
  return {
    content: [
      {
        type: "text",
        text: content
      }
    ],
    _meta: {
      mimeType: "text/javascript"
    }
  };
}
__name(javascript, "javascript");
function binary(base64Data, mimeType) {
  return {
    content: [
      {
        type: "text",
        text: base64Data
      }
    ],
    _meta: {
      mimeType,
      isBinary: true
    }
  };
}
__name(binary, "binary");
function widget(config) {
  const props = config.props || config.data || {};
  const { output, message } = config;
  const finalContent = message ? [{ type: "text", text: message }] : Array.isArray(output?.content) && output.content.length > 0 ? output.content : [{ type: "text", text: "" }];
  const meta = {
    ...output?._meta || {},
    "mcp-use/props": props
  };
  const result = {
    content: finalContent,
    _meta: meta
  };
  if (output?.structuredContent) {
    result.structuredContent = output.structuredContent;
  } else if (Object.keys(props).length > 0) {
    result.structuredContent = props;
  }
  return result;
}
__name(widget, "widget");
function mix(...results) {
  const structuredContent = results.find((result) => result.structuredContent) && results.filter((result) => result.structuredContent).map((result) => result.structuredContent).reduce(
    (acc, result) => {
      return { ...acc, ...result };
    },
    {}
  );
  const _meta = results.find((result) => result._meta) && results.filter((result) => result._meta).map((result) => result._meta).reduce(
    (acc, result) => {
      return { ...acc, ...result };
    },
    {}
  );
  return {
    content: results.flatMap((result) => result.content),
    ...structuredContent && { structuredContent },
    ..._meta && { _meta }
  };
}
__name(mix, "mix");

// src/server/utils/index.ts
init_runtime();

// src/server/utils/server-helpers.ts
var import_hono = require("hono");
var import_cors = require("hono/cors");
init_runtime();
function getDefaultCorsOptions() {
  return {
    origin: "*",
    allowMethods: ["GET", "HEAD", "POST", "PUT", "DELETE", "OPTIONS"],
    allowHeaders: [
      "Content-Type",
      "Accept",
      "Authorization",
      "mcp-protocol-version",
      "mcp-session-id",
      "X-Proxy-Token",
      "X-Target-URL"
    ],
    // Expose mcp-session-id so browser clients can read it from responses
    exposeHeaders: ["mcp-session-id"]
  };
}
__name(getDefaultCorsOptions, "getDefaultCorsOptions");
function createHonoApp(requestLogger2) {
  const app = new import_hono.Hono();
  app.use("*", (0, import_cors.cors)(getDefaultCorsOptions()));
  app.use("*", requestLogger2);
  return app;
}
__name(createHonoApp, "createHonoApp");
function getServerBaseUrl(serverBaseUrl, serverHost, serverPort) {
  if (serverBaseUrl) {
    return serverBaseUrl;
  }
  const mcpUrl = getEnv("MCP_URL");
  if (mcpUrl) {
    return mcpUrl;
  }
  return `http://${serverHost}:${serverPort}`;
}
__name(getServerBaseUrl, "getServerBaseUrl");
function getCSPUrls() {
  const cspUrlsEnv = getEnv("CSP_URLS");
  if (!cspUrlsEnv) {
    console.log("[CSP] No CSP_URLS environment variable found");
    return [];
  }
  const urls = cspUrlsEnv.split(",").map((url) => url.trim()).filter((url) => url.length > 0);
  console.log("[CSP] Parsed CSP URLs:", urls);
  return urls;
}
__name(getCSPUrls, "getCSPUrls");
function logRegisteredItems(registeredTools, registeredPrompts, registeredResources) {
  console.log("\n\u{1F4CB} Server exposes:");
  console.log(`   Tools: ${registeredTools.length}`);
  if (registeredTools.length > 0) {
    registeredTools.forEach((name) => {
      console.log(`      - ${name}`);
    });
  }
  console.log(`   Prompts: ${registeredPrompts.length}`);
  if (registeredPrompts.length > 0) {
    registeredPrompts.forEach((name) => {
      console.log(`      - ${name}`);
    });
  }
  console.log(`   Resources: ${registeredResources.length}`);
  if (registeredResources.length > 0) {
    registeredResources.forEach((name) => {
      console.log(`      - ${name}`);
    });
  }
  console.log("");
}
__name(logRegisteredItems, "logRegisteredItems");
function parseTemplateUri(template, uri) {
  const params = {};
  let regexPattern = template.replace(/[.*+?^$()[\]\\|]/g, "\\$&");
  const paramNames = [];
  regexPattern = regexPattern.replace(/\{([^}]+)\}/g, (_, paramName) => {
    paramNames.push(paramName);
    return "([^/]+)";
  });
  const regex = new RegExp(`^${regexPattern}$`);
  const match = uri.match(regex);
  if (match) {
    paramNames.forEach((paramName, index) => {
      params[paramName] = match[index + 1];
    });
  }
  return params;
}
__name(parseTemplateUri, "parseTemplateUri");

// src/server/utils/server-lifecycle.ts
init_runtime();
function isProductionMode() {
  return getEnv("NODE_ENV") === "production";
}
__name(isProductionMode, "isProductionMode");
function getDenoCorsHeaders() {
  return {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type"
  };
}
__name(getDenoCorsHeaders, "getDenoCorsHeaders");
function applyDenoCorsHeaders(response) {
  const corsHeaders = getDenoCorsHeaders();
  const newHeaders = new Headers(response.headers);
  Object.entries(corsHeaders).forEach(([key, value]) => {
    newHeaders.set(key, value);
  });
  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers: newHeaders
  });
}
__name(applyDenoCorsHeaders, "applyDenoCorsHeaders");
function createSupabasePathRewriter() {
  return (pathname) => {
    let newPathname = pathname;
    const functionsMatch = pathname.match(/^\/functions\/v1\/[^/]+(\/.*)?$/);
    if (functionsMatch) {
      newPathname = functionsMatch[1] || "/";
    } else {
      const functionNameMatch = pathname.match(/^\/([^/]+)(\/.*)?$/);
      if (functionNameMatch && functionNameMatch[2]) {
        newPathname = functionNameMatch[2] || "/";
      }
    }
    return newPathname;
  };
}
__name(createSupabasePathRewriter, "createSupabasePathRewriter");
function rewriteSupabaseRequest(req) {
  const url = new URL(req.url);
  const pathname = url.pathname;
  const rewriter = createSupabasePathRewriter();
  const newPathname = rewriter(pathname);
  if (newPathname !== pathname) {
    const newUrl = new URL(newPathname + url.search, url.origin);
    return new Request(newUrl, {
      method: req.method,
      headers: req.headers,
      body: req.body,
      redirect: req.redirect
    });
  }
  return req;
}
__name(rewriteSupabaseRequest, "rewriteSupabaseRequest");
async function startServer(app, port, host, options) {
  if (isDeno) {
    const corsHeaders = getDenoCorsHeaders();
    globalThis.Deno.serve(
      { port, hostname: host },
      async (req) => {
        if (req.method === "OPTIONS") {
          return new Response("ok", { headers: corsHeaders });
        }
        let finalReq = req;
        if (options?.onDenoRequest) {
          finalReq = await options.onDenoRequest(req);
        }
        let response = await app.fetch(finalReq);
        if (options?.onDenoResponse) {
          response = await options.onDenoResponse(response);
        } else {
          response = applyDenoCorsHeaders(response);
        }
        return response;
      }
    );
    console.log(`[SERVER] Listening`);
  } else {
    const { serve } = await import("@hono/node-server");
    serve(
      {
        fetch: app.fetch,
        port,
        hostname: host
      },
      (_info) => {
        console.log(`[SERVER] Listening on http://${host}:${port}`);
        console.log(
          `[MCP] Endpoints: http://${host}:${port}/mcp and http://${host}:${port}/sse`
        );
      }
    );
  }
}
__name(startServer, "startServer");

// src/server/connect-adapter.ts
function isExpressMiddleware(middleware) {
  if (!middleware || typeof middleware !== "function") {
    return false;
  }
  const paramCount = middleware.length;
  if (paramCount === 3 || paramCount === 4) {
    return true;
  }
  if (paramCount === 2) {
    const fnString = middleware.toString();
    const expressPatterns = [
      /\bres\.(send|json|status|end|redirect|render|sendFile|download)\b/,
      /\breq\.(body|params|query|cookies|session)\b/,
      /\breq\.get\s*\(/,
      /\bres\.set\s*\(/
    ];
    const hasExpressPattern = expressPatterns.some(
      (pattern) => pattern.test(fnString)
    );
    if (hasExpressPattern) {
      return true;
    }
    return false;
  }
  return false;
}
__name(isExpressMiddleware, "isExpressMiddleware");
async function adaptMiddleware(middleware, middlewarePath = "*") {
  if (isExpressMiddleware(middleware)) {
    return adaptConnectMiddleware(middleware, middlewarePath);
  }
  return middleware;
}
__name(adaptMiddleware, "adaptMiddleware");
async function adaptConnectMiddleware(connectMiddleware, middlewarePath) {
  let createRequest2;
  let createResponse;
  try {
    const { createRequire } = await import("module");
    const { pathToFileURL } = await import("url");
    const userProjectRequire = createRequire(
      pathToFileURL(
        // Use process.cwd() since this is a runtime utility that should work from user's project
        process.cwd() + "/package.json"
      ).href
    );
    const httpMocksPath = userProjectRequire.resolve("node-mocks-http");
    const httpMocks = await import(httpMocksPath);
    createRequest2 = httpMocks.createRequest;
    createResponse = httpMocks.createResponse;
  } catch (error2) {
    throw new Error(
      "\u274C Widget middleware dependencies not installed!\n\nTo use Connect middleware adapters with MCP widgets, you need to install:\n\n  npm install node-mocks-http\n  # or\n  pnpm add node-mocks-http\n\nThis dependency is automatically included in projects created with 'create-mcp-use-app'."
    );
  }
  let normalizedPath = middlewarePath;
  if (normalizedPath.endsWith("*")) {
    normalizedPath = normalizedPath.slice(0, -1);
  }
  if (normalizedPath.endsWith("/")) {
    normalizedPath = normalizedPath.slice(0, -1);
  }
  const honoMiddleware = /* @__PURE__ */ __name(async (c, next) => {
    const request = c.req.raw;
    const parsedURL = new URL(request.url, "http://localhost");
    const query = {};
    for (const [key, value] of parsedURL.searchParams.entries()) {
      query[key] = value;
    }
    let middlewarePathname = parsedURL.pathname;
    if (normalizedPath && middlewarePathname.startsWith(normalizedPath)) {
      middlewarePathname = middlewarePathname.substring(normalizedPath.length);
      if (middlewarePathname === "") {
        middlewarePathname = "/";
      } else if (!middlewarePathname.startsWith("/")) {
        middlewarePathname = "/" + middlewarePathname;
      }
    }
    const mockRequest = createRequest2({
      method: request.method.toUpperCase(),
      url: middlewarePathname + parsedURL.search,
      headers: request.headers && typeof request.headers.entries === "function" ? Object.fromEntries(request.headers.entries()) : request.headers,
      query,
      ...request.body && { body: request.body }
    });
    const mockResponse = createResponse();
    let responseResolved = false;
    const res = await new Promise((resolve) => {
      const originalEnd = mockResponse.end.bind(mockResponse);
      mockResponse.end = (...args) => {
        const result = originalEnd(...args);
        if (!responseResolved && mockResponse.writableEnded) {
          responseResolved = true;
          const statusCode = mockResponse.statusCode;
          const noBodyStatuses = [204, 304];
          const responseBody = noBodyStatuses.includes(statusCode) ? null : mockResponse._getData() || mockResponse._getBuffer() || null;
          const connectResponse = new Response(responseBody, {
            status: statusCode,
            statusText: mockResponse.statusMessage,
            headers: mockResponse.getHeaders()
          });
          resolve(connectResponse);
        }
        return result;
      };
      connectMiddleware(mockRequest, mockResponse, () => {
        if (!responseResolved && !mockResponse.writableEnded) {
          responseResolved = true;
          const statusCode = mockResponse.statusCode;
          const noBodyStatuses = [204, 304];
          const responseBody = noBodyStatuses.includes(statusCode) ? null : mockResponse._getData() || mockResponse._getBuffer() || null;
          const preparedHeaders = c.newResponse(null, 204, {}).headers;
          for (const key of [...preparedHeaders.keys()]) {
            if (preparedHeaders.has(key)) {
              c.header(key, void 0);
            }
            if (c.res && c.res.headers.has(key)) {
              c.res.headers.delete(key);
            }
          }
          const connectHeaders = mockResponse.getHeaders();
          for (const [key, value] of Object.entries(connectHeaders)) {
            if (value !== void 0) {
              c.header(
                key,
                Array.isArray(value) ? value.join(", ") : String(value)
              );
            }
          }
          c.status(statusCode);
          if (noBodyStatuses.includes(statusCode)) {
            resolve(c.newResponse(null, statusCode));
          } else if (responseBody) {
            resolve(c.body(responseBody));
          } else {
            resolve(void 0);
          }
        }
      });
    });
    if (res) {
      c.res = res;
      return res;
    }
    await next();
  }, "honoMiddleware");
  return honoMiddleware;
}
__name(adaptConnectMiddleware, "adaptConnectMiddleware");

// src/server/utils/hono-proxy.ts
function createHonoProxy(target, app) {
  return new Proxy(target, {
    get(target2, prop) {
      if (prop === "use") {
        return async (...args) => {
          const hasPath = typeof args[0] === "string";
          const path = hasPath ? args[0] : "*";
          const handlers = hasPath ? args.slice(1) : args;
          const adaptedHandlers = handlers.map((handler) => {
            if (isExpressMiddleware(handler)) {
              return { __isExpressMiddleware: true, handler, path };
            }
            return handler;
          });
          const hasExpressMiddleware = adaptedHandlers.some(
            (h) => h.__isExpressMiddleware
          );
          if (hasExpressMiddleware) {
            await Promise.all(
              adaptedHandlers.map(async (h) => {
                if (h.__isExpressMiddleware) {
                  const adapted = await adaptConnectMiddleware(
                    h.handler,
                    h.path
                  );
                  if (hasPath) {
                    app.use(path, adapted);
                  } else {
                    app.use(adapted);
                  }
                } else {
                  if (hasPath) {
                    app.use(path, h);
                  } else {
                    app.use(h);
                  }
                }
              })
            );
            return target2;
          }
          return app.use(...args);
        };
      }
      if (prop in target2) {
        return target2[prop];
      }
      const value = app[prop];
      return typeof value === "function" ? value.bind(app) : value;
    }
  });
}
__name(createHonoProxy, "createHonoProxy");

// src/server/widgets/mount-widgets-dev.ts
init_runtime();

// src/server/widgets/mcp-ui-adapter.ts
var import_server = require("@mcp-ui/server");
function buildWidgetUrl(widget2, props, config) {
  const url = new URL(
    `/mcp-use/widgets/${widget2}`,
    `${config.baseUrl}:${config.port}`
  );
  if (props && Object.keys(props).length > 0) {
    url.searchParams.set("props", JSON.stringify(props));
  }
  return url.toString();
}
__name(buildWidgetUrl, "buildWidgetUrl");
async function createExternalUrlResource(uri, iframeUrl, encoding = "text", adapters, metadata) {
  return await (0, import_server.createUIResource)({
    uri,
    content: { type: "externalUrl", iframeUrl },
    encoding,
    adapters,
    metadata
  });
}
__name(createExternalUrlResource, "createExternalUrlResource");
async function createRawHtmlResource(uri, htmlString, encoding = "text", adapters, metadata) {
  return await (0, import_server.createUIResource)({
    uri,
    content: { type: "rawHtml", htmlString },
    encoding,
    adapters,
    metadata
  });
}
__name(createRawHtmlResource, "createRawHtmlResource");
async function createRemoteDomResource(uri, script, framework = "react", encoding = "text", adapters, metadata) {
  return await (0, import_server.createUIResource)({
    uri,
    content: { type: "remoteDom", script, framework },
    encoding,
    adapters,
    metadata
  });
}
__name(createRemoteDomResource, "createRemoteDomResource");
function createAppsSdkResource(uri, htmlTemplate, metadata) {
  const resource2 = {
    uri,
    mimeType: "text/html+skybridge",
    text: htmlTemplate
  };
  if (metadata && Object.keys(metadata).length > 0) {
    resource2._meta = metadata;
  }
  return {
    type: "resource",
    resource: resource2
  };
}
__name(createAppsSdkResource, "createAppsSdkResource");
async function createUIResourceFromDefinition(definition, params, config) {
  const buildIdPart = config.buildId ? `-${config.buildId}` : "";
  const uri = definition.type === "appsSdk" ? `ui://widget/${definition.name}${buildIdPart}.html` : `ui://widget/${definition.name}${buildIdPart}`;
  const encoding = definition.encoding || "text";
  switch (definition.type) {
    case "externalUrl": {
      const widgetUrl = buildWidgetUrl(definition.widget, params, config);
      return await createExternalUrlResource(
        uri,
        widgetUrl,
        encoding,
        definition.adapters,
        definition.appsSdkMetadata
      );
    }
    case "rawHtml": {
      return await createRawHtmlResource(
        uri,
        definition.htmlContent,
        encoding,
        definition.adapters,
        definition.appsSdkMetadata
      );
    }
    case "remoteDom": {
      const framework = definition.framework || "react";
      return await createRemoteDomResource(
        uri,
        definition.script,
        framework,
        encoding,
        definition.adapters,
        definition.appsSdkMetadata
      );
    }
    case "appsSdk": {
      return createAppsSdkResource(
        uri,
        definition.htmlTemplate,
        definition.appsSdkMetadata
      );
    }
    default: {
      const _exhaustive = definition;
      throw new Error(`Unknown UI resource type: ${_exhaustive.type}`);
    }
  }
}
__name(createUIResourceFromDefinition, "createUIResourceFromDefinition");

// src/server/widgets/widget-helpers.ts
init_runtime();
function generateWidgetUri(widgetName, buildId, extension = "", suffix = "") {
  const parts = [widgetName];
  if (buildId) {
    parts.push(buildId);
  }
  if (suffix) {
    parts.push(suffix);
  }
  return `ui://widget/${parts.join("-")}${extension}`;
}
__name(generateWidgetUri, "generateWidgetUri");
function convertPropsToInputs(props) {
  if (!props) return [];
  return Object.entries(props).map(([name, prop]) => ({
    name,
    type: prop.type,
    description: prop.description,
    required: prop.required,
    default: prop.default
  }));
}
__name(convertPropsToInputs, "convertPropsToInputs");
function applyDefaultProps(props) {
  if (!props) return {};
  const defaults = {};
  for (const [key, prop] of Object.entries(props)) {
    if (prop.default !== void 0) {
      defaults[key] = prop.default;
    }
  }
  return defaults;
}
__name(applyDefaultProps, "applyDefaultProps");
async function readBuildManifest() {
  try {
    const manifestPath = pathHelpers.join(
      isDeno ? "." : getCwd(),
      "dist",
      "mcp-use.json"
    );
    const content = await fsHelpers.readFileSync(manifestPath, "utf8");
    return JSON.parse(content);
  } catch {
    return null;
  }
}
__name(readBuildManifest, "readBuildManifest");
function getContentType(filename) {
  const ext = filename.split(".").pop()?.toLowerCase();
  switch (ext) {
    case "js":
      return "application/javascript";
    case "css":
      return "text/css";
    case "png":
      return "image/png";
    case "jpg":
    case "jpeg":
      return "image/jpeg";
    case "svg":
      return "image/svg+xml";
    case "gif":
      return "image/gif";
    case "webp":
      return "image/webp";
    case "ico":
      return "image/x-icon";
    case "woff":
      return "font/woff";
    case "woff2":
      return "font/woff2";
    case "ttf":
      return "font/ttf";
    case "otf":
      return "font/otf";
    case "json":
      return "application/json";
    case "pdf":
      return "application/pdf";
    default:
      return "application/octet-stream";
  }
}
__name(getContentType, "getContentType");
function processWidgetHtml(html2, widgetName, baseUrl) {
  let processedHtml = html2;
  if (baseUrl && processedHtml) {
    let htmlWithoutComments = processedHtml;
    let prevHtmlWithoutComments;
    do {
      prevHtmlWithoutComments = htmlWithoutComments;
      htmlWithoutComments = htmlWithoutComments.replace(/<!--[\s\S]*?-->/g, "");
    } while (prevHtmlWithoutComments !== htmlWithoutComments);
    const baseTagRegex = /<base\s+[^>]*\/?>/i;
    if (baseTagRegex.test(htmlWithoutComments)) {
      const actualBaseTagMatch = processedHtml.match(/<base\s+[^>]*\/?>/i);
      if (actualBaseTagMatch) {
        processedHtml = processedHtml.replace(
          actualBaseTagMatch[0],
          `<base href="${baseUrl}" />`
        );
      }
    } else {
      const headTagRegex = /<head[^>]*>/i;
      if (headTagRegex.test(processedHtml)) {
        processedHtml = processedHtml.replace(
          headTagRegex,
          (match) => `${match}
    <base href="${baseUrl}" />`
        );
      }
    }
    processedHtml = processedHtml.replace(
      /src="\/mcp-use\/widgets\/([^"]+)"/g,
      `src="${baseUrl}/mcp-use/widgets/$1"`
    );
    processedHtml = processedHtml.replace(
      /href="\/mcp-use\/widgets\/([^"]+)"/g,
      `href="${baseUrl}/mcp-use/widgets/$1"`
    );
    processedHtml = processedHtml.replace(
      /<head[^>]*>/i,
      `<head>
    <script>window.__getFile = (filename) => { return "${baseUrl}/mcp-use/widgets/${widgetName}/"+filename }; window.__mcpPublicUrl = "${baseUrl}/mcp-use/public";</script>`
    );
  }
  return processedHtml;
}
__name(processWidgetHtml, "processWidgetHtml");
function createWidgetRegistration(widgetName, metadata, html2, serverConfig, isDev = false) {
  const props = metadata.props || metadata.inputs || metadata.schema || {};
  const description = metadata.description || `Widget: ${widgetName}`;
  const title = metadata.title || widgetName;
  const exposeAsTool = metadata.exposeAsTool !== void 0 ? metadata.exposeAsTool : true;
  const mcp_connect_domain = serverConfig.serverBaseUrl ? new URL(serverConfig.serverBaseUrl || "").origin : null;
  return {
    name: widgetName,
    title,
    description,
    type: "appsSdk",
    props,
    _meta: {
      "mcp-use/widget": {
        name: widgetName,
        title,
        description,
        type: "appsSdk",
        props,
        html: html2,
        dev: isDev,
        exposeAsTool
      },
      ...metadata._meta || {}
    },
    htmlTemplate: html2,
    appsSdkMetadata: {
      "openai/widgetDescription": description,
      "openai/toolInvocation/invoking": `Loading ${widgetName}...`,
      "openai/toolInvocation/invoked": `${widgetName} ready`,
      "openai/widgetAccessible": true,
      "openai/resultCanProduceWidget": true,
      ...metadata.appsSdkMetadata || {},
      "openai/widgetCSP": {
        connect_domains: [
          // always also add the base url of the server
          ...mcp_connect_domain ? [mcp_connect_domain] : [],
          ...metadata.appsSdkMetadata?.["openai/widgetCSP"]?.connect_domains || []
        ],
        resource_domains: [
          "https://*.oaistatic.com",
          "https://*.oaiusercontent.com",
          ...isDev ? [] : ["https://*.openai.com"],
          // always also add the base url of the server
          ...mcp_connect_domain ? [mcp_connect_domain] : [],
          // add additional CSP URLs from environment variable
          ...serverConfig.cspUrls,
          ...metadata.appsSdkMetadata?.["openai/widgetCSP"]?.resource_domains || []
        ]
      }
    }
  };
}
__name(createWidgetRegistration, "createWidgetRegistration");
async function createWidgetUIResource(definition, params, serverConfig) {
  let configBaseUrl = `http://${serverConfig.serverHost}`;
  let configPort = serverConfig.serverPort || 3e3;
  if (serverConfig.serverBaseUrl) {
    try {
      const url = new URL(serverConfig.serverBaseUrl);
      configBaseUrl = `${url.protocol}//${url.hostname}`;
      configPort = url.port || (url.protocol === "https:" ? 443 : 80);
    } catch (e) {
      console.warn("Failed to parse baseUrl, falling back to host:port", e);
    }
  }
  const urlConfig = {
    baseUrl: configBaseUrl,
    port: configPort,
    buildId: serverConfig.buildId
  };
  const uiResource = await createUIResourceFromDefinition(
    definition,
    params,
    urlConfig
  );
  if (definition._meta && Object.keys(definition._meta).length > 0) {
    uiResource.resource._meta = {
      ...uiResource.resource._meta,
      ...definition._meta
    };
  }
  return uiResource;
}
__name(createWidgetUIResource, "createWidgetUIResource");
function ensureWidgetMetadata(metadata, widgetName, widgetDescription) {
  const result = { ...metadata };
  if (!result.description) {
    result.description = widgetDescription || `Widget: ${widgetName}`;
  }
  return result;
}
__name(ensureWidgetMetadata, "ensureWidgetMetadata");
async function readWidgetHtml(filePath, widgetName) {
  try {
    return await fsHelpers.readFileSync(filePath, "utf8");
  } catch (error2) {
    console.error(
      `[WIDGET] Failed to read html template for widget ${widgetName}:`,
      error2
    );
    return "";
  }
}
__name(readWidgetHtml, "readWidgetHtml");
async function registerWidgetFromTemplate(widgetName, htmlPath, metadata, serverConfig, registerWidget, isDev = false) {
  let html2 = await readWidgetHtml(htmlPath, widgetName);
  if (!html2) {
    return;
  }
  html2 = processWidgetHtml(html2, widgetName, serverConfig.serverBaseUrl);
  const processedMetadata = ensureWidgetMetadata(metadata, widgetName);
  const widgetRegistration = createWidgetRegistration(
    widgetName,
    processedMetadata,
    html2,
    serverConfig,
    isDev
  );
  registerWidget(widgetRegistration);
}
__name(registerWidgetFromTemplate, "registerWidgetFromTemplate");
function setupPublicRoutes(app, useDistDirectory = false) {
  app.get("/mcp-use/public/*", async (c) => {
    const filePath = c.req.path.replace("/mcp-use/public/", "");
    const basePath = useDistDirectory ? "dist/public" : "public";
    const fullPath = pathHelpers.join(getCwd(), basePath, filePath);
    try {
      if (await fsHelpers.existsSync(fullPath)) {
        const content = await fsHelpers.readFile(fullPath);
        const contentType = getContentType(filePath);
        return new Response(content, {
          status: 200,
          headers: { "Content-Type": contentType }
        });
      }
      return c.notFound();
    } catch {
      return c.notFound();
    }
  });
}
__name(setupPublicRoutes, "setupPublicRoutes");
function setupFaviconRoute(app, faviconPath, useDistDirectory = false) {
  if (!faviconPath) {
    return;
  }
  app.get("/favicon.ico", async (c) => {
    const basePath = useDistDirectory ? "dist/public" : "public";
    const fullPath = pathHelpers.join(getCwd(), basePath, faviconPath);
    try {
      if (await fsHelpers.existsSync(fullPath)) {
        const content = await fsHelpers.readFile(fullPath);
        const contentType = getContentType(faviconPath);
        return new Response(content, {
          status: 200,
          headers: {
            "Content-Type": contentType,
            "Cache-Control": "public, max-age=31536000"
            // Cache for 1 year
          }
        });
      }
      return c.notFound();
    } catch {
      return c.notFound();
    }
  });
}
__name(setupFaviconRoute, "setupFaviconRoute");

// src/server/widgets/mount-widgets-dev.ts
var TMP_MCP_USE_DIR = ".mcp-use";
async function mountWidgetsDev(app, serverConfig, registerWidget, options) {
  const { promises: fs } = await import("fs");
  const baseRoute = options?.baseRoute || "/mcp-use/widgets";
  const resourcesDir = options?.resourcesDir || "resources";
  const srcDir = pathHelpers.join(getCwd(), resourcesDir);
  try {
    await fs.access(srcDir);
  } catch (error2) {
    console.log(
      `[WIDGETS] No ${resourcesDir}/ directory found - skipping widget serving`
    );
    return;
  }
  const entries = [];
  try {
    const files = await fs.readdir(srcDir, { withFileTypes: true });
    for (const dirent of files) {
      if (dirent.name.startsWith("._") || dirent.name.startsWith(".DS_Store")) {
        continue;
      }
      if (dirent.isFile() && (dirent.name.endsWith(".tsx") || dirent.name.endsWith(".ts"))) {
        entries.push({
          name: dirent.name.replace(/\.tsx?$/, ""),
          path: pathHelpers.join(srcDir, dirent.name)
        });
      } else if (dirent.isDirectory()) {
        const widgetPath = pathHelpers.join(srcDir, dirent.name, "widget.tsx");
        try {
          await fs.access(widgetPath);
          entries.push({
            name: dirent.name,
            path: widgetPath
          });
        } catch {
        }
      }
    }
  } catch (error2) {
    console.log(`[WIDGETS] No widgets found in ${resourcesDir}/ directory`);
    return;
  }
  if (entries.length === 0) {
    console.log(`[WIDGETS] No widgets found in ${resourcesDir}/ directory`);
    return;
  }
  const tempDir = pathHelpers.join(getCwd(), TMP_MCP_USE_DIR);
  try {
    await fs.access(tempDir);
    const currentWidgetNames = new Set(entries.map((e) => e.name));
    const existingDirs = await fs.readdir(tempDir, { withFileTypes: true });
    for (const dirent of existingDirs) {
      if (dirent.isDirectory() && !currentWidgetNames.has(dirent.name)) {
        const staleDir = pathHelpers.join(tempDir, dirent.name);
        await fs.rm(staleDir, { recursive: true, force: true });
        console.log(`[WIDGETS] Cleaned up stale widget: ${dirent.name}`);
      }
    }
  } catch {
  }
  await fs.mkdir(tempDir, { recursive: true }).catch(() => {
  });
  let createServer;
  let react;
  let tailwindcss;
  try {
    const { createRequire } = await import("module");
    const { pathToFileURL } = await import("url");
    const userProjectRequire = createRequire(
      pathToFileURL(pathHelpers.join(getCwd(), "package.json")).href
    );
    const vitePath = userProjectRequire.resolve("vite");
    const reactPluginPath = userProjectRequire.resolve("@vitejs/plugin-react");
    const tailwindPath = userProjectRequire.resolve("@tailwindcss/vite");
    const viteModule = await import(vitePath);
    createServer = viteModule.createServer;
    const reactModule = await import(reactPluginPath);
    react = reactModule.default;
    const tailwindModule = await import(tailwindPath);
    tailwindcss = tailwindModule.default;
  } catch (error2) {
    throw new Error(
      "\u274C Widget dependencies not installed!\n\nTo use MCP widgets with resources folder, you need to install the required dependencies:\n\n  npm install vite @vitejs/plugin-react @tailwindcss/vite\n  # or\n  pnpm add vite @vitejs/plugin-react @tailwindcss/vite\n\nThese dependencies are automatically included in projects created with 'create-mcp-use-app'.\nFor production, pre-build your widgets using 'mcp-use build'."
    );
  }
  const widgets = entries.map((entry) => {
    return {
      name: entry.name,
      description: `Widget: ${entry.name}`,
      entry: entry.path
    };
  });
  for (const widget2 of widgets) {
    const widgetTempDir = pathHelpers.join(tempDir, widget2.name);
    await fs.mkdir(widgetTempDir, { recursive: true });
    const resourcesPath = pathHelpers.join(getCwd(), resourcesDir);
    const relativeResourcesPath = pathHelpers.relative(widgetTempDir, resourcesPath).replace(/\\/g, "/");
    const mcpUsePath = pathHelpers.join(getCwd(), "node_modules", "mcp-use");
    const relativeMcpUsePath = pathHelpers.relative(widgetTempDir, mcpUsePath).replace(/\\/g, "/");
    const cssContent = `@import "tailwindcss";

/* Configure Tailwind to scan the resources directory and mcp-use package */
@source "${relativeResourcesPath}";
@source "${relativeMcpUsePath}/**/*.{ts,tsx,js,jsx}";
`;
    await fs.writeFile(
      pathHelpers.join(widgetTempDir, "styles.css"),
      cssContent,
      "utf8"
    );
    const entryContent = `import React from 'react'
import { createRoot } from 'react-dom/client'
import './styles.css'
import Component from '${widget2.entry}'

const container = document.getElementById('widget-root')
if (container && Component) {
  const root = createRoot(container)
  root.render(<Component />)
}
`;
    const htmlContent = `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>${widget2.name} Widget</title>${serverConfig.favicon ? `
    <link rel="icon" href="/mcp-use/public/${serverConfig.favicon}" />` : ""}
  </head>
  <body>
    <div id="widget-root"></div>
    <script type="module" src="${baseRoute}/${widget2.name}/entry.tsx"></script>
  </body>
</html>`;
    await fs.writeFile(
      pathHelpers.join(widgetTempDir, "entry.tsx"),
      entryContent,
      "utf8"
    );
    await fs.writeFile(
      pathHelpers.join(widgetTempDir, "index.html"),
      htmlContent,
      "utf8"
    );
  }
  const serverOrigin = serverConfig.serverBaseUrl;
  console.log(
    `[WIDGETS] Serving ${entries.length} widget(s) with shared Vite dev server and HMR`
  );
  const ssrCssPlugin = {
    name: "ssr-css-handler",
    enforce: "pre",
    resolveId(id, importer, options2) {
      if (options2 && options2.ssr === true && (id.endsWith(".css") || id.endsWith(".module.css"))) {
        return "\0ssr-css:" + id;
      }
      return null;
    },
    load(id, options2) {
      if (options2 && options2.ssr === true && id.startsWith("\0ssr-css:")) {
        return "export default {}";
      }
      return null;
    }
  };
  const watchResourcesPlugin = {
    name: "watch-resources",
    configureServer(server) {
      const resourcesPath = pathHelpers.join(getCwd(), resourcesDir);
      server.watcher.add(resourcesPath);
      console.log(`[WIDGETS] Watching resources directory: ${resourcesPath}`);
      server.watcher.on("unlink", async (filePath) => {
        const relativePath = pathHelpers.relative(resourcesPath, filePath);
        if ((relativePath.endsWith(".tsx") || relativePath.endsWith(".ts")) && !relativePath.includes("/")) {
          const widgetName = relativePath.replace(/\.tsx?$/, "");
          const widgetDir = pathHelpers.join(tempDir, widgetName);
          try {
            await fs.access(widgetDir);
            await fs.rm(widgetDir, { recursive: true, force: true });
            console.log(
              `[WIDGETS] Cleaned up stale widget (file removed): ${widgetName}`
            );
          } catch {
          }
        } else if (relativePath.endsWith("widget.tsx")) {
          const parts = relativePath.split("/");
          if (parts.length === 2) {
            const widgetName = parts[0];
            const widgetDir = pathHelpers.join(tempDir, widgetName);
            try {
              await fs.access(widgetDir);
              await fs.rm(widgetDir, { recursive: true, force: true });
              console.log(
                `[WIDGETS] Cleaned up stale widget (file removed): ${widgetName}`
              );
            } catch {
            }
          }
        }
      });
      server.watcher.on("unlinkDir", async (dirPath) => {
        const relativePath = pathHelpers.relative(resourcesPath, dirPath);
        if (relativePath && !relativePath.includes("/")) {
          const widgetName = relativePath;
          const widgetDir = pathHelpers.join(tempDir, widgetName);
          try {
            await fs.access(widgetDir);
            await fs.rm(widgetDir, { recursive: true, force: true });
            console.log(
              `[WIDGETS] Cleaned up stale widget (directory removed): ${widgetName}`
            );
          } catch {
          }
        }
      });
    }
  };
  const nodeStubsPlugin = {
    name: "node-stubs",
    enforce: "pre",
    resolveId(id) {
      if (id === "posthog-node" || id.startsWith("posthog-node/")) {
        return "\0virtual:posthog-node-stub";
      }
      return null;
    },
    load(id) {
      if (id === "\0virtual:posthog-node-stub") {
        return `
export class PostHog {
  constructor() {}
  capture() {}
  identify() {}
  alias() {}
  flush() { return Promise.resolve(); }
  shutdown() { return Promise.resolve(); }
}
export default PostHog;
`;
      }
      return null;
    }
  };
  const viteServer = await createServer({
    root: tempDir,
    base: baseRoute + "/",
    plugins: [
      nodeStubsPlugin,
      ssrCssPlugin,
      watchResourcesPlugin,
      tailwindcss(),
      react()
    ],
    resolve: {
      alias: {
        "@": pathHelpers.join(getCwd(), resourcesDir)
      }
    },
    server: {
      middlewareMode: true,
      origin: serverOrigin,
      watch: {
        // Watch the resources directory for HMR to work
        // This ensures changes to widget source files trigger hot reload
        ignored: ["**/node_modules/**", "**/.git/**"],
        // Include the resources directory in watch list
        // Vite will watch files imported from outside root
        usePolling: false
      }
    },
    // Explicitly tell Vite to watch files outside root
    // This is needed because widget entry files import from resources directory
    optimizeDeps: {
      // Exclude Node.js-only packages from browser bundling
      // posthog-node is for server-side telemetry and doesn't work in browser
      exclude: ["posthog-node"]
    },
    ssr: {
      // Force Vite to transform these packages in SSR instead of using external requires
      noExternal: ["@openai/apps-sdk-ui", "react-router"],
      // Mark Node.js-only packages as external in SSR mode
      external: ["posthog-node"]
    },
    define: {
      // Define process.env for SSR context
      "process.env.NODE_ENV": JSON.stringify(
        process.env.NODE_ENV || "development"
      ),
      "import.meta.env.DEV": true,
      "import.meta.env.PROD": false,
      "import.meta.env.MODE": JSON.stringify("development"),
      "import.meta.env.SSR": true
    }
  });
  app.use(`${baseRoute}/*`, async (c, next) => {
    const url = new URL(c.req.url);
    const pathname = url.pathname;
    const widgetMatch = pathname.replace(baseRoute, "").match(/^\/([^/]+)/);
    if (widgetMatch) {
      const widgetName = widgetMatch[1];
      const widget2 = widgets.find((w) => w.name === widgetName);
      if (widget2) {
        const relativePath = pathname.replace(baseRoute, "");
        if (relativePath === `/${widgetName}` || relativePath === `/${widgetName}/`) {
          const newUrl = new URL(c.req.url);
          newUrl.pathname = `${baseRoute}/${widgetName}/index.html`;
          const newRequest = new Request(newUrl.toString(), c.req.raw);
          Object.defineProperty(c, "req", {
            value: {
              ...c.req,
              url: newUrl.toString(),
              raw: newRequest
            },
            writable: false,
            configurable: true
          });
        }
      }
    }
    await next();
  });
  const viteMiddleware = await adaptConnectMiddleware(
    viteServer.middlewares,
    `${baseRoute}/*`
  );
  app.use(`${baseRoute}/*`, viteMiddleware);
  setupPublicRoutes(app, false);
  setupFaviconRoute(app, serverConfig.favicon, false);
  app.use(`${baseRoute}/*`, async (c) => {
    const url = new URL(c.req.url);
    const isAsset = url.pathname.match(
      /\.(js|css|png|jpg|jpeg|svg|json|ico|woff2?|tsx?)$/i
    );
    const message = isAsset ? "Widget asset not found" : "Widget not found";
    return c.text(message, 404);
  });
  widgets.forEach((widget2) => {
    console.log(
      `[WIDGET] ${widget2.name} mounted at ${baseRoute}/${widget2.name}`
    );
  });
  for (const widget2 of widgets) {
    let metadata = {};
    try {
      const mod = await viteServer.ssrLoadModule(widget2.entry);
      if (mod.widgetMetadata) {
        metadata = mod.widgetMetadata;
        const schemaField = metadata.props || metadata.inputs;
        if (schemaField) {
          try {
            metadata.props = schemaField;
            if (!metadata.inputs) {
              metadata.inputs = schemaField;
            }
          } catch (error2) {
            console.warn(
              `[WIDGET] Failed to extract schema for ${widget2.name}:`,
              error2
            );
          }
        }
      }
    } catch (error2) {
      console.warn(
        `[WIDGET] Failed to load metadata for ${widget2.name}:`,
        error2
      );
    }
    await registerWidgetFromTemplate(
      widget2.name,
      pathHelpers.join(tempDir, widget2.name, "index.html"),
      metadata.description ? metadata : { ...metadata, description: widget2.description },
      serverConfig,
      registerWidget,
      true
      // isDev
    );
  }
}
__name(mountWidgetsDev, "mountWidgetsDev");

// src/server/widgets/mount-widgets-production.ts
init_runtime();
async function mountWidgetsProduction(app, serverConfig, registerWidget, options) {
  const baseRoute = options?.baseRoute || "/mcp-use/widgets";
  const widgetsDir = pathHelpers.join(
    isDeno ? "." : getCwd(),
    "dist",
    "resources",
    "widgets"
  );
  console.log("widgetsDir", widgetsDir);
  const manifestPath = "./dist/mcp-use.json";
  let widgets = [];
  let widgetsMetadata = {};
  try {
    const manifestContent = await fsHelpers.readFileSync(manifestPath, "utf8");
    const manifest = JSON.parse(manifestContent);
    if (manifest.buildId && typeof manifest.buildId === "string") {
      serverConfig.buildId = manifest.buildId;
      console.log(`[WIDGETS] Build ID: ${manifest.buildId}`);
    }
    if (manifest.widgets && typeof manifest.widgets === "object" && !Array.isArray(manifest.widgets)) {
      widgets = Object.keys(manifest.widgets);
      widgetsMetadata = manifest.widgets;
      console.log(`[WIDGETS] Loaded ${widgets.length} widget(s) from manifest`);
    } else if (manifest.widgets && Array.isArray(manifest.widgets)) {
      widgets = manifest.widgets;
      console.log(
        `[WIDGETS] Loaded ${widgets.length} widget(s) from manifest (legacy format)`
      );
    } else {
      console.log("[WIDGETS] No widgets found in manifest");
    }
  } catch (error2) {
    console.log(
      "[WIDGETS] Could not read manifest file, falling back to directory listing:",
      error2
    );
    try {
      const allEntries = await fsHelpers.readdirSync(widgetsDir);
      for (const name of allEntries) {
        const widgetPath = pathHelpers.join(widgetsDir, name);
        const indexPath = pathHelpers.join(widgetPath, "index.html");
        if (await fsHelpers.existsSync(indexPath)) {
          widgets.push(name);
        }
      }
    } catch (dirError) {
      console.log("[WIDGETS] Directory listing also failed:", dirError);
    }
  }
  if (widgets.length === 0) {
    console.log("[WIDGETS] No built widgets found");
    return;
  }
  console.log(
    `[WIDGETS] Serving ${widgets.length} pre-built widget(s) from dist/resources/widgets/`
  );
  for (const widgetName of widgets) {
    const widgetPath = pathHelpers.join(widgetsDir, widgetName);
    const indexPath = pathHelpers.join(widgetPath, "index.html");
    const metadata = widgetsMetadata[widgetName] || {};
    const mcp_connect_domain = serverConfig.serverBaseUrl ? new URL(serverConfig.serverBaseUrl || "").origin : null;
    console.log("[CSP] mcp_connect_domain", mcp_connect_domain);
    console.log("[CSP] cspUrls", serverConfig.cspUrls);
    console.log("[CSP] metadata.appsSdkMetadata", metadata.appsSdkMetadata);
    console.log("[CSP] metadata._meta", metadata._meta);
    await registerWidgetFromTemplate(
      widgetName,
      indexPath,
      metadata,
      serverConfig,
      registerWidget,
      false
      // isDev
    );
    console.log(`[WIDGET] ${widgetName} mounted at ${baseRoute}/${widgetName}`);
  }
}
__name(mountWidgetsProduction, "mountWidgetsProduction");

// src/server/widgets/setup-widget-routes.ts
init_runtime();
function setupWidgetRoutes(app, serverConfig) {
  app.get("/mcp-use/widgets/:widget/assets/*", async (c) => {
    const widget2 = c.req.param("widget");
    const assetFile = c.req.path.split("/assets/")[1];
    const assetPath = pathHelpers.join(
      getCwd(),
      "dist",
      "resources",
      "widgets",
      widget2,
      "assets",
      assetFile
    );
    try {
      if (await fsHelpers.existsSync(assetPath)) {
        const content = await fsHelpers.readFile(assetPath);
        const contentType = getContentType(assetFile);
        return new Response(content, {
          status: 200,
          headers: { "Content-Type": contentType }
        });
      }
      return c.notFound();
    } catch {
      return c.notFound();
    }
  });
  app.get("/mcp-use/widgets/assets/*", async (c) => {
    const assetFile = c.req.path.split("/assets/")[1];
    const widgetsDir = pathHelpers.join(
      getCwd(),
      "dist",
      "resources",
      "widgets"
    );
    try {
      const widgets = await fsHelpers.readdirSync(widgetsDir);
      for (const widget2 of widgets) {
        const assetPath = pathHelpers.join(
          widgetsDir,
          widget2,
          "assets",
          assetFile
        );
        if (await fsHelpers.existsSync(assetPath)) {
          const content = await fsHelpers.readFile(assetPath);
          const contentType = getContentType(assetFile);
          return new Response(content, {
            status: 200,
            headers: { "Content-Type": contentType }
          });
        }
      }
      return c.notFound();
    } catch {
      return c.notFound();
    }
  });
  app.get("/mcp-use/widgets/:widget", async (c) => {
    const widget2 = c.req.param("widget");
    const filePath = pathHelpers.join(
      getCwd(),
      "dist",
      "resources",
      "widgets",
      widget2,
      "index.html"
    );
    try {
      let html2 = await fsHelpers.readFileSync(filePath, "utf8");
      html2 = processWidgetHtml(html2, widget2, serverConfig.serverBaseUrl);
      return c.html(html2);
    } catch {
      return c.notFound();
    }
  });
  setupPublicRoutes(app, true);
  setupFaviconRoute(app, serverConfig.favicon, true);
}
__name(setupWidgetRoutes, "setupWidgetRoutes");

// src/server/widgets/ui-resource-registration.ts
var import_zod = __toESM(require("zod"), 1);
function uiResourceRegistration(server, definition) {
  const displayName = definition.title || definition.name;
  if (definition.type === "appsSdk" && definition._meta) {
    server.widgetDefinitions.set(
      definition.name,
      definition._meta
    );
  }
  let resourceUri;
  let mimeType;
  switch (definition.type) {
    case "externalUrl":
      resourceUri = generateWidgetUri(definition.widget, server.buildId);
      mimeType = "text/uri-list";
      break;
    case "rawHtml":
      resourceUri = generateWidgetUri(definition.name, server.buildId);
      mimeType = "text/html";
      break;
    case "remoteDom":
      resourceUri = generateWidgetUri(definition.name, server.buildId);
      mimeType = "application/vnd.mcp-ui.remote-dom+javascript";
      break;
    case "appsSdk":
      resourceUri = generateWidgetUri(definition.name, server.buildId, ".html");
      mimeType = "text/html+skybridge";
      break;
    default:
      throw new Error(
        `Unsupported UI resource type. Must be one of: externalUrl, rawHtml, remoteDom, appsSdk`
      );
  }
  const serverConfig = {
    serverHost: server.serverHost,
    serverPort: server.serverPort || 3e3,
    serverBaseUrl: server.serverBaseUrl,
    buildId: server.buildId
  };
  server.resource({
    name: definition.name,
    uri: resourceUri,
    title: definition.title,
    description: definition.description,
    mimeType,
    _meta: definition._meta,
    annotations: definition.annotations,
    readCallback: /* @__PURE__ */ __name(async () => {
      const params = definition.type === "externalUrl" ? applyDefaultProps(definition.props) : {};
      const uiResource = await createWidgetUIResource(
        definition,
        params,
        serverConfig
      );
      uiResource.resource.uri = resourceUri;
      return {
        contents: [uiResource.resource]
      };
    }, "readCallback")
  });
  if (definition.type === "appsSdk") {
    const buildIdPart = server.buildId ? `-${server.buildId}` : "";
    const uriTemplate = `ui://widget/${definition.name}${buildIdPart}-{id}.html`;
    server.resourceTemplate({
      name: `${definition.name}-dynamic`,
      resourceTemplate: {
        uriTemplate,
        name: definition.title || definition.name,
        description: definition.description,
        mimeType
      },
      _meta: definition._meta,
      title: definition.title,
      description: definition.description,
      annotations: definition.annotations,
      readCallback: /* @__PURE__ */ __name(async (uri, params) => {
        const uiResource = await createWidgetUIResource(
          definition,
          {},
          serverConfig
        );
        uiResource.resource.uri = uri.toString();
        return {
          contents: [uiResource.resource]
        };
      }, "readCallback")
    });
  }
  const widgetMetadata = definition._meta?.["mcp-use/widget"];
  const exposeAsTool = definition.exposeAsTool ?? widgetMetadata?.exposeAsTool ?? true;
  if (exposeAsTool) {
    const toolMetadata = definition._meta || {};
    if (definition.type === "appsSdk" && definition.appsSdkMetadata) {
      toolMetadata["openai/outputTemplate"] = resourceUri;
      const toolMetadataFields = [
        "openai/toolInvocation/invoking",
        "openai/toolInvocation/invoked",
        "openai/widgetAccessible",
        "openai/resultCanProduceWidget"
      ];
      for (const field of toolMetadataFields) {
        if (definition.appsSdkMetadata[field] !== void 0) {
          toolMetadata[field] = definition.appsSdkMetadata[field];
        }
      }
    }
    const widgetMetadata2 = definition._meta?.["mcp-use/widget"];
    const propsOrSchema = definition.props || widgetMetadata2?.props || widgetMetadata2?.inputs || widgetMetadata2?.schema;
    const isZodSchema = propsOrSchema && typeof propsOrSchema === "object" && propsOrSchema instanceof import_zod.default.ZodObject;
    let isJsonSchema = false;
    if (propsOrSchema && typeof propsOrSchema === "object" && !isZodSchema) {
      const hasSchemaKey = Object.prototype.hasOwnProperty.call(
        propsOrSchema,
        "$schema"
      );
      const hasTypeObject = propsOrSchema.type === "object" && Object.prototype.hasOwnProperty.call(propsOrSchema, "properties");
      isJsonSchema = hasSchemaKey || hasTypeObject;
    }
    const toolDefinition = {
      name: definition.name,
      title: definition.title,
      description: definition.description,
      annotations: definition.toolAnnotations,
      _meta: Object.keys(toolMetadata).length > 0 ? toolMetadata : void 0
    };
    if (isZodSchema) {
      toolDefinition.schema = propsOrSchema;
    } else if (isJsonSchema) {
      const jsonSchema = propsOrSchema;
      if (jsonSchema.properties) {
        const requiredFields = new Set(jsonSchema.required || []);
        toolDefinition.inputs = Object.entries(jsonSchema.properties).map(
          ([name, prop]) => ({
            name,
            type: prop.type || "string",
            description: prop.description,
            required: requiredFields.has(name),
            default: prop.default
          })
        );
      }
    } else if (propsOrSchema) {
      toolDefinition.inputs = convertPropsToInputs(
        propsOrSchema
      );
    }
    server.tool(toolDefinition, async (params) => {
      const uiResource = await createWidgetUIResource(
        definition,
        params,
        serverConfig
      );
      if (definition.type === "appsSdk") {
        const randomId = Math.random().toString(36).substring(2, 15);
        const uniqueUri = generateWidgetUri(
          definition.name,
          server.buildId,
          ".html",
          randomId
        );
        const uniqueToolMetadata = {
          ...toolMetadata,
          "openai/outputTemplate": uniqueUri,
          "mcp-use/props": params
          // Pass params as widget props
        };
        let toolOutputResult;
        if (definition.toolOutput) {
          toolOutputResult = typeof definition.toolOutput === "function" ? definition.toolOutput(params) : definition.toolOutput;
        } else {
          toolOutputResult = {
            content: [
              {
                type: "text",
                text: `Displaying ${displayName}`
              }
            ]
          };
        }
        const content = toolOutputResult.content || [
          { type: "text", text: `Displaying ${displayName}` }
        ];
        return {
          _meta: uniqueToolMetadata,
          content,
          structuredContent: toolOutputResult.structuredContent
        };
      }
      return {
        content: [
          {
            type: "text",
            text: `Displaying ${displayName}`,
            description: `Show MCP-UI widget for ${displayName}`
          },
          uiResource
        ]
      };
    });
  }
  return server;
}
__name(uiResourceRegistration, "uiResourceRegistration");

// src/server/widgets/index.ts
async function mountWidgets(server, options) {
  const serverConfig = {
    serverBaseUrl: server.serverBaseUrl || `http://${server.serverHost}:${server.serverPort || 3e3}`,
    serverPort: server.serverPort || 3e3,
    cspUrls: getCSPUrls(),
    buildId: server.buildId,
    favicon: server.favicon
  };
  const registerWidget = /* @__PURE__ */ __name((widgetDef) => {
    server.uiResource(widgetDef);
  }, "registerWidget");
  const app = server.app;
  if (isProductionMode() || isDeno) {
    console.log("[WIDGETS] Mounting widgets in production mode");
    setupWidgetRoutes(app, serverConfig);
    await mountWidgetsProduction(app, serverConfig, registerWidget, options);
  } else {
    console.log("[WIDGETS] Mounting widgets in development mode");
    await mountWidgetsDev(app, serverConfig, registerWidget, options);
  }
}
__name(mountWidgets, "mountWidgets");

// src/server/inspector/mount.ts
async function mountInspectorUI(app, serverHost, serverPort, isProduction) {
  if (isProduction) {
    const manifest = await readBuildManifest();
    if (!manifest?.includeInspector) {
      console.log(
        "[INSPECTOR] Skipped in production (use --with-inspector flag during build)"
      );
      return false;
    }
  }
  try {
    const { mountInspector } = await import("@mcp-use/inspector");
    const mcpUrl = `http://${serverHost}:${serverPort}/mcp`;
    const autoConnectConfig = JSON.stringify({
      url: mcpUrl,
      name: "Local MCP Server",
      transportType: "sse",
      connectionType: "Direct"
    });
    mountInspector(app, { autoConnectUrl: autoConnectConfig });
    console.log(
      `[INSPECTOR] UI available at http://${serverHost}:${serverPort}/inspector`
    );
    return true;
  } catch {
    return false;
  }
}
__name(mountInspectorUI, "mountInspectorUI");

// src/server/tools/schema-helpers.ts
var import_zod2 = require("zod");
function convertZodSchemaToParams(zodSchema) {
  if (!(zodSchema instanceof import_zod2.z.ZodObject)) {
    throw new Error("schema must be a Zod object schema (z.object({...}))");
  }
  const shape = zodSchema.shape;
  const params = {};
  for (const [key, value] of Object.entries(shape)) {
    params[key] = value;
  }
  return params;
}
__name(convertZodSchemaToParams, "convertZodSchemaToParams");
function createParamsSchema(inputs) {
  const schema = {};
  inputs.forEach((input) => {
    let zodType;
    switch (input.type) {
      case "string":
        zodType = import_zod2.z.string();
        break;
      case "number":
        zodType = import_zod2.z.number();
        break;
      case "boolean":
        zodType = import_zod2.z.boolean();
        break;
      case "object":
        zodType = import_zod2.z.object({});
        break;
      case "array":
        zodType = import_zod2.z.array(import_zod2.z.any());
        break;
      default:
        zodType = import_zod2.z.any();
    }
    if (input.description) {
      zodType = zodType.describe(input.description);
    }
    if (!input.required) {
      zodType = zodType.optional();
    }
    schema[input.name] = zodType;
  });
  return schema;
}
__name(createParamsSchema, "createParamsSchema");

// src/server/tools/tool-registration.ts
init_context_storage();
init_tool_execution_helpers();
function toolRegistration(toolDefinition, callback) {
  const actualCallback = callback || toolDefinition.cb;
  if (!actualCallback) {
    throw new Error(
      `Tool '${toolDefinition.name}' must have either a cb property or a callback parameter`
    );
  }
  let inputSchema;
  if (toolDefinition.schema) {
    inputSchema = this.convertZodSchemaToParams(toolDefinition.schema);
  } else if (toolDefinition.inputs && toolDefinition.inputs.length > 0) {
    inputSchema = this.createParamsSchema(toolDefinition.inputs);
  } else {
    inputSchema = {};
  }
  this.server.registerTool(
    toolDefinition.name,
    {
      title: toolDefinition.title,
      description: toolDefinition.description ?? "",
      inputSchema,
      annotations: toolDefinition.annotations,
      _meta: toolDefinition._meta
    },
    async (params, extra) => {
      const initialRequestContext = getRequestContext();
      const extraProgressToken = extra?._meta?.progressToken;
      const extraSendNotification = extra?.sendNotification;
      const { requestContext, session, progressToken, sendNotification: sendNotification2 } = findSessionContext(
        this.sessions,
        initialRequestContext,
        extraProgressToken,
        extraSendNotification
      );
      const enhancedContext = createEnhancedContext(
        requestContext,
        this.createMessage.bind(this),
        this.server.server.elicitInput.bind(this.server.server),
        progressToken,
        sendNotification2,
        session?.logLevel,
        session?.clientCapabilities
      );
      const executeCallback = /* @__PURE__ */ __name(async () => {
        if (actualCallback.length >= 2) {
          return await actualCallback(params, enhancedContext);
        }
        return await actualCallback(params);
      }, "executeCallback");
      if (requestContext) {
        return await runWithContext(requestContext, executeCallback);
      }
      return await executeCallback();
    }
  );
  this.registeredTools.push(toolDefinition.name);
  return this;
}
__name(toolRegistration, "toolRegistration");

// src/server/tools/index.ts
init_tool_execution_helpers();

// src/server/resources/index.ts
var import_mcp = require("@mcp-use/modelcontextprotocol-sdk/server/mcp.js");
init_conversion();

// src/server/resources/subscriptions.ts
var import_types = require("@mcp-use/modelcontextprotocol-sdk/types.js");
init_context_storage();
var ResourceSubscriptionManager = class {
  static {
    __name(this, "ResourceSubscriptionManager");
  }
  /**
   * Tracks resource subscriptions per session
   * Map structure: uri -> Set<sessionId>
   */
  subscriptions = /* @__PURE__ */ new Map();
  /**
   * Register subscription handlers with an MCP server instance
   *
   * @param server - The native MCP server instance
   * @param sessions - Map of active sessions
   */
  registerHandlers(server, sessions) {
    server.server.setRequestHandler(
      import_types.SubscribeRequestSchema,
      async (request) => {
        const { uri } = request.params;
        const sessionId = this.getSessionIdFromContext(sessions, server);
        if (!sessionId) {
          console.warn(
            `[MCP] Could not determine session ID for resource subscription to ${uri}`
          );
          return {};
        }
        if (!this.subscriptions.has(uri)) {
          this.subscriptions.set(uri, /* @__PURE__ */ new Set());
        }
        this.subscriptions.get(uri).add(sessionId);
        console.log(
          `[MCP] Session ${sessionId} subscribed to resource: ${uri}`
        );
        return {};
      }
    );
    server.server.setRequestHandler(
      import_types.UnsubscribeRequestSchema,
      async (request) => {
        const { uri } = request.params;
        const sessionId = this.getSessionIdFromContext(sessions, server);
        if (!sessionId) {
          console.warn(
            `[MCP] Could not determine session ID for resource unsubscribe from ${uri}`
          );
          return {};
        }
        const subscribers = this.subscriptions.get(uri);
        if (subscribers) {
          subscribers.delete(sessionId);
          if (subscribers.size === 0) {
            this.subscriptions.delete(uri);
          }
          console.log(
            `[MCP] Session ${sessionId} unsubscribed from resource: ${uri}`
          );
        }
        return {};
      }
    );
  }
  /**
   * Get session ID from request context or sessions map
   *
   * @param sessions - Map of active sessions
   * @param server - The server instance to match against
   * @returns The session ID, or undefined if not found
   */
  getSessionIdFromContext(sessions, server) {
    const requestContext = getRequestContext();
    let sessionId;
    if (requestContext) {
      sessionId = requestContext.req.header("mcp-session-id");
    }
    if (!sessionId) {
      for (const [sid, session] of sessions.entries()) {
        if (session.server === server) {
          sessionId = sid;
          break;
        }
      }
    }
    return sessionId;
  }
  /**
   * Notify subscribed clients that a resource has been updated
   *
   * This method sends a `notifications/resources/updated` notification to all
   * sessions that have subscribed to the specified resource URI.
   *
   * @param uri - The URI of the resource that changed
   * @param sessions - Map of active sessions
   * @returns Promise that resolves when all notifications have been sent
   */
  async notifyResourceUpdated(uri, sessions) {
    const subscribers = this.subscriptions.get(uri);
    if (!subscribers || subscribers.size === 0) {
      return;
    }
    console.log(
      `[MCP] Notifying ${subscribers.size} subscriber(s) of resource update: ${uri}`
    );
    for (const sessionId of subscribers) {
      const session = sessions.get(sessionId);
      if (session?.server) {
        try {
          await session.server.server.sendResourceUpdated({ uri });
          console.log(
            `[MCP] Sent resource update notification to session ${sessionId}`
          );
        } catch (error2) {
          console.error(
            `[MCP] Failed to send resource update notification to session ${sessionId}:`,
            error2
          );
        }
      }
    }
  }
  /**
   * Clean up resource subscriptions for a closed session
   *
   * This method is called automatically when a session is closed to remove
   * all resource subscriptions associated with that session.
   *
   * @param sessionId - The session ID to clean up
   */
  cleanupSession(sessionId) {
    for (const [uri, subscribers] of this.subscriptions) {
      subscribers.delete(sessionId);
      if (subscribers.size === 0) {
        this.subscriptions.delete(uri);
      }
    }
    console.log(
      `[MCP] Cleaned up resource subscriptions for session ${sessionId}`
    );
  }
};

// src/server/resources/index.ts
function registerResource(resourceDefinition, callback) {
  const actualCallback = callback || resourceDefinition.readCallback;
  if (!actualCallback) {
    throw new Error(
      `Resource '${resourceDefinition.name}' must have either a readCallback property or a callback parameter`
    );
  }
  const explicitMimeType = resourceDefinition.mimeType;
  const wrappedCallback = /* @__PURE__ */ __name(async () => {
    const { getRequestContext: getRequestContext2, runWithContext: runWithContext2 } = await Promise.resolve().then(() => (init_context_storage(), context_storage_exports));
    const { findSessionContext: findSessionContext2 } = await Promise.resolve().then(() => (init_tool_execution_helpers(), tool_execution_helpers_exports));
    const initialRequestContext = getRequestContext2();
    const sessions = this.sessions || /* @__PURE__ */ new Map();
    const { requestContext } = findSessionContext2(
      sessions,
      initialRequestContext,
      void 0,
      void 0
    );
    const enhancedContext = requestContext || {};
    const executeCallback = /* @__PURE__ */ __name(async () => {
      if (actualCallback.length >= 1) {
        return await actualCallback(enhancedContext);
      }
      return await actualCallback();
    }, "executeCallback");
    const result = requestContext ? await runWithContext2(requestContext, executeCallback) : await executeCallback();
    if ("contents" in result && Array.isArray(result.contents)) {
      return result;
    }
    return convertToolResultToResourceResult(
      resourceDefinition.uri,
      result
    );
  }, "wrappedCallback");
  const registrationMimeType = explicitMimeType || "text/plain";
  this.server.registerResource(
    resourceDefinition.name,
    resourceDefinition.uri,
    {
      title: resourceDefinition.title,
      description: resourceDefinition.description,
      mimeType: registrationMimeType,
      _meta: resourceDefinition._meta
    },
    wrappedCallback
  );
  this.registeredResources.push(resourceDefinition.name);
  return this;
}
__name(registerResource, "registerResource");
function registerResourceTemplate(resourceTemplateDefinition, callback) {
  const actualCallback = callback || resourceTemplateDefinition.readCallback;
  if (!actualCallback) {
    throw new Error(
      `Resource template '${resourceTemplateDefinition.name}' must have either a readCallback property or a callback parameter`
    );
  }
  const isFlatStructure = "uriTemplate" in resourceTemplateDefinition;
  const uriTemplate = isFlatStructure ? resourceTemplateDefinition.uriTemplate : resourceTemplateDefinition.resourceTemplate.uriTemplate;
  const mimeType = isFlatStructure ? resourceTemplateDefinition.mimeType : resourceTemplateDefinition.resourceTemplate.mimeType;
  const templateDescription = isFlatStructure ? void 0 : resourceTemplateDefinition.resourceTemplate.description;
  const template = new import_mcp.ResourceTemplate(uriTemplate, {
    list: void 0,
    // Optional: callback to list all matching resources
    complete: void 0
    // Optional: callback for auto-completion
  });
  const metadata = {};
  if (resourceTemplateDefinition.title) {
    metadata.title = resourceTemplateDefinition.title;
  }
  if (resourceTemplateDefinition.description || templateDescription) {
    metadata.description = resourceTemplateDefinition.description || templateDescription;
  }
  if (mimeType) {
    metadata.mimeType = mimeType;
  }
  if (resourceTemplateDefinition.annotations) {
    metadata.annotations = resourceTemplateDefinition.annotations;
  }
  this.server.registerResource(
    resourceTemplateDefinition.name,
    template,
    metadata,
    async (uri) => {
      const params = this.parseTemplateUri(uriTemplate, uri.toString());
      const { getRequestContext: getRequestContext2, runWithContext: runWithContext2 } = await Promise.resolve().then(() => (init_context_storage(), context_storage_exports));
      const { findSessionContext: findSessionContext2 } = await Promise.resolve().then(() => (init_tool_execution_helpers(), tool_execution_helpers_exports));
      const initialRequestContext = getRequestContext2();
      const sessions = this.sessions || /* @__PURE__ */ new Map();
      const { requestContext } = findSessionContext2(
        sessions,
        initialRequestContext,
        void 0,
        void 0
      );
      const enhancedContext = requestContext || {};
      const executeCallback = /* @__PURE__ */ __name(async () => {
        if (actualCallback.length >= 3) {
          return await actualCallback(uri, params, enhancedContext);
        } else if (actualCallback.length === 2) {
          return await actualCallback(uri, params);
        } else if (actualCallback.length === 1) {
          return await actualCallback(uri);
        }
        return await actualCallback();
      }, "executeCallback");
      const result = requestContext ? await runWithContext2(requestContext, executeCallback) : await executeCallback();
      if ("contents" in result && Array.isArray(result.contents)) {
        return result;
      }
      return convertToolResultToResourceResult(
        uri.toString(),
        result
      );
    }
  );
  this.registeredResources.push(resourceTemplateDefinition.name);
  return this;
}
__name(registerResourceTemplate, "registerResourceTemplate");

// src/server/prompts/index.ts
init_conversion2();
function registerPrompt(promptDefinition, callback) {
  const actualCallback = callback || promptDefinition.cb;
  if (!actualCallback) {
    throw new Error(
      `Prompt '${promptDefinition.name}' must have either a cb property or a callback parameter`
    );
  }
  let argsSchema;
  if (promptDefinition.schema) {
    argsSchema = this.convertZodSchemaToParams(
      promptDefinition.schema
    );
  } else if (promptDefinition.args && promptDefinition.args.length > 0) {
    argsSchema = this.createParamsSchema(promptDefinition.args);
  } else {
    argsSchema = void 0;
  }
  const wrappedCallback = /* @__PURE__ */ __name(async (params, extra) => {
    const { getRequestContext: getRequestContext2, runWithContext: runWithContext2 } = await Promise.resolve().then(() => (init_context_storage(), context_storage_exports));
    const { findSessionContext: findSessionContext2 } = await Promise.resolve().then(() => (init_tool_execution_helpers(), tool_execution_helpers_exports));
    const initialRequestContext = getRequestContext2();
    const sessions = this.sessions || /* @__PURE__ */ new Map();
    const { requestContext } = findSessionContext2(
      sessions,
      initialRequestContext,
      void 0,
      void 0
    );
    const enhancedContext = requestContext || {};
    const executeCallback = /* @__PURE__ */ __name(async () => {
      if (actualCallback.length >= 2) {
        return await actualCallback(params, enhancedContext);
      }
      return await actualCallback(params);
    }, "executeCallback");
    const result = requestContext ? await runWithContext2(requestContext, executeCallback) : await executeCallback();
    if ("messages" in result && Array.isArray(result.messages)) {
      return result;
    }
    return convertToolResultToPromptResult(result);
  }, "wrappedCallback");
  this.server.registerPrompt(
    promptDefinition.name,
    {
      title: promptDefinition.title,
      description: promptDefinition.description ?? "",
      argsSchema
      // Type assertion for Zod v4 compatibility
    },
    wrappedCallback
  );
  this.registeredPrompts.push(promptDefinition.name);
  return this;
}
__name(registerPrompt, "registerPrompt");

// src/server/roots/roots-registration.ts
init_runtime();
init_jsonrpc_helpers();
function onRootsChanged(callback) {
  this.onRootsChangedCallback = callback;
  return this;
}
__name(onRootsChanged, "onRootsChanged");
async function listRoots(sessionId) {
  const session = this.sessions.get(sessionId);
  if (!session) {
    return null;
  }
  try {
    const request = createRequest(generateUUID(), "roots/list", {});
    const response = await session.transport.send(request);
    if (response && typeof response === "object" && "roots" in response) {
      return response.roots;
    }
    return [];
  } catch (error2) {
    console.warn(
      `[MCP] Failed to list roots from session ${sessionId}:`,
      error2
    );
    return null;
  }
}
__name(listRoots, "listRoots");

// src/server/logging.ts
init_runtime();
function isDebugMode() {
  const debugEnv = getEnv("DEBUG");
  return debugEnv !== void 0 && debugEnv !== "" && debugEnv !== "0" && debugEnv.toLowerCase() !== "false";
}
__name(isDebugMode, "isDebugMode");
function formatForLogging(obj) {
  function truncate(val) {
    if (typeof val === "string" && val.length > 100) {
      return val.slice(0, 100) + "...";
    } else if (Array.isArray(val)) {
      return val.map(truncate);
    } else if (val && typeof val === "object") {
      const result = {};
      for (const key in val) {
        if (Object.prototype.hasOwnProperty.call(val, key)) {
          result[key] = truncate(val[key]);
        }
      }
      return result;
    }
    return val;
  }
  __name(truncate, "truncate");
  try {
    return JSON.stringify(truncate(obj), null, 2);
  } catch {
    return String(obj);
  }
}
__name(formatForLogging, "formatForLogging");
async function requestLogger(c, next) {
  const timestamp = (/* @__PURE__ */ new Date()).toISOString().substring(11, 23);
  const method = c.req.method;
  const url = c.req.url;
  const debugMode = isDebugMode();
  let requestBody = null;
  let requestHeaders = {};
  if (debugMode) {
    const allHeaders = c.req.header();
    if (allHeaders) {
      requestHeaders = allHeaders;
    }
  }
  if (method !== "GET" && method !== "HEAD") {
    try {
      const clonedRequest = c.req.raw.clone();
      requestBody = await clonedRequest.json().catch(() => {
        return clonedRequest.text().catch(() => null);
      });
    } catch {
    }
  }
  await next();
  const statusCode = c.res.status;
  let statusColor = "";
  if (statusCode >= 200 && statusCode < 300) {
    statusColor = "\x1B[32m";
  } else if (statusCode >= 300 && statusCode < 400) {
    statusColor = "\x1B[33m";
  } else if (statusCode >= 400 && statusCode < 500) {
    statusColor = "\x1B[31m";
  } else if (statusCode >= 500) {
    statusColor = "\x1B[35m";
  }
  let logMessage = `[${timestamp}] ${method} \x1B[1m${new URL(url).pathname}\x1B[0m`;
  if (method === "POST" && url.includes("/mcp") && requestBody?.method) {
    logMessage += ` \x1B[1m[${requestBody.method}]\x1B[0m`;
  }
  logMessage += ` ${statusColor}${statusCode}\x1B[0m`;
  console.log(logMessage);
  if (debugMode) {
    console.log("\n\x1B[36m" + "=".repeat(80) + "\x1B[0m");
    console.log("\x1B[1m\x1B[36m[DEBUG] Request Details\x1B[0m");
    console.log("\x1B[36m" + "-".repeat(80) + "\x1B[0m");
    if (Object.keys(requestHeaders).length > 0) {
      console.log("\x1B[33mRequest Headers:\x1B[0m");
      console.log(formatForLogging(requestHeaders));
    }
    if (requestBody !== null) {
      console.log("\x1B[33mRequest Body:\x1B[0m");
      if (typeof requestBody === "string") {
        console.log(requestBody);
      } else {
        console.log(formatForLogging(requestBody));
      }
    }
    const responseHeaders = {};
    c.res.headers.forEach((value, key) => {
      responseHeaders[key] = value;
    });
    if (Object.keys(responseHeaders).length > 0) {
      console.log("\x1B[33mResponse Headers:\x1B[0m");
      console.log(formatForLogging(responseHeaders));
    }
    try {
      if (c.res.body !== null && c.res.body !== void 0) {
        try {
          const clonedResponse = c.res.clone();
          const responseBody = await clonedResponse.text().catch(() => null);
          if (responseBody !== null && responseBody.length > 0) {
            console.log("\x1B[33mResponse Body:\x1B[0m");
            try {
              const jsonBody = JSON.parse(responseBody);
              console.log(formatForLogging(jsonBody));
            } catch {
              const maxLength = 1e4;
              if (responseBody.length > maxLength) {
                console.log(
                  responseBody.substring(0, maxLength) + `
... (truncated, ${responseBody.length - maxLength} more characters)`
                );
              } else {
                console.log(responseBody);
              }
            }
          } else {
            console.log("\x1B[33mResponse Body:\x1B[0m (empty)");
          }
        } catch (cloneError) {
          console.log("\x1B[33mResponse Body:\x1B[0m (unable to clone/read)");
        }
      } else {
        console.log("\x1B[33mResponse Body:\x1B[0m (no body)");
      }
    } catch (error2) {
      console.log("\x1B[33mResponse Body:\x1B[0m (unable to read)");
    }
    console.log("\x1B[36m" + "=".repeat(80) + "\x1B[0m\n");
  }
}
__name(requestLogger, "requestLogger");

// src/server/notifications/notification-registration.ts
init_notifications();
function getActiveSessions() {
  return Array.from(this.sessions.keys());
}
__name(getActiveSessions, "getActiveSessions");
async function sendNotification(method, params) {
  await sendNotificationToAll(this.sessions, method, params);
}
__name(sendNotification, "sendNotification");
async function sendNotificationToSession2(sessionId, method, params) {
  return await sendNotificationToSession(
    this.sessions,
    sessionId,
    method,
    params
  );
}
__name(sendNotificationToSession2, "sendNotificationToSession");
async function sendToolsListChanged() {
  await sendNotificationToAll(
    this.sessions,
    "notifications/tools/list_changed"
  );
}
__name(sendToolsListChanged, "sendToolsListChanged");
async function sendResourcesListChanged() {
  await sendNotificationToAll(
    this.sessions,
    "notifications/resources/list_changed"
  );
}
__name(sendResourcesListChanged, "sendResourcesListChanged");
async function sendPromptsListChanged() {
  await sendNotificationToAll(
    this.sessions,
    "notifications/prompts/list_changed"
  );
}
__name(sendPromptsListChanged, "sendPromptsListChanged");

// src/server/mcp-server.ts
init_tool_execution_helpers();
init_context_storage();

// src/server/sessions/session-manager.ts
function startIdleCleanup(sessions, idleTimeoutMs, transports, mcpServerInstance) {
  if (idleTimeoutMs <= 0) {
    return void 0;
  }
  return setInterval(() => {
    const now = Date.now();
    const expiredSessions = [];
    for (const [sessionId, session] of sessions.entries()) {
      if (now - session.lastAccessedAt > idleTimeoutMs) {
        expiredSessions.push(sessionId);
      }
    }
    if (expiredSessions.length > 0) {
      console.log(
        `[MCP] Cleaning up ${expiredSessions.length} idle session(s)`
      );
      for (const sessionId of expiredSessions) {
        const transport = transports?.get(sessionId);
        if (transport?.close) {
          Promise.resolve(transport.close()).catch((e) => {
            console.warn(
              `[MCP] Error closing transport for session ${sessionId}:`,
              e
            );
          });
        }
        transports?.delete(sessionId);
        sessions.delete(sessionId);
        mcpServerInstance?.cleanupSessionSubscriptions?.(sessionId);
        console.log(
          `[MCP] Cleaned up resource subscriptions for session ${sessionId}`
        );
      }
    }
  }, 6e4);
}
__name(startIdleCleanup, "startIdleCleanup");

// src/server/sessions/index.ts
init_notifications();

// src/server/sessions/stores/memory.ts
var InMemorySessionStore = class {
  static {
    __name(this, "InMemorySessionStore");
  }
  /**
   * Internal map storing session metadata
   * Key: sessionId, Value: SessionMetadata
   */
  sessions = /* @__PURE__ */ new Map();
  /**
   * Retrieve session metadata by ID
   */
  async get(sessionId) {
    const data = this.sessions.get(sessionId);
    return data ?? null;
  }
  /**
   * Store or update session metadata
   */
  async set(sessionId, data) {
    this.sessions.set(sessionId, data);
  }
  /**
   * Delete session metadata
   */
  async delete(sessionId) {
    this.sessions.delete(sessionId);
  }
  /**
   * Check if session exists
   */
  async has(sessionId) {
    return this.sessions.has(sessionId);
  }
  /**
   * List all session IDs
   */
  async keys() {
    return Array.from(this.sessions.keys());
  }
  /**
   * Store session metadata with TTL (time-to-live)
   *
   * Note: In-memory implementation uses setTimeout for TTL.
   * For production TTL support, use Redis or another store with native TTL.
   */
  async setWithTTL(sessionId, data, ttlMs) {
    this.sessions.set(sessionId, data);
    setTimeout(() => {
      this.sessions.delete(sessionId);
      console.log(`[MCP] Session ${sessionId} expired after ${ttlMs}ms`);
    }, ttlMs);
  }
  /**
   * Get the number of active sessions
   * Useful for monitoring and debugging
   */
  get size() {
    return this.sessions.size;
  }
  /**
   * Clear all sessions
   * Useful for testing and manual cleanup
   */
  async clear() {
    this.sessions.clear();
  }
};

// src/server/sessions/stores/redis.ts
var RedisSessionStore = class {
  static {
    __name(this, "RedisSessionStore");
  }
  client;
  prefix;
  defaultTTL;
  constructor(config) {
    this.client = config.client;
    this.prefix = config.prefix ?? "mcp:session:";
    this.defaultTTL = config.defaultTTL ?? 3600;
  }
  /**
   * Get full Redis key for a session ID
   */
  getKey(sessionId) {
    return `${this.prefix}${sessionId}`;
  }
  /**
   * Retrieve session metadata by ID
   */
  async get(sessionId) {
    try {
      const key = this.getKey(sessionId);
      const data = await this.client.get(key);
      if (!data) {
        return null;
      }
      return JSON.parse(data);
    } catch (error2) {
      console.error(
        `[RedisSessionStore] Error getting session ${sessionId}:`,
        error2
      );
      return null;
    }
  }
  /**
   * Store or update session metadata
   */
  async set(sessionId, data) {
    try {
      const key = this.getKey(sessionId);
      const value = JSON.stringify(data);
      if (this.client.setEx) {
        await this.client.setEx(key, this.defaultTTL, value);
      } else if (this.client.setex) {
        await this.client.setex(key, this.defaultTTL, value);
      } else {
        await this.client.set(key, value, { EX: this.defaultTTL });
      }
    } catch (error2) {
      console.error(
        `[RedisSessionStore] Error setting session ${sessionId}:`,
        error2
      );
      throw error2;
    }
  }
  /**
   * Delete a session
   */
  async delete(sessionId) {
    try {
      const key = this.getKey(sessionId);
      await this.client.del(key);
    } catch (error2) {
      console.error(
        `[RedisSessionStore] Error deleting session ${sessionId}:`,
        error2
      );
      throw error2;
    }
  }
  /**
   * Check if a session exists
   */
  async has(sessionId) {
    try {
      const key = this.getKey(sessionId);
      const exists = await this.client.exists(key);
      return exists === 1;
    } catch (error2) {
      console.error(
        `[RedisSessionStore] Error checking session ${sessionId}:`,
        error2
      );
      return false;
    }
  }
  /**
   * List all session IDs
   *
   * WARNING: Uses KEYS command which blocks Redis. For production systems with
   * many sessions, consider using SCAN instead or maintaining a separate SET of
   * active session IDs.
   */
  async keys() {
    try {
      const pattern = `${this.prefix}*`;
      const keys = await this.client.keys(pattern);
      return keys.map((key) => key.substring(this.prefix.length));
    } catch (error2) {
      console.error("[RedisSessionStore] Error listing session keys:", error2);
      return [];
    }
  }
  /**
   * Store session metadata with custom TTL (time-to-live)
   */
  async setWithTTL(sessionId, data, ttlMs) {
    try {
      const key = this.getKey(sessionId);
      const value = JSON.stringify(data);
      const ttlSeconds = Math.ceil(ttlMs / 1e3);
      if (this.client.setEx) {
        await this.client.setEx(key, ttlSeconds, value);
      } else if (this.client.setex) {
        await this.client.setex(key, ttlSeconds, value);
      } else {
        await this.client.set(key, value, { EX: ttlSeconds });
      }
    } catch (error2) {
      console.error(
        `[RedisSessionStore] Error setting session ${sessionId} with TTL:`,
        error2
      );
      throw error2;
    }
  }
  /**
   * Close Redis connection
   * Should be called when shutting down the server
   */
  async close() {
    try {
      await this.client.quit();
    } catch (error2) {
      console.error(
        "[RedisSessionStore] Error closing Redis connection:",
        error2
      );
      throw error2;
    }
  }
  /**
   * Clear all sessions (useful for testing)
   * WARNING: This will delete all sessions with the configured prefix
   *
   * NOTE: Uses KEYS command which blocks Redis. This is acceptable for testing
   * but should be avoided in production with large datasets.
   */
  async clear() {
    try {
      const pattern = `${this.prefix}*`;
      const keys = await this.client.keys(pattern);
      if (keys.length > 0) {
        await this.client.del(keys);
      }
    } catch (error2) {
      console.error("[RedisSessionStore] Error clearing sessions:", error2);
      throw error2;
    }
  }
};

// src/server/sessions/stores/filesystem.ts
var import_promises = require("fs/promises");
var import_node_path = require("path");
var import_node_fs = require("fs");
var FileSystemSessionStore = class {
  static {
    __name(this, "FileSystemSessionStore");
  }
  sessions = /* @__PURE__ */ new Map();
  filePath;
  debounceMs;
  maxAgeMs;
  saveTimer = null;
  saving = false;
  pendingSave = false;
  constructor(config = {}) {
    this.filePath = config.path ?? (0, import_node_path.join)(process.cwd(), ".mcp-use", "sessions.json");
    this.debounceMs = config.debounceMs ?? 100;
    this.maxAgeMs = config.maxAgeMs ?? 24 * 60 * 60 * 1e3;
    this.loadSessionsSync();
  }
  /**
   * Load sessions from file synchronously during construction
   * This ensures sessions are available immediately when the server starts
   */
  loadSessionsSync() {
    try {
      if (!(0, import_node_fs.existsSync)(this.filePath)) {
        console.log(
          `[FileSystemSessionStore] No session file found at ${this.filePath}, starting fresh`
        );
        return;
      }
      const data = (0, import_node_fs.readFileSync)(this.filePath, "utf-8");
      const parsed = JSON.parse(data);
      const now = Date.now();
      let loadedCount = 0;
      let expiredCount = 0;
      for (const [sessionId, metadata] of Object.entries(parsed)) {
        const sessionMetadata = metadata;
        const age = now - sessionMetadata.lastAccessedAt;
        if (age > this.maxAgeMs) {
          expiredCount++;
          continue;
        }
        this.sessions.set(sessionId, sessionMetadata);
        loadedCount++;
      }
      console.log(
        `[FileSystemSessionStore] Loaded ${loadedCount} session(s) from ${this.filePath}` + (expiredCount > 0 ? ` (cleaned up ${expiredCount} expired)` : "")
      );
    } catch (error2) {
      if (error2.code === "ENOENT") {
        console.log(`[FileSystemSessionStore] No existing sessions file`);
      } else if (error2 instanceof SyntaxError) {
        console.warn(
          `[FileSystemSessionStore] Corrupted session file, starting fresh:`,
          error2.message
        );
      } else {
        console.warn(
          `[FileSystemSessionStore] Error loading sessions, starting fresh:`,
          error2.message
        );
      }
    }
  }
  /**
   * Retrieve session metadata by ID
   */
  async get(sessionId) {
    const data = this.sessions.get(sessionId);
    return data ?? null;
  }
  /**
   * Store or update session metadata
   * Uses debouncing to batch rapid consecutive writes
   */
  async set(sessionId, data) {
    this.sessions.set(sessionId, data);
    await this.scheduleSave();
  }
  /**
   * Delete session metadata
   */
  async delete(sessionId) {
    this.sessions.delete(sessionId);
    await this.scheduleSave();
  }
  /**
   * Check if session exists
   */
  async has(sessionId) {
    return this.sessions.has(sessionId);
  }
  /**
   * List all session IDs
   */
  async keys() {
    return Array.from(this.sessions.keys());
  }
  /**
   * Store session metadata with TTL
   * Note: TTL is enforced on load, not with timers (simple implementation)
   */
  async setWithTTL(sessionId, data, ttlMs) {
    const metadataWithExpiry = {
      ...data,
      lastAccessedAt: Date.now()
    };
    this.sessions.set(sessionId, metadataWithExpiry);
    await this.scheduleSave();
    setTimeout(() => {
      this.sessions.delete(sessionId);
      this.scheduleSave();
    }, ttlMs);
  }
  /**
   * Get the number of active sessions
   */
  get size() {
    return this.sessions.size;
  }
  /**
   * Clear all sessions
   */
  async clear() {
    this.sessions.clear();
    await this.scheduleSave();
  }
  /**
   * Schedule a save operation with debouncing
   * Prevents excessive disk I/O from rapid consecutive writes
   */
  async scheduleSave() {
    if (this.saving) {
      this.pendingSave = true;
      return;
    }
    if (this.saveTimer) {
      clearTimeout(this.saveTimer);
    }
    this.saveTimer = setTimeout(() => {
      this.performSave();
    }, this.debounceMs);
  }
  /**
   * Perform the actual save operation with atomic writes
   * Uses write-to-temp-then-rename pattern to prevent corruption
   */
  async performSave() {
    this.saveTimer = null;
    this.saving = true;
    this.pendingSave = false;
    try {
      const dir = (0, import_node_path.dirname)(this.filePath);
      await (0, import_promises.mkdir)(dir, { recursive: true });
      const data = {};
      for (const [sessionId, metadata] of Array.from(this.sessions.entries())) {
        data[sessionId] = metadata;
      }
      const tempPath = `${this.filePath}.tmp`;
      await (0, import_promises.writeFile)(tempPath, JSON.stringify(data, null, 2), "utf-8");
      await (0, import_promises.rename)(tempPath, this.filePath);
      console.debug(
        `[FileSystemSessionStore] Saved ${this.sessions.size} session(s) to ${this.filePath}`
      );
    } catch (error2) {
      console.error(
        `[FileSystemSessionStore] Error saving sessions:`,
        error2.message
      );
      try {
        const tempPath = `${this.filePath}.tmp`;
        if ((0, import_node_fs.existsSync)(tempPath)) {
          await (0, import_promises.unlink)(tempPath);
        }
      } catch {
      }
    } finally {
      this.saving = false;
      if (this.pendingSave) {
        await this.scheduleSave();
      }
    }
  }
  /**
   * Force an immediate save (bypasses debouncing)
   * Useful for ensuring persistence before process exit
   */
  async flush() {
    if (this.saveTimer) {
      clearTimeout(this.saveTimer);
      this.saveTimer = null;
    }
    await this.performSave();
  }
};

// src/server/sessions/streams/memory.ts
var InMemoryStreamManager = class {
  static {
    __name(this, "InMemoryStreamManager");
  }
  /**
   * Map of active SSE stream controllers
   * Key: sessionId, Value: ReadableStreamDefaultController
   */
  streams = /* @__PURE__ */ new Map();
  /**
   * Text encoder for converting strings to Uint8Array
   */
  textEncoder = new TextEncoder();
  /**
   * Register an active SSE stream controller
   */
  async create(sessionId, controller) {
    this.streams.set(sessionId, controller);
  }
  /**
   * Send data to active SSE streams
   *
   * Directly enqueues data to in-memory controllers.
   * For distributed deployments, use RedisStreamManager instead.
   */
  async send(sessionIds, data) {
    const encoded = this.textEncoder.encode(data);
    if (!sessionIds) {
      for (const [_id, controller] of this.streams.entries()) {
        try {
          controller.enqueue(encoded);
        } catch (error2) {
          console.warn(
            `[InMemoryStreamManager] Failed to send to session ${_id}:`,
            error2
          );
        }
      }
    } else {
      for (const sessionId of sessionIds) {
        const controller = this.streams.get(sessionId);
        if (controller) {
          try {
            controller.enqueue(encoded);
          } catch (error2) {
            console.warn(
              `[InMemoryStreamManager] Failed to send to session ${sessionId}:`,
              error2
            );
          }
        }
      }
    }
  }
  /**
   * Remove an active SSE stream
   */
  async delete(sessionId) {
    const controller = this.streams.get(sessionId);
    if (controller) {
      try {
        controller.close();
      } catch (error2) {
        console.debug(
          `[InMemoryStreamManager] Controller already closed for session ${sessionId}`
        );
      }
      this.streams.delete(sessionId);
    }
  }
  /**
   * Check if an active stream exists
   */
  async has(sessionId) {
    return this.streams.has(sessionId);
  }
  /**
   * Close all active streams
   */
  async close() {
    for (const [sessionId, controller] of this.streams.entries()) {
      try {
        controller.close();
      } catch (error2) {
        console.debug(
          `[InMemoryStreamManager] Error closing stream for ${sessionId}:`,
          error2
        );
      }
    }
    this.streams.clear();
  }
  /**
   * Get the number of active streams
   * Useful for monitoring
   */
  get size() {
    return this.streams.size;
  }
};

// src/server/sessions/streams/redis.ts
var RedisStreamManager = class {
  static {
    __name(this, "RedisStreamManager");
  }
  pubSubClient;
  client;
  prefix;
  heartbeatInterval;
  textEncoder = new TextEncoder();
  /**
   * Map of local controllers (only on this server instance)
   * Key: sessionId, Value: controller
   */
  localControllers = /* @__PURE__ */ new Map();
  /**
   * Map of heartbeat intervals for keeping sessions alive
   * Key: sessionId, Value: interval timer
   */
  heartbeats = /* @__PURE__ */ new Map();
  constructor(config) {
    this.pubSubClient = config.pubSubClient;
    this.client = config.client;
    this.prefix = config.prefix ?? "mcp:stream:";
    this.heartbeatInterval = config.heartbeatInterval ?? 10;
  }
  /**
   * Get the Redis channel name for a session
   */
  getChannel(sessionId) {
    return `${this.prefix}${sessionId}`;
  }
  /**
   * Get the Redis key for tracking active sessions
   */
  getAvailableKey(sessionId) {
    return `available:${this.prefix}${sessionId}`;
  }
  /**
   * Get the Redis key for the active sessions SET
   */
  getActiveSessionsKey() {
    return `${this.prefix}active`;
  }
  /**
   * Register an active SSE stream and subscribe to Redis channel
   */
  async create(sessionId, controller) {
    try {
      this.localControllers.set(sessionId, controller);
      const availableKey = this.getAvailableKey(sessionId);
      await this.client.set(availableKey, "active");
      if (this.client.expire) {
        await this.client.expire(availableKey, this.heartbeatInterval * 2);
      }
      const activeSessionsKey = this.getActiveSessionsKey();
      if (this.client.sAdd) {
        await this.client.sAdd(activeSessionsKey, sessionId);
        if (this.client.expire) {
          await this.client.expire(
            activeSessionsKey,
            this.heartbeatInterval * 2
          );
        }
      }
      const heartbeat = setInterval(async () => {
        try {
          if (this.client.expire) {
            await this.client.expire(availableKey, this.heartbeatInterval * 2);
            const activeSessionsKey2 = this.getActiveSessionsKey();
            await this.client.expire(
              activeSessionsKey2,
              this.heartbeatInterval * 2
            );
          }
        } catch (error2) {
          console.warn(
            `[RedisStreamManager] Heartbeat failed for session ${sessionId}:`,
            error2
          );
        }
      }, this.heartbeatInterval * 1e3);
      this.heartbeats.set(sessionId, heartbeat);
      const channel = this.getChannel(sessionId);
      if (!this.pubSubClient.subscribe) {
        throw new Error(
          "[RedisStreamManager] Redis client does not support subscribe method"
        );
      }
      await this.pubSubClient.subscribe(channel, (message) => {
        const localController = this.localControllers.get(sessionId);
        if (localController) {
          try {
            localController.enqueue(this.textEncoder.encode(message));
          } catch (error2) {
            console.warn(
              `[RedisStreamManager] Failed to enqueue message for ${sessionId}:`,
              error2
            );
          }
        }
      });
      const deleteChannel = `delete:${this.getChannel(sessionId)}`;
      await this.pubSubClient.subscribe(deleteChannel, async () => {
        await this.delete(sessionId);
      });
      console.log(
        `[RedisStreamManager] Created stream for session ${sessionId}`
      );
    } catch (error2) {
      console.error(
        `[RedisStreamManager] Error creating stream for ${sessionId}:`,
        error2
      );
      throw error2;
    }
  }
  /**
   * Send data to sessions via Redis Pub/Sub
   *
   * This works across distributed servers - any server with an active
   * SSE connection for the target session will receive and forward the message.
   *
   * Note: Uses the regular client (not pubSubClient) for publishing.
   * In node-redis v5+, clients in subscriber mode cannot publish.
   */
  async send(sessionIds, data) {
    try {
      if (!sessionIds) {
        const activeSessionsKey = this.getActiveSessionsKey();
        if (this.client.sMembers) {
          const sessionIds2 = await this.client.sMembers(activeSessionsKey);
          for (const sessionId of sessionIds2) {
            const channel = this.getChannel(sessionId);
            if (!this.client.publish) {
              throw new Error(
                "[RedisStreamManager] Redis client does not support publish method"
              );
            }
            await this.client.publish(channel, data);
          }
        } else {
          const pattern = `available:${this.prefix}*`;
          const keys = await this.client.keys(pattern);
          for (const key of keys) {
            const sessionId = key.replace(`available:${this.prefix}`, "");
            const channel = this.getChannel(sessionId);
            if (!this.client.publish) {
              throw new Error(
                "[RedisStreamManager] Redis client does not support publish method"
              );
            }
            await this.client.publish(channel, data);
          }
        }
      } else {
        for (const sessionId of sessionIds) {
          const channel = this.getChannel(sessionId);
          if (!this.client.publish) {
            throw new Error(
              "[RedisStreamManager] Redis client does not support publish method"
            );
          }
          await this.client.publish(channel, data);
        }
      }
    } catch (error2) {
      console.error(`[RedisStreamManager] Error sending to sessions:`, error2);
      throw error2;
    }
  }
  /**
   * Remove an active SSE stream
   */
  async delete(sessionId) {
    try {
      const heartbeat = this.heartbeats.get(sessionId);
      if (heartbeat) {
        clearInterval(heartbeat);
        this.heartbeats.delete(sessionId);
      }
      const channel = this.getChannel(sessionId);
      const deleteChannel = `delete:${channel}`;
      if (!this.pubSubClient.unsubscribe) {
        throw new Error(
          "[RedisStreamManager] Redis client does not support unsubscribe method"
        );
      }
      await this.pubSubClient.unsubscribe(channel);
      await this.pubSubClient.unsubscribe(deleteChannel);
      if (!this.client.publish) {
        throw new Error(
          "[RedisStreamManager] Redis client does not support publish method"
        );
      }
      await this.client.publish(deleteChannel, "");
      await this.client.del(this.getAvailableKey(sessionId));
      const activeSessionsKey = this.getActiveSessionsKey();
      if (this.client.sRem) {
        await this.client.sRem(activeSessionsKey, sessionId);
      }
      const controller = this.localControllers.get(sessionId);
      if (controller) {
        try {
          controller.close();
        } catch (error2) {
          console.debug(
            `[RedisStreamManager] Controller already closed for ${sessionId}`
          );
        }
        this.localControllers.delete(sessionId);
      }
      console.log(
        `[RedisStreamManager] Deleted stream for session ${sessionId}`
      );
    } catch (error2) {
      console.error(
        `[RedisStreamManager] Error deleting stream for ${sessionId}:`,
        error2
      );
      throw error2;
    }
  }
  /**
   * Check if a session has an active stream (on ANY server)
   */
  async has(sessionId) {
    try {
      const availableKey = this.getAvailableKey(sessionId);
      const exists = await this.client.exists(availableKey);
      return exists === 1;
    } catch (error2) {
      console.error(
        `[RedisStreamManager] Error checking session ${sessionId}:`,
        error2
      );
      return false;
    }
  }
  /**
   * Close all connections and cleanup
   */
  async close() {
    try {
      for (const heartbeat of this.heartbeats.values()) {
        clearInterval(heartbeat);
      }
      this.heartbeats.clear();
      const activeSessionsKey = this.getActiveSessionsKey();
      const sessionIdsToCleanup = Array.from(this.localControllers.keys());
      for (const sessionId of sessionIdsToCleanup) {
        await this.client.del(this.getAvailableKey(sessionId));
        if (this.client.sRem) {
          await this.client.sRem(activeSessionsKey, sessionId);
        }
      }
      for (const controller of this.localControllers.values()) {
        try {
          controller.close();
        } catch (error2) {
        }
      }
      this.localControllers.clear();
      console.log(`[RedisStreamManager] Closed all streams`);
    } catch (error2) {
      console.error(`[RedisStreamManager] Error during close:`, error2);
      throw error2;
    }
  }
  /**
   * Get count of active local streams on this server instance
   */
  get localSize() {
    return this.localControllers.size;
  }
};

// src/server/endpoints/mount-mcp.ts
init_runtime();
init_telemetry2();
var import_node_path2 = require("path");
async function mountMcp(app, mcpServerInstance, sessions, config, isProductionMode2) {
  const { FetchStreamableHTTPServerTransport } = await import("@mcp-use/modelcontextprotocol-sdk/experimental/fetch-streamable-http/index.js");
  const idleTimeoutMs = config.sessionIdleTimeoutMs ?? 3e5;
  const sessionStore = config.sessionStore ?? (isProductionMode2 ? new InMemorySessionStore() : new FileSystemSessionStore({
    path: (0, import_node_path2.join)(process.cwd(), ".mcp-use", "sessions.json")
  }));
  const streamManager = config.streamManager ?? new InMemoryStreamManager();
  const transports = /* @__PURE__ */ new Map();
  if (config.autoCreateSessionOnInvalidId !== void 0) {
    console.warn(
      "[MCP] WARNING: 'autoCreateSessionOnInvalidId' is deprecated and will be removed in a future version.\nThe MCP specification requires clients to send a new InitializeRequest when receiving a 404 for stale sessions.\nModern MCP clients handle this correctly. For session persistence across restarts, use the 'sessionStore' option.\nSee: https://modelcontextprotocol.io/specification/2025-11-25/basic/transports#session-management"
    );
  }
  let idleCleanupInterval;
  if (!config.stateless && idleTimeoutMs > 0) {
    idleCleanupInterval = startIdleCleanup(
      sessions,
      idleTimeoutMs,
      transports,
      mcpServerInstance
    );
  }
  const handleRequest = /* @__PURE__ */ __name(async (c) => {
    const acceptHeader = c.req.header("Accept") || c.req.header("accept") || "";
    const clientSupportsSSE = acceptHeader.includes("text/event-stream");
    const useStatelessMode = config.stateless || !clientSupportsSSE;
    if (useStatelessMode) {
      const server = mcpServerInstance.getServerForSession();
      const transport = new FetchStreamableHTTPServerTransport({
        sessionIdGenerator: void 0,
        // No session tracking
        // Enable plain JSON responses ONLY if client doesn't support SSE
        // This allows k6/curl to work while maintaining SSE format for compatible clients
        enableJsonResponse: !clientSupportsSSE
      });
      try {
        await server.connect(transport);
        const request = c.req.raw;
        if (!clientSupportsSSE) {
          const modifiedRequest = new Request(request.url, {
            method: request.method,
            headers: {
              ...Object.fromEntries(request.headers.entries()),
              Accept: "application/json, text/event-stream"
            },
            body: request.body,
            ...request.body && { duplex: "half" }
          });
          return await transport.handleRequest(modifiedRequest);
        }
        return await transport.handleRequest(request);
      } catch (error2) {
        console.error("[MCP] Stateless request error:", error2);
        transport.close();
        server.close();
        throw error2;
      }
    } else {
      const sessionId = c.req.header("mcp-session-id");
      if (c.req.method === "HEAD") {
        if (sessionId && await sessionStore.has(sessionId)) {
          const session = await sessionStore.get(sessionId);
          if (session) {
            session.lastAccessedAt = Date.now();
            await sessionStore.set(sessionId, session);
          }
        }
        return new Response(null, { status: 200 });
      }
      if (sessionId && await sessionStore.has(sessionId) && !transports.has(sessionId)) {
        console.log(
          `[MCP] Session metadata found but transport lost (likely hot reload): ${sessionId} - recreating transport`
        );
        const server2 = mcpServerInstance.getServerForSession();
        const transport2 = new FetchStreamableHTTPServerTransport({
          sessionIdGenerator: /* @__PURE__ */ __name(() => sessionId, "sessionIdGenerator"),
          // Reuse existing session ID
          onsessioninitialized: /* @__PURE__ */ __name(async (sid) => {
            console.log(`[MCP] Session reconnected: ${sid}`);
            transports.set(sid, transport2);
            const metadata = await sessionStore.get(sid);
            const sessionData = {
              transport: transport2,
              server: server2,
              lastAccessedAt: Date.now(),
              context: c,
              honoContext: c,
              ...metadata || {}
            };
            sessions.set(sid, sessionData);
            server2.server.oninitialized = async () => {
              const clientCapabilities = server2.server.getClientCapabilities();
              const clientInfo = server2.server.getClientInfo?.() || {};
              const protocolVersion = server2.server.getProtocolVersion?.() || "unknown";
              const metadata2 = await sessionStore.get(sid);
              if (metadata2) {
                metadata2.clientCapabilities = clientCapabilities;
                metadata2.clientInfo = clientInfo;
                metadata2.protocolVersion = String(protocolVersion);
                await sessionStore.set(sid, metadata2);
              }
              const sessionData2 = sessions.get(sid);
              if (sessionData2) {
                sessionData2.clientCapabilities = clientCapabilities;
              }
              Telemetry.getInstance().trackServerInitialize({
                protocolVersion: String(protocolVersion),
                clientInfo: clientInfo || {},
                clientCapabilities: clientCapabilities || {},
                sessionId: sid
              }).catch(
                (e) => console.debug(`Failed to track server initialize: ${e}`)
              );
              if (!isProductionMode2) {
                console.log(
                  `[MCP] Development mode: Sending list_changed notifications to reconnected session ${sid}`
                );
                try {
                  const { sendNotificationToSession: sendNotificationToSession3 } = await Promise.resolve().then(() => (init_notifications(), notifications_exports));
                  await sendNotificationToSession3(
                    sessions,
                    sid,
                    "notifications/tools/list_changed"
                  );
                  await sendNotificationToSession3(
                    sessions,
                    sid,
                    "notifications/resources/list_changed"
                  );
                  await sendNotificationToSession3(
                    sessions,
                    sid,
                    "notifications/prompts/list_changed"
                  );
                } catch (err) {
                  console.debug(
                    `[MCP] Failed to send list_changed notification:`,
                    err
                  );
                }
              }
            };
          }, "onsessioninitialized"),
          onsessionclosed: /* @__PURE__ */ __name(async (sid) => {
            console.log(`[MCP] Session closed: ${sid}`);
            transports.delete(sid);
            await streamManager.delete(sid);
            await sessionStore.delete(sid);
            sessions.delete(sid);
            mcpServerInstance.cleanupSessionSubscriptions?.(sid);
          }, "onsessionclosed")
        });
        await server2.connect(transport2);
        return transport2.handleRequest(c.req.raw);
      }
      if (sessionId && !await sessionStore.has(sessionId)) {
        console.log(
          `[MCP] Session not found: ${sessionId} - returning 404 (client should re-initialize)`
        );
        return c.json(
          {
            jsonrpc: "2.0",
            error: { code: -32001, message: "Session not found" },
            id: null
          },
          404
        );
      }
      if (sessionId && transports.has(sessionId)) {
        const transport2 = transports.get(sessionId);
        const metadata = await sessionStore.get(sessionId);
        if (metadata) {
          metadata.lastAccessedAt = Date.now();
          await sessionStore.set(sessionId, metadata);
        }
        const sessionData = sessions.get(sessionId);
        if (sessionData) {
          sessionData.lastAccessedAt = Date.now();
          sessionData.context = c;
          sessionData.honoContext = c;
        }
        return transport2.handleRequest(c.req.raw);
      }
      const server = mcpServerInstance.getServerForSession();
      const transport = new FetchStreamableHTTPServerTransport({
        sessionIdGenerator: /* @__PURE__ */ __name(() => generateUUID(), "sessionIdGenerator"),
        onsessioninitialized: /* @__PURE__ */ __name(async (sid) => {
          console.log(`[MCP] Session initialized: ${sid}`);
          transports.set(sid, transport);
          const sessionData = {
            transport,
            server,
            lastAccessedAt: Date.now(),
            context: c,
            honoContext: c
          };
          sessions.set(sid, sessionData);
          await sessionStore.set(sid, {
            lastAccessedAt: Date.now()
          });
          server.server.oninitialized = async () => {
            const clientCapabilities = server.server.getClientCapabilities();
            const clientInfo = server.server.getClientInfo?.() || {};
            const protocolVersion = server.server.getProtocolVersion?.() || "unknown";
            const metadata = await sessionStore.get(sid);
            if (metadata) {
              metadata.clientCapabilities = clientCapabilities;
              metadata.clientInfo = clientInfo;
              metadata.protocolVersion = String(protocolVersion);
              await sessionStore.set(sid, metadata);
              console.log(
                `[MCP] Captured client capabilities for session ${sid}:`,
                clientCapabilities ? Object.keys(clientCapabilities) : "none"
              );
            }
            const sessionData2 = sessions.get(sid);
            if (sessionData2) {
              sessionData2.clientCapabilities = clientCapabilities;
            }
            Telemetry.getInstance().trackServerInitialize({
              protocolVersion: String(protocolVersion),
              clientInfo: clientInfo || {},
              clientCapabilities: clientCapabilities || {},
              sessionId: sid
            }).catch(
              (e) => console.debug(`Failed to track server initialize: ${e}`)
            );
          };
        }, "onsessioninitialized"),
        onsessionclosed: /* @__PURE__ */ __name(async (sid) => {
          console.log(`[MCP] Session closed: ${sid}`);
          transports.delete(sid);
          await streamManager.delete(sid);
          await sessionStore.delete(sid);
          sessions.delete(sid);
          mcpServerInstance.cleanupSessionSubscriptions?.(sid);
        }, "onsessionclosed")
      });
      await server.connect(transport);
      return transport.handleRequest(c.req.raw);
    }
  }, "handleRequest");
  for (const endpoint of ["/mcp", "/sse"]) {
    app.on(["GET", "POST", "DELETE", "HEAD"], endpoint, handleRequest);
  }
  console.log(
    `[MCP] Server mounted at /mcp and /sse (${config.stateless ? "stateless" : "stateful"} mode)`
  );
  return { mcpMounted: true, idleCleanupInterval };
}
__name(mountMcp, "mountMcp");

// src/server/oauth/routes.ts
var import_cors2 = require("hono/cors");
function setupOAuthRoutes(app, provider, baseUrl) {
  const mode = provider.getMode?.() || "proxy";
  app.use(
    "/.well-known/*",
    (0, import_cors2.cors)({
      origin: "*",
      // Allow all origins for metadata discovery
      allowMethods: ["GET", "OPTIONS"],
      allowHeaders: ["Content-Type", "Authorization"],
      exposeHeaders: ["Content-Type"],
      maxAge: 86400
      // Cache preflight for 24 hours
    })
  );
  if (mode === "proxy") {
    app.use(
      "/authorize",
      (0, import_cors2.cors)({
        origin: "*",
        allowMethods: ["GET", "POST", "OPTIONS"],
        allowHeaders: ["Content-Type", "Authorization"],
        maxAge: 86400
      })
    );
    app.use(
      "/token",
      (0, import_cors2.cors)({
        origin: "*",
        allowMethods: ["POST", "OPTIONS"],
        allowHeaders: ["Content-Type", "Authorization"],
        maxAge: 86400
      })
    );
  }
  if (mode === "proxy") {
    const handleAuthorize = /* @__PURE__ */ __name(async (c) => {
      const params = c.req.method === "POST" ? await c.req.parseBody() : c.req.query();
      const clientId = params.client_id;
      const redirectUri = params.redirect_uri;
      const responseType = params.response_type;
      const codeChallenge = params.code_challenge;
      const codeChallengeMethod = params.code_challenge_method;
      const state = params.state;
      const scope = params.scope;
      const audience = params.audience;
      if (!clientId || !redirectUri || !responseType || !codeChallenge) {
        return c.json(
          {
            error: "invalid_request",
            error_description: "Missing required parameters"
          },
          400
        );
      }
      const authUrl = new URL(provider.getAuthEndpoint());
      authUrl.searchParams.set("client_id", clientId);
      authUrl.searchParams.set("redirect_uri", redirectUri);
      authUrl.searchParams.set("response_type", responseType);
      authUrl.searchParams.set("code_challenge", codeChallenge);
      authUrl.searchParams.set(
        "code_challenge_method",
        codeChallengeMethod || "S256"
      );
      if (state) authUrl.searchParams.set("state", state);
      if (scope) authUrl.searchParams.set("scope", scope);
      if (audience) authUrl.searchParams.set("audience", audience);
      return c.redirect(authUrl.toString(), 302);
    }, "handleAuthorize");
    app.get("/authorize", handleAuthorize);
    app.post("/authorize", handleAuthorize);
    app.post("/token", async (c) => {
      try {
        const body = await c.req.parseBody();
        const response = await fetch(provider.getTokenEndpoint(), {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: new URLSearchParams(body).toString()
        });
        const data = await response.json();
        if (!response.ok) {
          return c.json(data, response.status);
        }
        return c.json(data);
      } catch (error2) {
        return c.json(
          {
            error: "server_error",
            error_description: `Token exchange failed: ${error2}`
          },
          500
        );
      }
    });
  }
  const handleAuthorizationServerMetadata = /* @__PURE__ */ __name(async (c) => {
    const requestPath = new URL(c.req.url).pathname;
    console.log(`[OAuth] Metadata request: ${requestPath} (mode: ${mode})`);
    if (mode === "direct") {
      try {
        const metadataUrl = `${provider.getIssuer()}/.well-known/oauth-authorization-server`;
        console.log(`[OAuth] Fetching metadata from provider: ${metadataUrl}`);
        const response = await fetch(metadataUrl);
        if (!response.ok) {
          console.error(
            `[OAuth] Failed to fetch provider metadata: ${response.status}`
          );
          return c.json(
            {
              error: "server_error",
              error_description: `Failed to fetch provider metadata: ${response.status}`
            },
            500
          );
        }
        const metadata = await response.json();
        const hasRegisteredClient = provider.getRegistrationEndpoint && provider.config?.clientId;
        if (hasRegisteredClient) {
          console.log(
            `[OAuth] Provider has pre-registered client - removing DCR endpoint`
          );
          delete metadata.registration_endpoint;
        }
        console.log(`[OAuth] Provider metadata retrieved successfully`);
        console.log(`[OAuth]   - Issuer: ${metadata.issuer}`);
        console.log(
          `[OAuth]   - Registration endpoint: ${metadata.registration_endpoint || "not available (using pre-registered client)"}`
        );
        return c.json(metadata);
      } catch (error2) {
        console.error(`[OAuth] Error fetching provider metadata:`, error2);
        return c.json(
          {
            error: "server_error",
            error_description: `Failed to fetch provider metadata: ${error2}`
          },
          500
        );
      }
    } else {
      console.log(`[OAuth] Returning proxy mode metadata`);
      return c.json({
        issuer: provider.getIssuer(),
        authorization_endpoint: `${baseUrl}/authorize`,
        token_endpoint: `${baseUrl}/token`,
        response_types_supported: ["code"],
        grant_types_supported: provider.getGrantTypesSupported(),
        code_challenge_methods_supported: ["S256"],
        token_endpoint_auth_methods_supported: [
          "client_secret_post",
          "client_secret_basic",
          "none"
        ],
        scopes_supported: provider.getScopesSupported()
      });
    }
  }, "handleAuthorizationServerMetadata");
  app.get(
    "/.well-known/oauth-authorization-server",
    handleAuthorizationServerMetadata
  );
  app.get(
    "/.well-known/openid-configuration",
    handleAuthorizationServerMetadata
  );
  app.get("/.well-known/oauth-protected-resource", (c) => {
    console.log(`[OAuth] Protected resource metadata request (mode: ${mode})`);
    console.log(`[OAuth]   - Resource: ${baseUrl}`);
    console.log(`[OAuth]   - Authorization server: ${provider.getIssuer()}`);
    return c.json({
      resource: baseUrl,
      authorization_servers: [provider.getIssuer()],
      bearer_methods_supported: ["header"],
      resource_documentation: mode === "direct" ? "This resource uses direct OAuth flow. Clients communicate directly with the authorization server." : void 0
    });
  });
  app.get("/.well-known/oauth-protected-resource/mcp", (c) => {
    return c.json({
      resource: `${baseUrl}/mcp`,
      authorization_servers: [provider.getIssuer()],
      bearer_methods_supported: ["header"]
    });
  });
}
__name(setupOAuthRoutes, "setupOAuthRoutes");

// src/server/oauth/middleware.ts
function createBearerAuthMiddleware(provider, baseUrl) {
  return async (c, next) => {
    const authHeader = c.req.header("Authorization");
    const getWWWAuthenticateHeader = /* @__PURE__ */ __name(() => {
      const base = baseUrl || new URL(c.req.url).origin;
      const parts = [
        'Bearer error="unauthorized"',
        'error_description="Authorization needed"'
      ];
      parts.push(
        `resource_metadata="${base}/.well-known/oauth-protected-resource"`
      );
      return parts.join(", ");
    }, "getWWWAuthenticateHeader");
    if (!authHeader) {
      c.header("WWW-Authenticate", getWWWAuthenticateHeader());
      return c.json({ error: "Missing Authorization header" }, 401);
    }
    const [type, token] = authHeader.split(" ");
    if (type.toLowerCase() !== "bearer" || !token) {
      c.header("WWW-Authenticate", getWWWAuthenticateHeader());
      return c.json(
        {
          error: 'Invalid Authorization header format, expected "Bearer TOKEN"'
        },
        401
      );
    }
    try {
      const result = await provider.verifyToken(token);
      const payload = result.payload;
      const user = provider.getUserInfo(payload);
      const scope = payload.scope;
      const authInfo = {
        user,
        payload,
        accessToken: token,
        // Extract scopes from scope claim (OAuth standard)
        scopes: scope ? scope.split(" ") : [],
        // Extract permissions (Auth0 style, or custom)
        permissions: payload.permissions || []
      };
      c.set("auth", authInfo);
      c.auth = authInfo;
      c.set("user", user);
      c.set("payload", payload);
      c.set("accessToken", token);
      await next();
    } catch (error2) {
      c.header("WWW-Authenticate", getWWWAuthenticateHeader());
      return c.json({ error: `Invalid token: ${error2}` }, 401);
    }
  };
}
__name(createBearerAuthMiddleware, "createBearerAuthMiddleware");

// src/server/oauth/setup.ts
async function setupOAuthForServer(app, oauthProvider, baseUrl, state) {
  if (state.complete) {
    return state;
  }
  console.log(`[OAuth] OAuth provider initialized`);
  const middleware = createBearerAuthMiddleware(oauthProvider, baseUrl);
  setupOAuthRoutes(app, oauthProvider, baseUrl);
  const mode = oauthProvider.getMode?.() || "proxy";
  if (mode === "direct") {
    console.log(
      "[OAuth] Direct mode: Clients will authenticate with provider directly"
    );
    console.log("[OAuth] Metadata endpoints: /.well-known/*");
  } else {
    console.log(
      "[OAuth] Proxy mode: Routes at /authorize, /token, /.well-known/*"
    );
  }
  app.use("/mcp/*", middleware);
  console.log("[OAuth] Bearer authentication enabled on /mcp routes");
  return {
    provider: oauthProvider,
    middleware,
    complete: true
  };
}
__name(setupOAuthForServer, "setupOAuthForServer");

// src/server/mcp-server.ts
var MCPServerClass = class {
  static {
    __name(this, "MCPServerClass");
  }
  /**
   * Get the mcp-use package version.
   * Works in all environments (Node.js, browser, Cloudflare Workers, Deno, etc.)
   */
  static getPackageVersion() {
    return getPackageVersion();
  }
  /**
   * Native MCP server instance from @modelcontextprotocol/sdk
   * Exposed publicly for advanced use cases
   */
  nativeServer;
  /** @deprecated Use nativeServer instead - kept for backward compatibility */
  get server() {
    return this.nativeServer;
  }
  config;
  app;
  mcpMounted = false;
  inspectorMounted = false;
  serverPort;
  serverHost;
  serverBaseUrl;
  favicon;
  registeredTools = [];
  registeredPrompts = [];
  registeredResources = [];
  buildId;
  sessions = /* @__PURE__ */ new Map();
  idleCleanupInterval;
  oauthSetupState = {
    complete: false,
    provider: void 0,
    middleware: void 0
  };
  oauthProvider;
  oauthMiddleware;
  /**
   * Storage for registrations that can be replayed on new server instances
   * Following the official SDK pattern where each session gets its own server instance
   * @internal Exposed for telemetry purposes
   */
  registrations = {
    tools: /* @__PURE__ */ new Map(),
    prompts: /* @__PURE__ */ new Map(),
    resources: /* @__PURE__ */ new Map(),
    resourceTemplates: /* @__PURE__ */ new Map()
  };
  /**
   * Storage for widget definitions, used to inject metadata into tool responses
   * when using the widget() helper with returnsWidget option
   */
  widgetDefinitions = /* @__PURE__ */ new Map();
  /**
   * Resource subscription manager for tracking and notifying resource updates
   */
  subscriptionManager = new ResourceSubscriptionManager();
  /**
   * Clean up resource subscriptions for a closed session
   *
   * This method is called automatically when a session is closed to remove
   * all resource subscriptions associated with that session.
   *
   * @param sessionId - The session ID to clean up
   * @internal
   */
  cleanupSessionSubscriptions(sessionId) {
    this.subscriptionManager.cleanupSession(sessionId);
  }
  /**
   * Creates a new MCP server instance with Hono integration
   *
   * Initializes the server with the provided configuration, sets up CORS headers,
   * configures widget serving routes, and creates a proxy that allows direct
   * access to Hono methods while preserving MCP server functionality.
   *
   * @param config - Server configuration including name, version, and description
   * @returns A proxied MCPServer instance that supports both MCP and Hono methods
   */
  constructor(config) {
    this.config = config;
    if (this.config.stateless === void 0) {
      this.config.stateless = isDeno;
      if (this.config.stateless) {
        console.log("[MCP] Deno detected - using stateless mode (no sessions)");
      }
    }
    this.serverHost = config.host || "localhost";
    this.serverBaseUrl = config.baseUrl;
    this.favicon = config.favicon;
    this.nativeServer = new import_mcp2.McpServer(
      {
        name: config.name,
        version: config.version
      },
      {
        capabilities: {
          logging: {},
          resources: {
            subscribe: true,
            listChanged: true
          }
        }
      }
    );
    this.app = createHonoApp(requestLogger);
    this.oauthProvider = config.oauth;
    this.wrapRegistrationMethods();
    return createHonoProxy(this, this.app);
  }
  /**
   * Wrap registration methods to capture registrations following official SDK pattern.
   * Each session will get a fresh server instance with all registrations replayed.
   */
  wrapRegistrationMethods() {
    const originalTool = toolRegistration;
    const originalPrompt = registerPrompt;
    const originalResource = registerResource;
    const originalResourceTemplate = registerResourceTemplate;
    const self = this;
    this.tool = ((toolDefinition, callback) => {
      const widgetConfig = toolDefinition.widget;
      const widgetName = widgetConfig?.name;
      if (widgetConfig && widgetName) {
        const buildIdPart = self.buildId ? `-${self.buildId}` : "";
        const outputTemplate = `ui://widget/${widgetName}${buildIdPart}.html`;
        toolDefinition._meta = {
          ...toolDefinition._meta,
          "openai/outputTemplate": outputTemplate,
          "openai/toolInvocation/invoking": widgetConfig.invoking ?? `Loading ${widgetName}...`,
          "openai/toolInvocation/invoked": widgetConfig.invoked ?? `${widgetName} ready`,
          "openai/widgetAccessible": widgetConfig.widgetAccessible ?? true,
          "openai/resultCanProduceWidget": widgetConfig.resultCanProduceWidget ?? true
        };
      }
      let actualCallback = callback || toolDefinition.cb;
      if (widgetConfig && widgetName && actualCallback) {
        const originalCallback = actualCallback;
        actualCallback = /* @__PURE__ */ __name((async (params, ctx) => {
          const result = await originalCallback(params, ctx);
          const widgetDef = self.widgetDefinitions.get(widgetName);
          if (result && typeof result === "object") {
            const randomId = Math.random().toString(36).substring(2, 15);
            const buildIdPart = self.buildId ? `-${self.buildId}` : "";
            const uniqueUri = `ui://widget/${widgetName}${buildIdPart}-${randomId}.html`;
            const responseMeta = {
              ...widgetDef || {},
              // Include mcp-use/widget and other widget metadata
              "openai/outputTemplate": uniqueUri,
              "openai/toolInvocation/invoking": widgetConfig.invoking ?? `Loading ${widgetName}...`,
              "openai/toolInvocation/invoked": widgetConfig.invoked ?? `${widgetName} ready`,
              "openai/widgetAccessible": widgetConfig.widgetAccessible ?? true,
              "openai/resultCanProduceWidget": widgetConfig.resultCanProduceWidget ?? true
            };
            result._meta = {
              ...result._meta || {},
              ...responseMeta
            };
            if (result.content?.[0]?.type === "text" && !result.content[0].text) {
              result.content[0].text = `Displaying ${widgetName}`;
            }
          }
          return result;
        }), "actualCallback");
      }
      if (actualCallback) {
        self.registrations.tools.set(toolDefinition.name, {
          config: toolDefinition,
          handler: actualCallback
        });
      }
      return originalTool.call(self, toolDefinition, actualCallback);
    });
    this.prompt = ((promptDefinition, callback) => {
      const actualCallback = callback || promptDefinition.cb;
      if (actualCallback) {
        self.registrations.prompts.set(promptDefinition.name, {
          config: promptDefinition,
          handler: actualCallback
        });
      }
      return originalPrompt.call(
        self,
        promptDefinition,
        callback
      );
    });
    this.resource = ((resourceDefinition, callback) => {
      const actualCallback = callback || resourceDefinition.readCallback;
      if (actualCallback) {
        const resourceKey = `${resourceDefinition.name}:${resourceDefinition.uri}`;
        self.registrations.resources.set(resourceKey, {
          config: resourceDefinition,
          handler: actualCallback
        });
      }
      return originalResource.call(self, resourceDefinition, callback);
    });
    this.resourceTemplate = ((templateDefinition, callback) => {
      const actualCallback = callback || templateDefinition.readCallback;
      if (actualCallback) {
        self.registrations.resourceTemplates.set(templateDefinition.name, {
          config: templateDefinition,
          handler: actualCallback
        });
      }
      return originalResourceTemplate.call(
        self,
        templateDefinition,
        callback
      );
    });
  }
  /**
   * Create a new server instance for a session following official SDK pattern.
   * This is called for each initialize request to create an isolated server.
   */
  getServerForSession() {
    const newServer = new import_mcp2.McpServer(
      {
        name: this.config.name,
        version: this.config.version
      },
      {
        capabilities: {
          logging: {}
        }
      }
    );
    for (const [name, registration] of this.registrations.tools) {
      const { config, handler: actualCallback } = registration;
      let inputSchema;
      if (config.schema) {
        inputSchema = this.convertZodSchemaToParams(config.schema);
      } else if (config.inputs && config.inputs.length > 0) {
        inputSchema = this.createParamsSchema(config.inputs);
      } else {
        inputSchema = {};
      }
      const wrappedHandler = /* @__PURE__ */ __name(async (params, extra) => {
        const initialRequestContext = getRequestContext();
        const extraProgressToken = extra?._meta?.progressToken;
        const extraSendNotification = extra?.sendNotification;
        const { requestContext, session, progressToken, sendNotification: sendNotification2 } = findSessionContext(
          this.sessions,
          initialRequestContext,
          extraProgressToken,
          extraSendNotification
        );
        let sessionId;
        if (session) {
          for (const [id, s] of this.sessions.entries()) {
            if (s === session) {
              sessionId = id;
              break;
            }
          }
        }
        const createMessageWithLogging = /* @__PURE__ */ __name(async (params2, options) => {
          console.log("[createMessage] About to call server.createMessage");
          console.log("[createMessage] Has server:", !!newServer);
          try {
            const result = await newServer.server.createMessage(
              params2,
              options
            );
            console.log("[createMessage] Got result successfully");
            return result;
          } catch (err) {
            const error2 = err;
            console.error(
              "[createMessage] Error:",
              error2.message,
              "Code:",
              error2.code
            );
            throw err;
          }
        }, "createMessageWithLogging");
        const enhancedContext = createEnhancedContext(
          requestContext,
          createMessageWithLogging,
          newServer.server.elicitInput.bind(newServer.server),
          progressToken,
          sendNotification2,
          session?.logLevel,
          session?.clientCapabilities,
          sessionId,
          this.sessions
        );
        const executeCallback = /* @__PURE__ */ __name(async () => {
          if (actualCallback.length >= 2) {
            return await actualCallback(params, enhancedContext);
          }
          return await actualCallback(params);
        }, "executeCallback");
        const startTime = Date.now();
        let success = true;
        let errorType = null;
        try {
          const result = requestContext ? await runWithContext(requestContext, executeCallback) : await executeCallback();
          return result;
        } catch (err) {
          success = false;
          errorType = err instanceof Error ? err.name : "unknown_error";
          throw err;
        } finally {
          const executionTimeMs = Date.now() - startTime;
          Telemetry.getInstance().trackServerToolCall({
            toolName: name,
            lengthInputArgument: JSON.stringify(params).length,
            success,
            errorType,
            executionTimeMs
          }).catch((e) => console.debug(`Failed to track tool call: ${e}`));
        }
      }, "wrappedHandler");
      newServer.registerTool(
        name,
        {
          title: config.title,
          description: config.description ?? "",
          inputSchema,
          annotations: config.annotations,
          _meta: config._meta
        },
        wrappedHandler
      );
    }
    for (const [name, registration] of this.registrations.prompts) {
      const { config, handler } = registration;
      let argsSchema;
      if (config.schema) {
        argsSchema = this.convertZodSchemaToParams(config.schema);
      } else if (config.args && config.args.length > 0) {
        argsSchema = this.createParamsSchema(config.args);
      } else {
        argsSchema = void 0;
      }
      const wrappedHandler = /* @__PURE__ */ __name(async (params, extra) => {
        let success = true;
        let errorType = null;
        try {
          const result = await handler(params, extra);
          if ("messages" in result && Array.isArray(result.messages)) {
            return result;
          }
          const { convertToolResultToPromptResult: convertToolResultToPromptResult2 } = await Promise.resolve().then(() => (init_conversion2(), conversion_exports2));
          return convertToolResultToPromptResult2(result);
        } catch (err) {
          success = false;
          errorType = err instanceof Error ? err.name : "unknown_error";
          throw err;
        } finally {
          Telemetry.getInstance().trackServerPromptCall({
            name,
            description: config.description ?? null,
            success,
            errorType
          }).catch((e) => console.debug(`Failed to track prompt call: ${e}`));
        }
      }, "wrappedHandler");
      newServer.registerPrompt(
        name,
        {
          title: config.title,
          description: config.description ?? "",
          argsSchema
        },
        wrappedHandler
      );
    }
    for (const [_key, registration] of this.registrations.resources) {
      const { config, handler } = registration;
      const wrappedHandler = /* @__PURE__ */ __name(async (extra) => {
        let success = true;
        let errorType = null;
        let contents = [];
        try {
          const result = await handler(extra);
          if ("contents" in result && Array.isArray(result.contents)) {
            contents = result.contents;
            return result;
          }
          const { convertToolResultToResourceResult: convertToolResultToResourceResult2 } = await Promise.resolve().then(() => (init_conversion(), conversion_exports));
          const converted = convertToolResultToResourceResult2(
            config.uri,
            result
          );
          contents = converted.contents || [];
          return converted;
        } catch (err) {
          success = false;
          errorType = err instanceof Error ? err.name : "unknown_error";
          throw err;
        } finally {
          Telemetry.getInstance().trackServerResourceCall({
            name: config.name,
            description: config.description ?? null,
            contents: contents.map((c) => ({
              mime_type: c.mimeType ?? null,
              text: c.text ? `[text: ${c.text.length} chars]` : null,
              blob: c.blob ? `[blob: ${c.blob.length} bytes]` : null
            })),
            success,
            errorType
          }).catch((e) => console.debug(`Failed to track resource call: ${e}`));
        }
      }, "wrappedHandler");
      newServer.registerResource(
        config.name,
        config.uri,
        {
          title: config.title,
          description: config.description,
          mimeType: config.mimeType || "text/plain"
        },
        wrappedHandler
      );
    }
    for (const [_name, registration] of this.registrations.resourceTemplates) {
      const { config, handler } = registration;
      const isFlatStructure = "uriTemplate" in config;
      const uriTemplate = isFlatStructure ? config.uriTemplate : config.resourceTemplate.uriTemplate;
      const mimeType = isFlatStructure ? config.mimeType : config.resourceTemplate.mimeType;
      const templateDescription = isFlatStructure ? void 0 : config.resourceTemplate.description;
      const template = new import_mcp2.ResourceTemplate(uriTemplate, {
        list: void 0,
        complete: void 0
      });
      const metadata = {};
      if (config.title) {
        metadata.title = config.title;
      }
      if (config.description || templateDescription) {
        metadata.description = config.description || templateDescription;
      }
      if (mimeType) {
        metadata.mimeType = mimeType;
      }
      if (config.annotations) {
        metadata.annotations = config.annotations;
      }
      newServer.registerResource(
        config.name,
        template,
        metadata,
        async (uri, extra) => {
          let success = true;
          let errorType = null;
          let contents = [];
          try {
            const params = this.parseTemplateUri(uriTemplate, uri.toString());
            const result = await handler(uri, params, extra);
            if ("contents" in result && Array.isArray(result.contents)) {
              contents = result.contents;
              return result;
            }
            const { convertToolResultToResourceResult: convertToolResultToResourceResult2 } = await Promise.resolve().then(() => (init_conversion(), conversion_exports));
            const converted = convertToolResultToResourceResult2(
              uri.toString(),
              result
            );
            contents = converted.contents || [];
            return converted;
          } catch (err) {
            success = false;
            errorType = err instanceof Error ? err.name : "unknown_error";
            throw err;
          } finally {
            Telemetry.getInstance().trackServerResourceCall({
              name: config.name,
              description: config.description ?? null,
              contents: contents.map((c) => ({
                mimeType: c.mimeType ?? null,
                text: c.text ? `[text: ${c.text.length} chars]` : null,
                blob: c.blob ? `[blob: ${c.blob.length} bytes]` : null
              })),
              success,
              errorType
            }).catch(
              (e) => console.debug(`Failed to track resource template call: ${e}`)
            );
          }
        }
      );
    }
    newServer.server.setRequestHandler(
      import_zod3.z.object({ method: import_zod3.z.literal("logging/setLevel") }).passthrough(),
      (async (request, extra) => {
        const level = request.params?.level;
        if (!level) {
          throw new import_types2.McpError(
            import_types2.ErrorCode.InvalidParams,
            "Missing 'level' parameter"
          );
        }
        if (!isValidLogLevel(level)) {
          throw new import_types2.McpError(
            import_types2.ErrorCode.InvalidParams,
            `Invalid log level '${level}'. Must be one of: debug, info, notice, warning, error, critical, alert, emergency`
          );
        }
        const requestContext = getRequestContext();
        if (requestContext) {
          const sessionId = requestContext.req.header("mcp-session-id");
          if (sessionId && this.sessions.has(sessionId)) {
            const session = this.sessions.get(sessionId);
            session.logLevel = level;
            console.log(
              `[MCP] Set log level to '${level}' for session ${sessionId}`
            );
            return {};
          }
        }
        for (const [sessionId, session] of this.sessions.entries()) {
          if (session.server === newServer) {
            session.logLevel = level;
            console.log(
              `[MCP] Set log level to '${level}' for session ${sessionId}`
            );
            return {};
          }
        }
        console.warn(
          "[MCP] Could not find session for logging/setLevel request"
        );
        throw new import_types2.McpError(import_types2.ErrorCode.InternalError, "Could not find session");
      })
    );
    this.subscriptionManager.registerHandlers(newServer, this.sessions);
    return newServer;
  }
  /**
   * Gets the server base URL with fallback to host:port if not configured
   * @returns The complete base URL for the server
   */
  getServerBaseUrl() {
    return getServerBaseUrl(
      this.serverBaseUrl,
      this.serverHost,
      this.serverPort
    );
  }
  // Tool registration helper - type is set in wrapRegistrationMethods
  tool;
  // Schema conversion helpers (used by tool registration)
  convertZodSchemaToParams = convertZodSchemaToParams;
  createParamsSchema = createParamsSchema;
  // Template URI parsing helper (used by resource templates)
  parseTemplateUri = parseTemplateUri;
  // Resource registration helpers - types are set in wrapRegistrationMethods
  resource;
  resourceTemplate;
  // Prompt registration helper - type is set in wrapRegistrationMethods
  prompt;
  // Notification helpers
  getActiveSessions = getActiveSessions;
  sendNotification = sendNotification;
  sendNotificationToSession = sendNotificationToSession2;
  sendToolsListChanged = sendToolsListChanged;
  sendResourcesListChanged = sendResourcesListChanged;
  sendPromptsListChanged = sendPromptsListChanged;
  /**
   * Notify subscribed clients that a resource has been updated
   *
   * This method sends a `notifications/resources/updated` notification to all
   * sessions that have subscribed to the specified resource URI.
   *
   * @param uri - The URI of the resource that changed
   * @returns Promise that resolves when all notifications have been sent
   *
   * @example
   * ```typescript
   * // After updating a resource, notify subscribers
   * await server.notifyResourceUpdated("file:///path/to/resource.txt");
   * ```
   */
  async notifyResourceUpdated(uri) {
    return this.subscriptionManager.notifyResourceUpdated(uri, this.sessions);
  }
  uiResource = /* @__PURE__ */ __name((definition) => {
    return uiResourceRegistration(this, definition);
  }, "uiResource");
  /**
   * Mount MCP server endpoints at /mcp and /sse
   *
   * Sets up the HTTP transport layer for the MCP server, creating endpoints for
   * Server-Sent Events (SSE) streaming, POST message handling, and DELETE session cleanup.
   * The transport manages multiple sessions through a single server instance.
   *
   * This method is called automatically when the server starts listening and ensures
   * that MCP clients can communicate with the server over HTTP.
   *
   * @private
   * @returns Promise that resolves when MCP endpoints are successfully mounted
   *
   * @example
   * Endpoints created:
   * - GET /mcp, GET /sse - SSE streaming endpoint for real-time communication
   * - POST /mcp, POST /sse - Message handling endpoint for MCP protocol messages
   * - DELETE /mcp, DELETE /sse - Session cleanup endpoint
   */
  async mountMcp() {
    if (this.mcpMounted) return;
    const result = await mountMcp(
      this.app,
      this,
      // Pass the MCPServer instance so mountMcp can call getServerForSession()
      this.sessions,
      this.config,
      isProductionMode()
    );
    this.mcpMounted = result.mcpMounted;
  }
  /**
   * Start the Hono server with MCP endpoints
   *
   * Initiates the server startup process by mounting MCP endpoints, configuring
   * the inspector UI (if available), and starting the server to listen
   * for incoming connections. This is the main entry point for running the server.
   *
   * The server will be accessible at the specified port with MCP endpoints at /mcp and /sse
   * and inspector UI at /inspector (if the inspector package is installed).
   *
   * @param port - Port number to listen on (defaults to 3000 if not specified)
   * @returns Promise that resolves when the server is successfully listening
   *
   * @example
   * ```typescript
   * await server.listen(8080)
   * // Server now running at http://localhost:8080 (or configured host)
   * // MCP endpoints: http://localhost:8080/mcp and http://localhost:8080/sse
   * // Inspector UI: http://localhost:8080/inspector
   * ```
   */
  /**
   * Log registered tools, prompts, and resources to console
   */
  logRegisteredItems() {
    logRegisteredItems(
      this.registeredTools,
      this.registeredPrompts,
      this.registeredResources
    );
  }
  getBuildId() {
    return this.buildId;
  }
  getServerPort() {
    return this.serverPort || 3e3;
  }
  /**
   * Create a message for sampling (calling the LLM)
   * Delegates to the native SDK server
   */
  async createMessage(params, options) {
    return await this.nativeServer.server.createMessage(params, options);
  }
  async listen(port) {
    const portEnv = getEnv("PORT");
    this.serverPort = port || (portEnv ? parseInt(portEnv, 10) : 3e3);
    const hostEnv = getEnv("HOST");
    if (hostEnv) {
      this.serverHost = hostEnv;
    }
    this.serverBaseUrl = getServerBaseUrl(
      this.serverBaseUrl,
      this.serverHost,
      this.serverPort
    );
    if (this.oauthProvider && !this.oauthSetupState.complete) {
      await setupOAuthForServer(
        this.app,
        this.oauthProvider,
        this.getServerBaseUrl(),
        this.oauthSetupState
      );
    }
    await mountWidgets(this, {
      baseRoute: "/mcp-use/widgets",
      resourcesDir: "resources"
    });
    await this.mountMcp();
    await this.mountInspector();
    this.logRegisteredItems();
    this._trackServerRun("http");
    await startServer(this.app, this.serverPort, this.serverHost, {
      onDenoRequest: rewriteSupabaseRequest
    });
  }
  _trackServerRun(transport) {
    Telemetry.getInstance().trackServerRunFromServer(this, transport).catch((e) => console.debug(`Failed to track server run: ${e}`));
  }
  /**
   * Get the fetch handler for the server after mounting all endpoints
   *
   * This method prepares the server by mounting MCP endpoints, widgets, and inspector
   * (if available), then returns the fetch handler. This is useful for integrating
   * with external server frameworks like Supabase Edge Functions, Cloudflare Workers,
   * or other platforms that handle the server lifecycle themselves.
   *
   * Unlike `listen()`, this method does not start a server - it only prepares the
   * routes and returns the handler function that can be used with external servers.
   *
   * @param options - Optional configuration for the handler
   * @param options.provider - Platform provider (e.g., 'supabase') to handle platform-specific path rewriting
   * @returns Promise that resolves to the fetch handler function
   *
   * @example
   * ```typescript
   * // For Supabase Edge Functions (handles path rewriting automatically)
   * const server = new MCPServer({ name: 'my-server', version: '1.0.0' });
   * server.tool({ ... });
   * const handler = await server.getHandler({ provider: 'supabase' });
   * Deno.serve(handler);
   * ```
   *
   * @example
   * ```typescript
   * // For Cloudflare Workers
   * const server = new MCPServer({ name: 'my-server', version: '1.0.0' });
   * server.tool({ ... });
   * const handler = await server.getHandler();
   * export default { fetch: handler };
   * ```
   */
  async getHandler(options) {
    if (this.oauthProvider && !this.oauthSetupState.complete) {
      await setupOAuthForServer(
        this.app,
        this.oauthProvider,
        this.getServerBaseUrl(),
        this.oauthSetupState
      );
    }
    console.log("[MCP] Mounting widgets");
    await mountWidgets(this, {
      baseRoute: "/mcp-use/widgets",
      resourcesDir: "resources"
    });
    console.log("[MCP] Mounted widgets");
    await this.mountMcp();
    console.log("[MCP] Mounted MCP");
    console.log("[MCP] Mounting inspector");
    await this.mountInspector();
    console.log("[MCP] Mounted inspector");
    const provider = options?.provider || "fetch";
    this._trackServerRun(provider);
    const fetchHandler = this.app.fetch.bind(this.app);
    if (options?.provider === "supabase") {
      return async (req) => {
        const corsHeaders = getDenoCorsHeaders();
        if (req.method === "OPTIONS") {
          return new Response("ok", { headers: corsHeaders });
        }
        const rewrittenReq = rewriteSupabaseRequest(req);
        const result = await fetchHandler(rewrittenReq);
        return applyDenoCorsHeaders(result);
      };
    }
    return async (req) => {
      const result = await fetchHandler(req);
      return result;
    };
  }
  // Roots registration helpers
  onRootsChanged = onRootsChanged.bind(this);
  listRoots = listRoots.bind(this);
  /**
   * Mount MCP Inspector UI at /inspector
   *
   * Dynamically loads and mounts the MCP Inspector UI package if available, providing
   * a web-based interface for testing and debugging MCP servers. The inspector
   * automatically connects to the local MCP server endpoints.
   *
   * This method gracefully handles cases where the inspector package is not installed,
   * allowing the server to function without the inspector in production environments.
   *
   * @private
   * @returns void
   *
   * @example
   * If @mcp-use/inspector is installed:
   * - Inspector UI available at http://localhost:PORT/inspector
   * - Automatically connects to http://localhost:PORT/mcp (or /sse)
   *
   * If not installed:
   * - Server continues to function normally
   * - No inspector UI available
   */
  async mountInspector() {
    if (this.inspectorMounted) return;
    const mounted = await mountInspectorUI(
      this.app,
      this.serverHost,
      this.serverPort,
      isProductionMode()
    );
    if (mounted) {
      this.inspectorMounted = true;
    }
  }
};
var MCPServer = MCPServerClass;
function createMCPServer(name, config = {}) {
  const instance = new MCPServerClass({
    name,
    version: config.version || "1.0.0",
    description: config.description,
    host: config.host,
    baseUrl: config.baseUrl,
    allowedOrigins: config.allowedOrigins,
    sessionIdleTimeoutMs: config.sessionIdleTimeoutMs,
    autoCreateSessionOnInvalidId: config.autoCreateSessionOnInvalidId,
    oauth: config.oauth,
    favicon: config.favicon
  });
  return instance;
}
__name(createMCPServer, "createMCPServer");

// src/server/index.ts
init_version();
init_context_storage();

// src/server/oauth/providers/supabase.ts
var import_jose = require("jose");
var SupabaseOAuthProvider = class {
  static {
    __name(this, "SupabaseOAuthProvider");
  }
  config;
  supabaseUrl;
  supabaseAuthUrl;
  issuer;
  jwks = null;
  constructor(config) {
    this.config = config;
    this.supabaseUrl = `https://${config.projectId}.supabase.co`;
    this.supabaseAuthUrl = `${this.supabaseUrl}/auth/v1`;
    this.issuer = `${this.supabaseUrl}/auth/v1`;
  }
  getJWKS() {
    if (!this.jwks) {
      this.jwks = (0, import_jose.createRemoteJWKSet)(
        new URL(`${this.issuer}/.well-known/jwks.json`)
      );
    }
    return this.jwks;
  }
  async verifyToken(token) {
    if (this.config.skipVerification) {
      console.warn(
        "[Supabase OAuth] \u26A0\uFE0F  SKIPPING VERIFICATION (DEVELOPMENT MODE)"
      );
      console.warn(
        "[Supabase OAuth]     This is NOT secure! Only use for testing!"
      );
      const payload = (0, import_jose.decodeJwt)(token);
      return { payload, protectedHeader: (0, import_jose.decodeProtectedHeader)(token) };
    }
    try {
      const header = (0, import_jose.decodeProtectedHeader)(token);
      if (header.alg === "HS256") {
        if (!this.config.jwtSecret) {
          throw new Error(
            "JWT Secret is required for HS256 tokens. Get it from: Supabase Dashboard \u2192 Project Settings \u2192 API \u2192 JWT Settings"
          );
        }
        const secret = new TextEncoder().encode(this.config.jwtSecret);
        const result = await (0, import_jose.jwtVerify)(token, secret, {
          issuer: this.issuer,
          audience: "authenticated"
        });
        return result;
      } else if (header.alg === "ES256") {
        const result = await (0, import_jose.jwtVerify)(token, this.getJWKS(), {
          issuer: this.issuer,
          audience: "authenticated"
        });
        return result;
      } else {
        throw new Error(`Unsupported algorithm: ${header.alg}`);
      }
    } catch (error2) {
      throw new Error(`Supabase JWT verification failed: ${error2}`);
    }
  }
  getUserInfo(payload) {
    const userMetadata = payload.user_metadata;
    return {
      userId: payload.sub || payload.user_id,
      email: payload.email,
      name: userMetadata?.name || userMetadata?.full_name,
      username: userMetadata?.username,
      picture: userMetadata?.avatar_url,
      roles: payload.role ? [payload.role] : [],
      permissions: payload.aal ? [`aal:${payload.aal}`] : [],
      // Include Supabase-specific claims
      aal: payload.aal,
      // Authentication Assurance Level
      amr: payload.amr,
      // Authentication Methods References
      session_id: payload.session_id
    };
  }
  getIssuer() {
    return this.issuer;
  }
  getAuthEndpoint() {
    return `${this.supabaseAuthUrl}/authorize`;
  }
  getTokenEndpoint() {
    return `${this.supabaseAuthUrl}/token`;
  }
  getScopesSupported() {
    return [];
  }
  getGrantTypesSupported() {
    return ["authorization_code", "refresh_token"];
  }
};

// src/server/oauth/providers/auth0.ts
var import_jose2 = require("jose");
var Auth0OAuthProvider = class {
  static {
    __name(this, "Auth0OAuthProvider");
  }
  config;
  issuer;
  jwks = null;
  constructor(config) {
    this.config = config;
    this.issuer = `https://${config.domain}`;
  }
  getJWKS() {
    if (!this.jwks) {
      this.jwks = (0, import_jose2.createRemoteJWKSet)(
        new URL(`${this.issuer}/.well-known/jwks.json`)
      );
    }
    return this.jwks;
  }
  async verifyToken(token) {
    if (this.config.verifyJwt === false) {
      console.warn("[Auth0 OAuth] \u26A0\uFE0F  JWT verification is disabled");
      console.warn("[Auth0 OAuth]     Enable verifyJwt: true for production");
      const parts = token.split(".");
      if (parts.length !== 3) {
        throw new Error("Invalid JWT format");
      }
      const payload = JSON.parse(
        Buffer.from(parts[1], "base64url").toString("utf8")
      );
      return { payload };
    }
    try {
      const result = await (0, import_jose2.jwtVerify)(token, this.getJWKS(), {
        issuer: this.issuer,
        audience: this.config.audience
      });
      return result;
    } catch (error2) {
      throw new Error(`Auth0 JWT verification failed: ${error2}`);
    }
  }
  getUserInfo(payload) {
    const scope = payload.scope;
    return {
      userId: payload.sub,
      email: payload.email,
      name: payload.name,
      username: payload.username,
      nickname: payload.nickname,
      picture: payload.picture,
      // Auth0 includes permissions directly in the token
      permissions: payload.permissions || [],
      // Auth0 can include roles (if configured)
      roles: payload.roles || payload["https://your-app.com/roles"] || [],
      // Include scope as well
      scopes: scope ? scope.split(" ") : [],
      // Additional Auth0-specific claims
      email_verified: payload.email_verified,
      updated_at: payload.updated_at
    };
  }
  getIssuer() {
    return this.issuer;
  }
  getAuthEndpoint() {
    return `${this.issuer}/authorize`;
  }
  getTokenEndpoint() {
    return `${this.issuer}/oauth/token`;
  }
  getScopesSupported() {
    return ["openid", "profile", "email", "offline_access"];
  }
  getGrantTypesSupported() {
    return ["authorization_code", "refresh_token"];
  }
};

// src/server/oauth/providers/keycloak.ts
var import_jose3 = require("jose");
var KeycloakOAuthProvider = class {
  static {
    __name(this, "KeycloakOAuthProvider");
  }
  config;
  issuer;
  jwks = null;
  constructor(config) {
    this.config = config;
    const serverUrl = config.serverUrl.replace(/\/$/, "");
    this.issuer = `${serverUrl}/realms/${config.realm}`;
  }
  getJWKS() {
    if (!this.jwks) {
      this.jwks = (0, import_jose3.createRemoteJWKSet)(
        new URL(`${this.issuer}/protocol/openid-connect/certs`)
      );
    }
    return this.jwks;
  }
  async verifyToken(token) {
    if (this.config.verifyJwt === false) {
      console.warn("[Keycloak OAuth] \u26A0\uFE0F  JWT verification is disabled");
      console.warn(
        "[Keycloak OAuth]     Enable verifyJwt: true for production"
      );
      const parts = token.split(".");
      if (parts.length !== 3) {
        throw new Error("Invalid JWT format");
      }
      const payload = JSON.parse(
        Buffer.from(parts[1], "base64url").toString("utf8")
      );
      return { payload };
    }
    try {
      const result = await (0, import_jose3.jwtVerify)(token, this.getJWKS(), {
        issuer: this.issuer,
        // Don't verify audience if not specified
        ...this.config.clientId && { audience: this.config.clientId }
      });
      return result;
    } catch (error2) {
      throw new Error(`Keycloak JWT verification failed: ${error2}`);
    }
  }
  getUserInfo(payload) {
    const realmAccess = payload.realm_access;
    const realmRoles = realmAccess?.roles || [];
    const resourceAccess = payload.resource_access;
    const clientRoles = this.config.clientId && (resourceAccess?.[this.config.clientId]?.roles || []) || [];
    const allRoles = [...realmRoles, ...clientRoles];
    const permissions = [];
    if (payload.resource_access) {
      Object.entries(payload.resource_access).forEach(
        ([resource2, access]) => {
          if (access.roles) {
            access.roles.forEach((role) => {
              permissions.push(`${resource2}:${role}`);
            });
          }
        }
      );
    }
    const scope = payload.scope;
    return {
      userId: payload.sub,
      email: payload.email,
      name: payload.name,
      username: payload.preferred_username,
      nickname: payload.preferred_username,
      picture: payload.picture,
      roles: allRoles,
      permissions,
      // Include scope as well
      scopes: scope ? scope.split(" ") : [],
      // Keycloak-specific claims
      email_verified: payload.email_verified,
      given_name: payload.given_name,
      family_name: payload.family_name,
      realm_access: payload.realm_access,
      resource_access: payload.resource_access
    };
  }
  getIssuer() {
    return this.issuer;
  }
  getAuthEndpoint() {
    return `${this.issuer}/protocol/openid-connect/auth`;
  }
  getTokenEndpoint() {
    return `${this.issuer}/protocol/openid-connect/token`;
  }
  getScopesSupported() {
    return ["openid", "profile", "email", "offline_access", "roles"];
  }
  getGrantTypesSupported() {
    return ["authorization_code", "refresh_token", "client_credentials"];
  }
};

// src/server/oauth/providers/workos.ts
var import_jose4 = require("jose");
var WorkOSOAuthProvider = class {
  static {
    __name(this, "WorkOSOAuthProvider");
  }
  config;
  issuer;
  jwks = null;
  constructor(config) {
    this.config = config;
    this.issuer = `https://${config.subdomain}.authkit.app`;
  }
  getJWKS() {
    if (!this.jwks) {
      this.jwks = (0, import_jose4.createRemoteJWKSet)(new URL(`${this.issuer}/oauth2/jwks`));
    }
    return this.jwks;
  }
  async verifyToken(token) {
    if (this.config.verifyJwt === false) {
      console.warn("[WorkOS OAuth] \u26A0\uFE0F  JWT verification is disabled");
      console.warn("[WorkOS OAuth]     Enable verifyJwt: true for production");
      const parts = token.split(".");
      if (parts.length !== 3) {
        throw new Error("Invalid JWT format");
      }
      const payload = (0, import_jose4.decodeJwt)(token);
      return { payload };
    }
    try {
      const result = await (0, import_jose4.jwtVerify)(token, this.getJWKS(), {
        issuer: this.issuer
      });
      return result;
    } catch (error2) {
      throw new Error(`WorkOS JWT verification failed: ${error2}`);
    }
  }
  getUserInfo(payload) {
    return {
      userId: payload.sub,
      email: payload.email,
      name: payload.name,
      username: payload.preferred_username,
      picture: payload.picture,
      // WorkOS includes permissions and roles in token
      permissions: payload.permissions || [],
      roles: payload.roles || [],
      // Include scope as well
      scopes: payload.scope ? payload.scope.split(" ") : [],
      // Additional WorkOS-specific claims
      email_verified: payload.email_verified,
      organization_id: payload.org_id,
      sid: payload.sid
      // Session ID
    };
  }
  getIssuer() {
    return this.issuer;
  }
  getAuthEndpoint() {
    return `${this.issuer}/oauth2/authorize`;
  }
  getTokenEndpoint() {
    return `${this.issuer}/oauth2/token`;
  }
  getScopesSupported() {
    return ["email", "offline_access", "openid", "profile"];
  }
  getGrantTypesSupported() {
    return ["authorization_code", "refresh_token"];
  }
  getMode() {
    if (this.config.clientId) {
      console.log("[WorkOS OAuth] Using proxy mode (pre-registered client)");
      return "proxy";
    }
    console.log(
      "[WorkOS OAuth] Using direct mode (Dynamic Client Registration)"
    );
    return "direct";
  }
  getRegistrationEndpoint() {
    if (this.config.clientId) {
      return void 0;
    }
    return `${this.issuer}/oauth2/register`;
  }
};

// src/server/oauth/providers/custom.ts
var CustomOAuthProvider = class {
  static {
    __name(this, "CustomOAuthProvider");
  }
  config;
  constructor(config) {
    this.config = config;
  }
  async verifyToken(token) {
    try {
      const result = await this.config.verifyToken(token);
      return result;
    } catch (error2) {
      throw new Error(`Custom OAuth verification failed: ${error2}`);
    }
  }
  getUserInfo(payload) {
    if (this.config.getUserInfo) {
      return this.config.getUserInfo(payload);
    }
    const scope = payload.scope;
    const roles = payload.roles;
    const permissions = payload.permissions;
    return {
      userId: payload.sub || payload.user_id || payload.id,
      email: payload.email ? payload.email : void 0,
      name: payload.name ? payload.name : void 0,
      username: payload.username || payload.preferred_username ? payload.username || payload.preferred_username : void 0,
      nickname: payload.nickname ? payload.nickname : void 0,
      picture: payload.picture || payload.avatar_url ? payload.picture || payload.avatar_url : void 0,
      roles: Array.isArray(roles) ? roles : [],
      permissions: Array.isArray(permissions) ? permissions : [],
      scopes: scope ? scope.split(" ") : []
    };
  }
  getIssuer() {
    return this.config.issuer;
  }
  getAuthEndpoint() {
    return this.config.authEndpoint;
  }
  getTokenEndpoint() {
    return this.config.tokenEndpoint;
  }
  getScopesSupported() {
    return this.config.scopesSupported || ["openid", "profile", "email"];
  }
  getGrantTypesSupported() {
    return this.config.grantTypesSupported || ["authorization_code", "refresh_token"];
  }
};

// src/server/oauth/providers.ts
init_runtime();
function oauthSupabaseProvider(config = {}) {
  const projectId = config.projectId ?? getEnv("MCP_USE_OAUTH_SUPABASE_PROJECT_ID");
  const jwtSecret = config.jwtSecret ?? getEnv("MCP_USE_OAUTH_SUPABASE_JWT_SECRET");
  if (!projectId) {
    throw new Error(
      "Supabase projectId is required. Set MCP_USE_OAUTH_SUPABASE_PROJECT_ID environment variable or pass projectId in config."
    );
  }
  return new SupabaseOAuthProvider({
    provider: "supabase",
    projectId,
    jwtSecret,
    skipVerification: config.skipVerification
  });
}
__name(oauthSupabaseProvider, "oauthSupabaseProvider");
function oauthAuth0Provider(config = {}) {
  const domain = config.domain ?? getEnv("MCP_USE_OAUTH_AUTH0_DOMAIN");
  const audience = config.audience ?? getEnv("MCP_USE_OAUTH_AUTH0_AUDIENCE");
  if (!domain) {
    throw new Error(
      "Auth0 domain is required. Set MCP_USE_OAUTH_AUTH0_DOMAIN environment variable or pass domain in config."
    );
  }
  if (!audience) {
    throw new Error(
      "Auth0 audience is required. Set MCP_USE_OAUTH_AUTH0_AUDIENCE environment variable or pass audience in config."
    );
  }
  return new Auth0OAuthProvider({
    provider: "auth0",
    domain,
    audience,
    verifyJwt: config.verifyJwt
  });
}
__name(oauthAuth0Provider, "oauthAuth0Provider");
function oauthKeycloakProvider(config = {}) {
  const serverUrl = config.serverUrl ?? getEnv("MCP_USE_OAUTH_KEYCLOAK_SERVER_URL");
  const realm = config.realm ?? getEnv("MCP_USE_OAUTH_KEYCLOAK_REALM");
  const clientId = config.clientId ?? getEnv("MCP_USE_OAUTH_KEYCLOAK_CLIENT_ID");
  if (!serverUrl) {
    throw new Error(
      "Keycloak serverUrl is required. Set MCP_USE_OAUTH_KEYCLOAK_SERVER_URL environment variable or pass serverUrl in config."
    );
  }
  if (!realm) {
    throw new Error(
      "Keycloak realm is required. Set MCP_USE_OAUTH_KEYCLOAK_REALM environment variable or pass realm in config."
    );
  }
  return new KeycloakOAuthProvider({
    provider: "keycloak",
    serverUrl,
    realm,
    clientId,
    verifyJwt: config.verifyJwt
  });
}
__name(oauthKeycloakProvider, "oauthKeycloakProvider");
function oauthWorkOSProvider(config = {}) {
  const subdomain = config.subdomain ?? getEnv("MCP_USE_OAUTH_WORKOS_SUBDOMAIN");
  const clientId = config.clientId ?? getEnv("MCP_USE_OAUTH_WORKOS_CLIENT_ID");
  const apiKey = config.apiKey ?? getEnv("MCP_USE_OAUTH_WORKOS_API_KEY");
  if (!subdomain) {
    throw new Error(
      "WorkOS subdomain is required. Set MCP_USE_OAUTH_WORKOS_SUBDOMAIN environment variable or pass subdomain in config."
    );
  }
  if (clientId) {
    console.log("[WorkOS OAuth] Using pre-registered OAuth client mode");
    console.log(`[WorkOS OAuth]   - Client ID: ${clientId}`);
    console.log(
      "[WorkOS OAuth]   - Make sure this client exists in WorkOS Dashboard"
    );
    console.log(
      "[WorkOS OAuth]   - Configure redirect URIs to match your MCP client"
    );
  } else {
    console.log("[WorkOS OAuth] Using Dynamic Client Registration (DCR) mode");
    console.log(
      "[WorkOS OAuth]   - MCP clients will register themselves automatically"
    );
    console.log(
      "[WorkOS OAuth]   - Make sure DCR is enabled in WorkOS Dashboard"
    );
  }
  return new WorkOSOAuthProvider({
    provider: "workos",
    subdomain,
    clientId,
    apiKey,
    verifyJwt: config.verifyJwt
  });
}
__name(oauthWorkOSProvider, "oauthWorkOSProvider");
function oauthCustomProvider(config) {
  return new CustomOAuthProvider({
    provider: "custom",
    ...config
  });
}
__name(oauthCustomProvider, "oauthCustomProvider");

// src/server/oauth/utils.ts
function getAuth(context) {
  return context.get("auth");
}
__name(getAuth, "getAuth");
function hasScope(context, needed) {
  const { scopes, permissions } = getAuth(context);
  const requiredScopes = Array.isArray(needed) ? needed : [needed];
  return requiredScopes.every(
    (scope) => scopes.includes(scope) || permissions.includes(scope)
  );
}
__name(hasScope, "hasScope");
function hasAnyScope(context, needed) {
  const { scopes, permissions } = getAuth(context);
  return needed.some(
    (scope) => scopes.includes(scope) || permissions.includes(scope)
  );
}
__name(hasAnyScope, "hasAnyScope");
function requireScope(needed) {
  return async (c, next) => {
    if (!hasScope(c, needed)) {
      const { scopes, permissions } = getAuth(c);
      const requiredScopes = Array.isArray(needed) ? needed : [needed];
      return c.json(
        {
          error: "insufficient_scope",
          required: requiredScopes,
          granted_scopes: scopes,
          granted_permissions: permissions,
          message: `Missing required scope(s): ${requiredScopes.join(", ")}`
        },
        403
      );
    }
    await next();
  };
}
__name(requireScope, "requireScope");
function requireAnyScope(needed) {
  return async (c, next) => {
    if (!hasAnyScope(c, needed)) {
      const { scopes, permissions } = getAuth(c);
      return c.json(
        {
          error: "insufficient_scope",
          required_any: needed,
          granted_scopes: scopes,
          granted_permissions: permissions,
          message: `Missing at least one required scope from: ${needed.join(", ")}`
        },
        403
      );
    }
    await next();
  };
}
__name(requireAnyScope, "requireAnyScope");
