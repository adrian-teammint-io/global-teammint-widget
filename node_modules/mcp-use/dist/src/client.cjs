"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/client.ts
var client_exports = {};
__export(client_exports, {
  BaseCodeExecutor: () => BaseCodeExecutor,
  E2BCodeExecutor: () => E2BCodeExecutor,
  MCPClient: () => MCPClient,
  MCPSession: () => MCPSession,
  VMCodeExecutor: () => VMCodeExecutor,
  isVMAvailable: () => isVMAvailable
});
module.exports = __toCommonJS(client_exports);
var import_node_fs2 = __toESM(require("fs"), 1);
var import_node_path = __toESM(require("path"), 1);

// src/logging.ts
async function getNodeModules() {
  if (typeof process !== "undefined" && process.platform) {
    try {
      const fs2 = await import("fs");
      const path2 = await import("path");
      return { fs: fs2.default, path: path2.default };
    } catch {
      return { fs: null, path: null };
    }
  }
  return { fs: null, path: null };
}
__name(getNodeModules, "getNodeModules");
var winston = null;
function loadWinstonSync() {
  if (typeof require !== "undefined") {
    try {
      winston = require("winston");
    } catch {
    }
  }
}
__name(loadWinstonSync, "loadWinstonSync");
async function getWinston() {
  if (!winston) {
    winston = await import("winston");
  }
  return winston;
}
__name(getWinston, "getWinston");
var DEFAULT_LOGGER_NAME = "mcp-use";
function isNodeJSEnvironment() {
  try {
    if (typeof navigator !== "undefined" && navigator.userAgent?.includes("Cloudflare-Workers")) {
      return false;
    }
    if (typeof globalThis.EdgeRuntime !== "undefined" || typeof globalThis.Deno !== "undefined") {
      return false;
    }
    const hasNodeGlobals = typeof process !== "undefined" && typeof process.platform !== "undefined" && typeof __dirname !== "undefined";
    return hasNodeGlobals;
  } catch {
    return false;
  }
}
__name(isNodeJSEnvironment, "isNodeJSEnvironment");
var SimpleConsoleLogger = class {
  static {
    __name(this, "SimpleConsoleLogger");
  }
  _level;
  name;
  constructor(name = DEFAULT_LOGGER_NAME, level = "info") {
    this.name = name;
    this._level = level;
  }
  shouldLog(level) {
    const levels = [
      "error",
      "warn",
      "info",
      "http",
      "verbose",
      "debug",
      "silly"
    ];
    const currentIndex = levels.indexOf(this._level);
    const messageIndex = levels.indexOf(level);
    return messageIndex <= currentIndex;
  }
  formatMessage(level, message) {
    const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", { hour12: false });
    return `${timestamp} [${this.name}] ${level}: ${message}`;
  }
  error(message) {
    if (this.shouldLog("error")) {
      console.error(this.formatMessage("error", message));
    }
  }
  warn(message) {
    if (this.shouldLog("warn")) {
      console.warn(this.formatMessage("warn", message));
    }
  }
  info(message) {
    if (this.shouldLog("info")) {
      console.info(this.formatMessage("info", message));
    }
  }
  debug(message) {
    if (this.shouldLog("debug")) {
      console.debug(this.formatMessage("debug", message));
    }
  }
  http(message) {
    if (this.shouldLog("http")) {
      console.log(this.formatMessage("http", message));
    }
  }
  verbose(message) {
    if (this.shouldLog("verbose")) {
      console.log(this.formatMessage("verbose", message));
    }
  }
  silly(message) {
    if (this.shouldLog("silly")) {
      console.log(this.formatMessage("silly", message));
    }
  }
  // Make it compatible with Winston interface
  get level() {
    return this._level;
  }
  set level(newLevel) {
    this._level = newLevel;
  }
};
function resolveLevel(env) {
  const envValue = typeof process !== "undefined" && process.env ? env : void 0;
  switch (envValue?.trim()) {
    case "2":
      return "debug";
    case "1":
      return "info";
    default:
      return "info";
  }
}
__name(resolveLevel, "resolveLevel");
var Logger = class {
  static {
    __name(this, "Logger");
  }
  static instances = {};
  static simpleInstances = {};
  static currentFormat = "minimal";
  static get(name = DEFAULT_LOGGER_NAME) {
    if (!isNodeJSEnvironment()) {
      if (!this.simpleInstances[name]) {
        const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
        this.simpleInstances[name] = new SimpleConsoleLogger(
          name,
          resolveLevel(debugEnv)
        );
      }
      return this.simpleInstances[name];
    }
    if (!this.instances[name]) {
      if (!winston) {
        throw new Error("Winston not loaded - call Logger.configure() first");
      }
      const { createLogger, format } = winston;
      const { combine, timestamp, label, colorize, splat } = format;
      this.instances[name] = createLogger({
        level: resolveLevel(process.env.DEBUG),
        format: combine(
          colorize(),
          splat(),
          label({ label: name }),
          timestamp({ format: "HH:mm:ss" }),
          this.getFormatter()
        ),
        transports: [new winston.transports.Console()]
      });
    }
    return this.instances[name];
  }
  static getFormatter() {
    if (!winston) {
      throw new Error("Winston not loaded");
    }
    const { format } = winston;
    const { printf } = format;
    const minimalFormatter = printf(({ level, message, label, timestamp }) => {
      return `${timestamp} [${label}] ${level}: ${message}`;
    });
    const detailedFormatter = printf(({ level, message, label, timestamp }) => {
      return `${timestamp} [${label}] ${level.toUpperCase()}: ${message}`;
    });
    const emojiFormatter = printf(({ level, message, label, timestamp }) => {
      return `${timestamp} [${label}] ${level.toUpperCase()}: ${message}`;
    });
    switch (this.currentFormat) {
      case "minimal":
        return minimalFormatter;
      case "detailed":
        return detailedFormatter;
      case "emoji":
        return emojiFormatter;
      default:
        return minimalFormatter;
    }
  }
  static async configure(options = {}) {
    const { level, console: console2 = true, file, format = "minimal" } = options;
    const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
    const resolvedLevel = level ?? resolveLevel(debugEnv);
    this.currentFormat = format;
    if (!isNodeJSEnvironment()) {
      Object.values(this.simpleInstances).forEach((logger2) => {
        logger2.level = resolvedLevel;
      });
      return;
    }
    await getWinston();
    if (!winston) {
      throw new Error("Failed to load winston");
    }
    const root = this.get();
    root.level = resolvedLevel;
    const winstonRoot = root;
    winstonRoot.clear();
    if (console2) {
      winstonRoot.add(new winston.transports.Console());
    }
    if (file) {
      const { fs: nodeFs, path: nodePath } = await getNodeModules();
      if (nodeFs && nodePath) {
        const dir = nodePath.dirname(nodePath.resolve(file));
        if (!nodeFs.existsSync(dir)) {
          nodeFs.mkdirSync(dir, { recursive: true });
        }
        winstonRoot.add(new winston.transports.File({ filename: file }));
      }
    }
    const { format: winstonFormat } = winston;
    const { combine, timestamp, label, colorize, splat } = winstonFormat;
    Object.values(this.instances).forEach((logger2) => {
      if (logger2 && "format" in logger2) {
        logger2.level = resolvedLevel;
        logger2.format = combine(
          colorize(),
          splat(),
          label({ label: DEFAULT_LOGGER_NAME }),
          timestamp({ format: "HH:mm:ss" }),
          this.getFormatter()
        );
      }
    });
  }
  static setDebug(enabled) {
    let level;
    if (enabled === 2 || enabled === true) level = "debug";
    else if (enabled === 1) level = "info";
    else level = "info";
    Object.values(this.simpleInstances).forEach((logger2) => {
      logger2.level = level;
    });
    Object.values(this.instances).forEach((logger2) => {
      if (logger2) {
        logger2.level = level;
      }
    });
    if (typeof process !== "undefined" && process.env) {
      process.env.DEBUG = enabled ? enabled === true ? "2" : String(enabled) : "0";
    }
  }
  static setFormat(format) {
    this.currentFormat = format;
    this.configure({ format });
  }
};
if (isNodeJSEnvironment()) {
  loadWinstonSync();
  if (winston) {
    Logger.configure();
  }
}
var logger = Logger.get();

// src/session.ts
var MCPSession = class {
  static {
    __name(this, "MCPSession");
  }
  connector;
  autoConnect;
  constructor(connector, autoConnect = true) {
    this.connector = connector;
    this.autoConnect = autoConnect;
  }
  async connect() {
    await this.connector.connect();
  }
  async disconnect() {
    await this.connector.disconnect();
  }
  async initialize() {
    if (!this.isConnected && this.autoConnect) {
      await this.connect();
    }
    await this.connector.initialize();
  }
  get isConnected() {
    return this.connector && this.connector.isClientConnected;
  }
  /**
   * Register an event handler for session events
   *
   * @param event - The event type to listen for
   * @param handler - The handler function to call when the event occurs
   *
   * @example
   * ```typescript
   * session.on("notification", async (notification) => {
   *   console.log(`Received: ${notification.method}`, notification.params);
   *
   *   if (notification.method === "notifications/tools/list_changed") {
   *     // Refresh tools list
   *   }
   * });
   * ```
   */
  on(event, handler) {
    if (event === "notification") {
      this.connector.onNotification(handler);
    }
  }
  /**
   * Set roots and notify the server.
   * Roots represent directories or files that the client has access to.
   *
   * @param roots - Array of Root objects with `uri` (must start with "file://") and optional `name`
   *
   * @example
   * ```typescript
   * await session.setRoots([
   *   { uri: "file:///home/user/project", name: "My Project" },
   *   { uri: "file:///home/user/data" }
   * ]);
   * ```
   */
  async setRoots(roots) {
    return this.connector.setRoots(roots);
  }
  /**
   * Get the current roots.
   */
  getRoots() {
    return this.connector.getRoots();
  }
  /**
   * Get the cached list of tools from the server.
   *
   * @returns Array of available tools
   *
   * @example
   * ```typescript
   * const tools = session.tools;
   * console.log(`Available tools: ${tools.map(t => t.name).join(", ")}`);
   * ```
   */
  get tools() {
    return this.connector.tools;
  }
  /**
   * List all available tools from the MCP server.
   * This method fetches fresh tools from the server, unlike the `tools` getter which returns cached tools.
   *
   * @param options - Optional request options
   * @returns Array of available tools
   *
   * @example
   * ```typescript
   * const tools = await session.listTools();
   * console.log(`Available tools: ${tools.map(t => t.name).join(", ")}`);
   * ```
   */
  async listTools(options) {
    return this.connector.listTools(options);
  }
  /**
   * Get the server capabilities advertised during initialization.
   *
   * @returns Server capabilities object
   */
  get serverCapabilities() {
    return this.connector.serverCapabilities;
  }
  /**
   * Get the server information (name and version).
   *
   * @returns Server info object or null if not available
   */
  get serverInfo() {
    return this.connector.serverInfo;
  }
  /**
   * Call a tool on the server.
   *
   * @param name - Name of the tool to call
   * @param args - Arguments to pass to the tool (defaults to empty object)
   * @param options - Optional request options (timeout, progress handlers, etc.)
   * @returns Result from the tool execution
   *
   * @example
   * ```typescript
   * const result = await session.callTool("add", { a: 5, b: 3 });
   * console.log(`Result: ${result.content[0].text}`);
   * ```
   */
  async callTool(name, args = {}, options) {
    return this.connector.callTool(name, args, options);
  }
  /**
   * List resources from the server with optional pagination.
   *
   * @param cursor - Optional cursor for pagination
   * @param options - Request options
   * @returns Resource list with optional nextCursor for pagination
   *
   * @example
   * ```typescript
   * const result = await session.listResources();
   * console.log(`Found ${result.resources.length} resources`);
   * ```
   */
  async listResources(cursor, options) {
    return this.connector.listResources(cursor, options);
  }
  /**
   * List all resources from the server, automatically handling pagination.
   *
   * @param options - Request options
   * @returns Complete list of all resources
   *
   * @example
   * ```typescript
   * const result = await session.listAllResources();
   * console.log(`Total resources: ${result.resources.length}`);
   * ```
   */
  async listAllResources(options) {
    return this.connector.listAllResources(options);
  }
  /**
   * List resource templates from the server.
   *
   * @param options - Request options
   * @returns List of available resource templates
   *
   * @example
   * ```typescript
   * const result = await session.listResourceTemplates();
   * console.log(`Available templates: ${result.resourceTemplates.length}`);
   * ```
   */
  async listResourceTemplates(options) {
    return this.connector.listResourceTemplates(options);
  }
  /**
   * Read a resource by URI.
   *
   * @param uri - URI of the resource to read
   * @param options - Request options
   * @returns Resource content
   *
   * @example
   * ```typescript
   * const resource = await session.readResource("file:///path/to/file.txt");
   * console.log(resource.contents);
   * ```
   */
  async readResource(uri, options) {
    return this.connector.readResource(uri, options);
  }
  /**
   * Subscribe to resource updates.
   *
   * @param uri - URI of the resource to subscribe to
   * @param options - Request options
   *
   * @example
   * ```typescript
   * await session.subscribeToResource("file:///path/to/file.txt");
   * // Now you'll receive notifications when this resource changes
   * ```
   */
  async subscribeToResource(uri, options) {
    return this.connector.subscribeToResource(uri, options);
  }
  /**
   * Unsubscribe from resource updates.
   *
   * @param uri - URI of the resource to unsubscribe from
   * @param options - Request options
   *
   * @example
   * ```typescript
   * await session.unsubscribeFromResource("file:///path/to/file.txt");
   * ```
   */
  async unsubscribeFromResource(uri, options) {
    return this.connector.unsubscribeFromResource(uri, options);
  }
  /**
   * List available prompts from the server.
   *
   * @returns List of available prompts
   *
   * @example
   * ```typescript
   * const result = await session.listPrompts();
   * console.log(`Available prompts: ${result.prompts.length}`);
   * ```
   */
  async listPrompts() {
    return this.connector.listPrompts();
  }
  /**
   * Get a specific prompt with arguments.
   *
   * @param name - Name of the prompt to get
   * @param args - Arguments for the prompt
   * @returns Prompt result
   *
   * @example
   * ```typescript
   * const prompt = await session.getPrompt("greeting", { name: "Alice" });
   * console.log(prompt.messages);
   * ```
   */
  async getPrompt(name, args) {
    return this.connector.getPrompt(name, args);
  }
  /**
   * Send a raw request through the client.
   *
   * @param method - MCP method name
   * @param params - Request parameters
   * @param options - Request options
   * @returns Response from the server
   *
   * @example
   * ```typescript
   * const result = await session.request("custom/method", { key: "value" });
   * ```
   */
  async request(method, params = null, options) {
    return this.connector.request(method, params, options);
  }
};

// src/telemetry/events.ts
var BaseTelemetryEvent = class {
  static {
    __name(this, "BaseTelemetryEvent");
  }
};
var MCPAgentExecutionEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "MCPAgentExecutionEvent");
  }
  get name() {
    return "mcp_agent_execution";
  }
  get properties() {
    return {
      // Core execution info
      execution_method: this.data.executionMethod,
      query: this.data.query,
      query_length: this.data.query.length,
      success: this.data.success,
      // Agent configuration
      model_provider: this.data.modelProvider,
      model_name: this.data.modelName,
      server_count: this.data.serverCount,
      server_identifiers: this.data.serverIdentifiers,
      total_tools_available: this.data.totalToolsAvailable,
      tools_available_names: this.data.toolsAvailableNames,
      max_steps_configured: this.data.maxStepsConfigured,
      memory_enabled: this.data.memoryEnabled,
      use_server_manager: this.data.useServerManager,
      // Execution parameters (always include, even if null)
      max_steps_used: this.data.maxStepsUsed,
      manage_connector: this.data.manageConnector,
      external_history_used: this.data.externalHistoryUsed,
      // Execution results (always include, even if null)
      steps_taken: this.data.stepsTaken ?? null,
      tools_used_count: this.data.toolsUsedCount ?? null,
      tools_used_names: this.data.toolsUsedNames ?? null,
      response: this.data.response ?? null,
      response_length: this.data.response ? this.data.response.length : null,
      execution_time_ms: this.data.executionTimeMs ?? null,
      error_type: this.data.errorType ?? null,
      conversation_history_length: this.data.conversationHistoryLength ?? null
    };
  }
};
function createServerRunEventData(server, transport) {
  const toolRegistrations = Array.from(server.registrations.tools.values());
  const promptRegistrations = Array.from(server.registrations.prompts.values());
  const resourceRegistrations = Array.from(
    server.registrations.resources.values()
  );
  const templateRegistrations = Array.from(
    server.registrations.resourceTemplates.values()
  );
  const allResources = resourceRegistrations.map((r) => ({
    name: r.config.name,
    title: r.config.title ?? null,
    description: r.config.description ?? null,
    uri: r.config.uri ?? null,
    mime_type: r.config.mimeType ?? null
  }));
  const appsSdkResources = allResources.filter(
    (r) => r.mime_type === "text/html+skybridge"
  );
  const mcpUiResources = allResources.filter(
    (r) => r.mime_type === "text/uri-list" || r.mime_type === "text/html"
  );
  const mcpAppsResources = allResources.filter(
    (r) => r.mime_type === "text/html+mcp"
  );
  return {
    transport,
    toolsNumber: server.registeredTools.length,
    resourcesNumber: server.registeredResources.length,
    promptsNumber: server.registeredPrompts.length,
    auth: !!server.oauthProvider,
    name: server.config.name,
    description: server.config.description ?? null,
    baseUrl: server.serverBaseUrl ?? null,
    toolNames: server.registeredTools.length > 0 ? server.registeredTools : null,
    resourceNames: server.registeredResources.length > 0 ? server.registeredResources : null,
    promptNames: server.registeredPrompts.length > 0 ? server.registeredPrompts : null,
    tools: toolRegistrations.length > 0 ? toolRegistrations.map((r) => ({
      name: r.config.name,
      title: r.config.title ?? null,
      description: r.config.description ?? null,
      input_schema: r.config.schema ? JSON.stringify(r.config.schema) : null,
      output_schema: r.config.outputSchema ? JSON.stringify(r.config.outputSchema) : null
    })) : null,
    resources: allResources.length > 0 ? allResources : null,
    prompts: promptRegistrations.length > 0 ? promptRegistrations.map((r) => ({
      name: r.config.name,
      title: r.config.title ?? null,
      description: r.config.description ?? null,
      args: r.config.args ? JSON.stringify(r.config.args) : null
    })) : null,
    templates: templateRegistrations.length > 0 ? templateRegistrations.map((r) => ({
      name: r.config.name,
      title: r.config.title ?? null,
      description: r.config.description ?? null
    })) : null,
    capabilities: {
      logging: true,
      resources: { subscribe: true, listChanged: true }
    },
    appsSdkResources: appsSdkResources.length > 0 ? appsSdkResources : null,
    appsSdkResourcesNumber: appsSdkResources.length,
    mcpUiResources: mcpUiResources.length > 0 ? mcpUiResources : null,
    mcpUiResourcesNumber: mcpUiResources.length,
    mcpAppsResources: mcpAppsResources.length > 0 ? mcpAppsResources : null,
    mcpAppsResourcesNumber: mcpAppsResources.length
  };
}
__name(createServerRunEventData, "createServerRunEventData");
var ServerRunEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerRunEvent");
  }
  get name() {
    return "server_run";
  }
  get properties() {
    return {
      transport: this.data.transport,
      tools_number: this.data.toolsNumber,
      resources_number: this.data.resourcesNumber,
      prompts_number: this.data.promptsNumber,
      auth: this.data.auth,
      name: this.data.name,
      description: this.data.description ?? null,
      base_url: this.data.baseUrl ?? null,
      tool_names: this.data.toolNames ?? null,
      resource_names: this.data.resourceNames ?? null,
      prompt_names: this.data.promptNames ?? null,
      tools: this.data.tools ?? null,
      resources: this.data.resources ?? null,
      prompts: this.data.prompts ?? null,
      templates: this.data.templates ?? null,
      capabilities: this.data.capabilities ? JSON.stringify(this.data.capabilities) : null,
      apps_sdk_resources: this.data.appsSdkResources ? JSON.stringify(this.data.appsSdkResources) : null,
      apps_sdk_resources_number: this.data.appsSdkResourcesNumber ?? 0,
      mcp_ui_resources: this.data.mcpUiResources ? JSON.stringify(this.data.mcpUiResources) : null,
      mcp_ui_resources_number: this.data.mcpUiResourcesNumber ?? 0,
      mcp_apps_resources: this.data.mcpAppsResources ? JSON.stringify(this.data.mcpAppsResources) : null,
      mcp_apps_resources_number: this.data.mcpAppsResourcesNumber ?? 0
    };
  }
};
var ServerInitializeEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerInitializeEvent");
  }
  get name() {
    return "server_initialize_call";
  }
  get properties() {
    return {
      protocol_version: this.data.protocolVersion,
      client_info: JSON.stringify(this.data.clientInfo),
      client_capabilities: JSON.stringify(this.data.clientCapabilities),
      session_id: this.data.sessionId ?? null
    };
  }
};
var ServerToolCallEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerToolCallEvent");
  }
  get name() {
    return "server_tool_call";
  }
  get properties() {
    return {
      tool_name: this.data.toolName,
      length_input_argument: this.data.lengthInputArgument,
      success: this.data.success,
      error_type: this.data.errorType ?? null,
      execution_time_ms: this.data.executionTimeMs ?? null
    };
  }
};
var ServerResourceCallEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerResourceCallEvent");
  }
  get name() {
    return "server_resource_call";
  }
  get properties() {
    return {
      name: this.data.name,
      description: this.data.description,
      contents: this.data.contents,
      success: this.data.success,
      error_type: this.data.errorType ?? null
    };
  }
};
var ServerPromptCallEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerPromptCallEvent");
  }
  get name() {
    return "server_prompt_call";
  }
  get properties() {
    return {
      name: this.data.name,
      description: this.data.description,
      success: this.data.success,
      error_type: this.data.errorType ?? null
    };
  }
};
var ServerContextEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerContextEvent");
  }
  get name() {
    return `server_context_${this.data.contextType}`;
  }
  get properties() {
    return {
      context_type: this.data.contextType,
      notification_type: this.data.notificationType ?? null
    };
  }
};
var MCPClientInitEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "MCPClientInitEvent");
  }
  get name() {
    return "mcpclient_init";
  }
  get properties() {
    return {
      code_mode: this.data.codeMode,
      sandbox: this.data.sandbox,
      all_callbacks: this.data.allCallbacks,
      verify: this.data.verify,
      servers: this.data.servers,
      num_servers: this.data.numServers,
      is_browser: this.data.isBrowser
    };
  }
};
var ConnectorInitEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ConnectorInitEvent");
  }
  get name() {
    return "connector_init";
  }
  get properties() {
    return {
      connector_type: this.data.connectorType,
      server_command: this.data.serverCommand ?? null,
      server_args: this.data.serverArgs ?? null,
      server_url: this.data.serverUrl ?? null,
      public_identifier: this.data.publicIdentifier ?? null
    };
  }
};
var ClientAddServerEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ClientAddServerEvent");
  }
  get name() {
    return "client_add_server";
  }
  get properties() {
    const { serverName, serverConfig } = this.data;
    const url = serverConfig.url;
    return {
      server_name: serverName,
      server_url_domain: url ? this._extractHostname(url) : null,
      transport: serverConfig.transport ?? null,
      has_auth: !!(serverConfig.authToken || serverConfig.authProvider)
    };
  }
  _extractHostname(url) {
    try {
      return new URL(url).hostname;
    } catch {
      return null;
    }
  }
};
var ClientRemoveServerEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ClientRemoveServerEvent");
  }
  get name() {
    return "client_remove_server";
  }
  get properties() {
    return {
      server_name: this.data.serverName
    };
  }
};

// src/server/utils/runtime.ts
var isDeno = typeof globalThis.Deno !== "undefined";
function generateUUID() {
  return globalThis.crypto.randomUUID();
}
__name(generateUUID, "generateUUID");

// src/version.ts
var VERSION = "1.11.1";
function getPackageVersion() {
  return VERSION;
}
__name(getPackageVersion, "getPackageVersion");

// src/telemetry/telemetry.ts
function secureRandomString() {
  if (typeof window !== "undefined" && window.crypto && typeof window.crypto.getRandomValues === "function") {
    const array = new Uint8Array(8);
    window.crypto.getRandomValues(array);
    return Array.from(array, (v) => v.toString(16).padStart(2, "0")).join("");
  }
  try {
    const crypto = require("crypto");
    return crypto.randomBytes(8).toString("hex");
  } catch (e) {
    return Math.random().toString(36).substring(2, 15);
  }
}
__name(secureRandomString, "secureRandomString");
var USER_ID_STORAGE_KEY = "mcp_use_user_id";
function detectRuntimeEnvironment() {
  try {
    if (typeof globalThis.Bun !== "undefined") {
      return "bun";
    }
    if (typeof globalThis.Deno !== "undefined") {
      return "deno";
    }
    if (typeof navigator !== "undefined" && navigator.userAgent?.includes("Cloudflare-Workers")) {
      return "cloudflare-workers";
    }
    if (typeof globalThis.EdgeRuntime !== "undefined") {
      return "edge";
    }
    if (typeof window !== "undefined" && typeof document !== "undefined") {
      return "browser";
    }
    if (typeof process !== "undefined" && typeof process.versions?.node !== "undefined") {
      return "node";
    }
    return "unknown";
  } catch {
    return "unknown";
  }
}
__name(detectRuntimeEnvironment, "detectRuntimeEnvironment");
function getStorageCapability(env) {
  switch (env) {
    case "node":
    case "bun":
      return "filesystem";
    case "browser":
      try {
        if (typeof localStorage !== "undefined") {
          localStorage.setItem("__mcp_use_test__", "1");
          localStorage.removeItem("__mcp_use_test__");
          return "localStorage";
        }
      } catch {
      }
      return "session-only";
    case "deno":
      return "session-only";
    default:
      return "session-only";
  }
}
__name(getStorageCapability, "getStorageCapability");
var cachedEnvironment = null;
function getRuntimeEnvironment() {
  if (cachedEnvironment === null) {
    cachedEnvironment = detectRuntimeEnvironment();
  }
  return cachedEnvironment;
}
__name(getRuntimeEnvironment, "getRuntimeEnvironment");
var ScarfEventLogger = class {
  static {
    __name(this, "ScarfEventLogger");
  }
  endpoint;
  timeout;
  constructor(endpoint, timeout = 3e3) {
    this.endpoint = endpoint;
    this.timeout = timeout;
  }
  async logEvent(properties) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.timeout);
      const response = await fetch(this.endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(properties),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      logger.debug(`Failed to send Scarf event: ${error}`);
    }
  }
};
var Telemetry = class _Telemetry {
  static {
    __name(this, "Telemetry");
  }
  static instance = null;
  PROJECT_API_KEY = "phc_lyTtbYwvkdSbrcMQNPiKiiRWrrM1seyKIMjycSvItEI";
  HOST = "https://eu.i.posthog.com";
  SCARF_GATEWAY_URL = "https://mcpuse.gateway.scarf.sh/events-ts";
  UNKNOWN_USER_ID = "UNKNOWN_USER_ID";
  _currUserId = null;
  _posthogNodeClient = null;
  _posthogBrowserClient = null;
  _posthogLoading = null;
  _scarfClient = null;
  _runtimeEnvironment;
  _storageCapability;
  _source;
  // Node.js specific paths (lazily computed)
  _userIdPath = null;
  _versionDownloadPath = null;
  constructor() {
    this._runtimeEnvironment = getRuntimeEnvironment();
    this._storageCapability = getStorageCapability(this._runtimeEnvironment);
    this._source = typeof process !== "undefined" && process.env?.MCP_USE_TELEMETRY_SOURCE || this._runtimeEnvironment;
    const telemetryDisabled = this._checkTelemetryDisabled();
    const canSupportTelemetry = this._runtimeEnvironment !== "unknown";
    if (telemetryDisabled) {
      this._posthogNodeClient = null;
      this._posthogBrowserClient = null;
      this._scarfClient = null;
      logger.debug("Telemetry disabled via environment/localStorage");
    } else if (!canSupportTelemetry) {
      this._posthogNodeClient = null;
      this._posthogBrowserClient = null;
      this._scarfClient = null;
      logger.debug(
        `Telemetry disabled - unknown environment: ${this._runtimeEnvironment}`
      );
    } else {
      logger.info(
        "Anonymized telemetry enabled. Set MCP_USE_ANONYMIZED_TELEMETRY=false to disable."
      );
      this._posthogLoading = this._initPostHog();
      if (this._runtimeEnvironment !== "browser") {
        try {
          this._scarfClient = new ScarfEventLogger(
            this.SCARF_GATEWAY_URL,
            3e3
          );
        } catch (e) {
          logger.warn(`Failed to initialize Scarf telemetry: ${e}`);
          this._scarfClient = null;
        }
      } else {
        this._scarfClient = null;
      }
      if (this._storageCapability === "filesystem" && this._scarfClient) {
        setTimeout(() => {
          this.trackPackageDownload({ triggered_by: "initialization" }).catch(
            (e) => logger.debug(`Failed to track package download: ${e}`)
          );
        }, 0);
      }
    }
  }
  _checkTelemetryDisabled() {
    if (typeof process !== "undefined" && process.env?.MCP_USE_ANONYMIZED_TELEMETRY?.toLowerCase() === "false") {
      return true;
    }
    if (typeof localStorage !== "undefined" && localStorage.getItem("MCP_USE_ANONYMIZED_TELEMETRY") === "false") {
      return true;
    }
    return false;
  }
  async _initPostHog() {
    const isBrowser = this._runtimeEnvironment === "browser";
    if (isBrowser) {
      await this._initPostHogBrowser();
    } else {
      await this._initPostHogNode();
    }
  }
  async _initPostHogBrowser() {
    try {
      const posthogModule = await import("posthog-js");
      const posthog = posthogModule.default || posthogModule.posthog;
      if (!posthog || typeof posthog.init !== "function") {
        throw new Error("posthog-js module did not export expected interface");
      }
      posthog.init(this.PROJECT_API_KEY, {
        api_host: this.HOST,
        persistence: "localStorage",
        autocapture: false,
        // We only want explicit captures
        capture_pageview: false,
        // We don't want automatic pageview tracking
        disable_session_recording: true,
        // No session recording
        loaded: /* @__PURE__ */ __name(() => {
          logger.debug("PostHog browser client initialized");
        }, "loaded")
      });
      this._posthogBrowserClient = posthog;
    } catch (e) {
      logger.warn(`Failed to initialize PostHog browser telemetry: ${e}`);
      this._posthogBrowserClient = null;
    }
  }
  async _initPostHogNode() {
    try {
      const { PostHog } = await import("posthog-node");
      const isServerlessEnvironment = [
        "cloudflare-workers",
        "edge",
        "deno"
      ].includes(this._runtimeEnvironment);
      const posthogOptions = {
        host: this.HOST,
        disableGeoip: false
      };
      if (isServerlessEnvironment) {
        posthogOptions.flushAt = 1;
        posthogOptions.flushInterval = 0;
      }
      this._posthogNodeClient = new PostHog(
        this.PROJECT_API_KEY,
        posthogOptions
      );
      logger.debug("PostHog Node.js client initialized");
    } catch (e) {
      logger.warn(`Failed to initialize PostHog Node.js telemetry: ${e}`);
      this._posthogNodeClient = null;
    }
  }
  /**
   * Get the detected runtime environment
   */
  get runtimeEnvironment() {
    return this._runtimeEnvironment;
  }
  /**
   * Get the storage capability for this environment
   */
  get storageCapability() {
    return this._storageCapability;
  }
  static getInstance() {
    if (!_Telemetry.instance) {
      _Telemetry.instance = new _Telemetry();
    }
    return _Telemetry.instance;
  }
  /**
   * Set the source identifier for telemetry events.
   * This allows tracking usage from different applications.
   * @param source - The source identifier (e.g., "my-app", "cli", "vs-code-extension")
   */
  setSource(source) {
    this._source = source;
    logger.debug(`Telemetry source set to: ${source}`);
  }
  /**
   * Get the current source identifier.
   */
  getSource() {
    return this._source;
  }
  /**
   * Check if telemetry is enabled.
   */
  get isEnabled() {
    return this._posthogNodeClient !== null || this._posthogBrowserClient !== null || this._scarfClient !== null;
  }
  get userId() {
    if (this._currUserId) {
      return this._currUserId;
    }
    try {
      switch (this._storageCapability) {
        case "filesystem":
          this._currUserId = this._getUserIdFromFilesystem();
          break;
        case "localStorage":
          this._currUserId = this._getUserIdFromLocalStorage();
          break;
        case "session-only":
        default:
          try {
            this._currUserId = `session-${generateUUID()}`;
          } catch (uuidError) {
            this._currUserId = `session-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
          }
          break;
      }
    } catch (e) {
      this._currUserId = this.UNKNOWN_USER_ID;
    }
    return this._currUserId;
  }
  /**
   * Get or create user ID from filesystem (Node.js/Bun)
   * Falls back to session ID if filesystem operations fail
   */
  _getUserIdFromFilesystem() {
    try {
      let fs2, os, path2;
      try {
        fs2 = require("fs");
        os = require("os");
        path2 = require("path");
      } catch (requireError) {
        try {
          const sessionId = `session-${generateUUID()}`;
          return sessionId;
        } catch (uuidError) {
          return `session-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
        }
      }
      if (!this._userIdPath) {
        this._userIdPath = path2.join(
          this._getCacheHome(os, path2),
          "mcp_use_3",
          "telemetry_user_id"
        );
      }
      const isFirstTime = !fs2.existsSync(this._userIdPath);
      if (isFirstTime) {
        fs2.mkdirSync(path2.dirname(this._userIdPath), { recursive: true });
        let newUserId;
        try {
          newUserId = generateUUID();
        } catch (uuidError) {
          newUserId = `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
        }
        fs2.writeFileSync(this._userIdPath, newUserId);
        return newUserId;
      }
      const userId = fs2.readFileSync(this._userIdPath, "utf-8").trim();
      return userId;
    } catch (e) {
      try {
        return `session-${generateUUID()}`;
      } catch (uuidError) {
        return `session-${Date.now()}-${secureRandomString()}`;
      }
    }
  }
  /**
   * Get or create user ID from localStorage (Browser)
   */
  _getUserIdFromLocalStorage() {
    try {
      let userId = localStorage.getItem(USER_ID_STORAGE_KEY);
      if (!userId) {
        try {
          userId = generateUUID();
        } catch (uuidError) {
          userId = `${Date.now()}-${secureRandomString()}`;
        }
        localStorage.setItem(USER_ID_STORAGE_KEY, userId);
      }
      return userId;
    } catch (e) {
      let sessionId;
      try {
        sessionId = `session-${generateUUID()}`;
      } catch (uuidError) {
        sessionId = `session-${Date.now()}-${secureRandomString()}`;
      }
      return sessionId;
    }
  }
  _getCacheHome(os, path2) {
    const envVar = process.env.XDG_CACHE_HOME;
    if (envVar && path2.isAbsolute(envVar)) {
      return envVar;
    }
    const platform = process.platform;
    const homeDir = os.homedir();
    if (platform === "win32") {
      const appdata = process.env.LOCALAPPDATA || process.env.APPDATA;
      if (appdata) {
        return appdata;
      }
      return path2.join(homeDir, "AppData", "Local");
    } else if (platform === "darwin") {
      return path2.join(homeDir, "Library", "Caches");
    } else {
      return path2.join(homeDir, ".cache");
    }
  }
  async capture(event) {
    if (this._posthogLoading) {
      await this._posthogLoading;
    }
    if (!this._posthogNodeClient && !this._posthogBrowserClient && !this._scarfClient) {
      return;
    }
    const currentUserId = this.userId;
    const properties = { ...event.properties };
    properties.mcp_use_version = getPackageVersion();
    properties.language = "typescript";
    properties.source = this._source;
    properties.runtime = this._runtimeEnvironment;
    if (this._posthogNodeClient) {
      try {
        this._posthogNodeClient.capture({
          distinctId: currentUserId,
          event: event.name,
          properties
        });
      } catch (e) {
        logger.debug(`Failed to track PostHog Node event ${event.name}: ${e}`);
      }
    }
    if (this._posthogBrowserClient) {
      try {
        this._posthogBrowserClient.capture(event.name, {
          ...properties,
          distinct_id: currentUserId
        });
      } catch (e) {
        logger.debug(
          `Failed to track PostHog Browser event ${event.name}: ${e}`
        );
      }
    }
    if (this._scarfClient) {
      try {
        const scarfProperties = {
          ...properties,
          user_id: currentUserId,
          event: event.name
        };
        await this._scarfClient.logEvent(scarfProperties);
      } catch (e) {
        logger.debug(`Failed to track Scarf event ${event.name}: ${e}`);
      }
    }
  }
  // ============================================================================
  // Package Download Tracking (Node.js only)
  // ============================================================================
  /**
   * Track package download event.
   * This is a public wrapper that safely accesses userId.
   */
  async trackPackageDownload(properties) {
    return this._trackPackageDownloadInternal(this.userId, properties);
  }
  /**
   * Internal method to track package download with explicit userId.
   */
  async _trackPackageDownloadInternal(userId, properties) {
    if (!this._scarfClient) {
      return;
    }
    if (this._storageCapability !== "filesystem") {
      return;
    }
    try {
      const fs2 = require("fs");
      const path2 = require("path");
      const os = require("os");
      if (!this._versionDownloadPath) {
        this._versionDownloadPath = path2.join(
          this._getCacheHome(os, path2),
          "mcp_use",
          "download_version"
        );
      }
      const currentVersion = getPackageVersion();
      let shouldTrack = false;
      let firstDownload = false;
      if (!fs2.existsSync(this._versionDownloadPath)) {
        shouldTrack = true;
        firstDownload = true;
        fs2.mkdirSync(path2.dirname(this._versionDownloadPath), {
          recursive: true
        });
        fs2.writeFileSync(this._versionDownloadPath, currentVersion);
      } else {
        const savedVersion = fs2.readFileSync(this._versionDownloadPath, "utf-8").trim();
        if (currentVersion > savedVersion) {
          shouldTrack = true;
          firstDownload = false;
          fs2.writeFileSync(this._versionDownloadPath, currentVersion);
        }
      }
      if (shouldTrack) {
        logger.debug(
          `Tracking package download event with properties: ${JSON.stringify(properties)}`
        );
        const eventProperties = { ...properties || {} };
        eventProperties.mcp_use_version = currentVersion;
        eventProperties.user_id = userId;
        eventProperties.event = "package_download";
        eventProperties.first_download = firstDownload;
        eventProperties.language = "typescript";
        eventProperties.source = this._source;
        eventProperties.runtime = this._runtimeEnvironment;
        await this._scarfClient.logEvent(eventProperties);
      }
    } catch (e) {
      logger.debug(`Failed to track Scarf package_download event: ${e}`);
    }
  }
  // ============================================================================
  // Agent Events
  // ============================================================================
  async trackAgentExecution(data) {
    if (!this.isEnabled) return;
    const event = new MCPAgentExecutionEvent(data);
    await this.capture(event);
  }
  // ============================================================================
  // Server Events
  // ============================================================================
  /**
   * Track server run event directly from an MCPServer instance.
   */
  async trackServerRunFromServer(server, transport) {
    if (!this.isEnabled) return;
    const data = createServerRunEventData(server, transport);
    const event = new ServerRunEvent(data);
    await this.capture(event);
  }
  async trackServerInitialize(data) {
    if (!this.isEnabled) return;
    const event = new ServerInitializeEvent(data);
    await this.capture(event);
  }
  async trackServerToolCall(data) {
    if (!this.isEnabled) return;
    const event = new ServerToolCallEvent(data);
    await this.capture(event);
  }
  async trackServerResourceCall(data) {
    if (!this.isEnabled) return;
    const event = new ServerResourceCallEvent(data);
    await this.capture(event);
  }
  async trackServerPromptCall(data) {
    if (!this.isEnabled) return;
    const event = new ServerPromptCallEvent(data);
    await this.capture(event);
  }
  async trackServerContext(data) {
    if (!this.isEnabled) return;
    const event = new ServerContextEvent(data);
    await this.capture(event);
  }
  // ============================================================================
  // Client Events
  // ============================================================================
  async trackMCPClientInit(data) {
    if (!this.isEnabled) return;
    const event = new MCPClientInitEvent(data);
    await this.capture(event);
  }
  async trackConnectorInit(data) {
    if (!this.isEnabled) return;
    const event = new ConnectorInitEvent(data);
    await this.capture(event);
  }
  async trackClientAddServer(serverName, serverConfig) {
    if (!this.isEnabled) return;
    const event = new ClientAddServerEvent({ serverName, serverConfig });
    await this.capture(event);
  }
  async trackClientRemoveServer(serverName) {
    if (!this.isEnabled) return;
    const event = new ClientRemoveServerEvent({ serverName });
    await this.capture(event);
  }
  // ============================================================================
  // React Hook / Browser specific events
  // ============================================================================
  async trackUseMcpConnection(data) {
    if (!this.isEnabled) return;
    await this.capture({
      name: "usemcp_connection",
      properties: {
        url_domain: new URL(data.url).hostname,
        // Only domain for privacy
        transport_type: data.transportType,
        success: data.success,
        error_type: data.errorType ?? null,
        connection_time_ms: data.connectionTimeMs ?? null,
        has_oauth: data.hasOAuth,
        has_sampling: data.hasSampling,
        has_elicitation: data.hasElicitation
      }
    });
  }
  async trackUseMcpToolCall(data) {
    if (!this.isEnabled) return;
    await this.capture({
      name: "usemcp_tool_call",
      properties: {
        tool_name: data.toolName,
        success: data.success,
        error_type: data.errorType ?? null,
        execution_time_ms: data.executionTimeMs ?? null
      }
    });
  }
  async trackUseMcpResourceRead(data) {
    if (!this.isEnabled) return;
    await this.capture({
      name: "usemcp_resource_read",
      properties: {
        resource_uri_scheme: data.resourceUri.split(":")[0],
        // Only scheme for privacy
        success: data.success,
        error_type: data.errorType ?? null
      }
    });
  }
  // ============================================================================
  // Browser-specific Methods
  // ============================================================================
  /**
   * Identify the current user (useful for linking sessions)
   * Browser only - no-op in Node.js
   */
  identify(userId, properties) {
    if (this._posthogBrowserClient) {
      try {
        this._posthogBrowserClient.identify(userId, properties);
      } catch (e) {
        logger.debug(`Failed to identify user: ${e}`);
      }
    }
  }
  /**
   * Reset the user identity (useful for logout)
   * Browser only - no-op in Node.js
   */
  reset() {
    if (this._posthogBrowserClient) {
      try {
        this._posthogBrowserClient.reset();
      } catch (e) {
        logger.debug(`Failed to reset user: ${e}`);
      }
    }
    this._currUserId = null;
  }
  // ============================================================================
  // Node.js-specific Methods
  // ============================================================================
  /**
   * Flush the telemetry queue (Node.js only)
   */
  flush() {
    if (this._posthogNodeClient) {
      try {
        this._posthogNodeClient.flush();
        logger.debug("PostHog client telemetry queue flushed");
      } catch (e) {
        logger.debug(`Failed to flush PostHog client: ${e}`);
      }
    }
  }
  /**
   * Shutdown the telemetry client (Node.js only)
   */
  shutdown() {
    if (this._posthogNodeClient) {
      try {
        this._posthogNodeClient.shutdown();
        logger.debug("PostHog client shutdown successfully");
      } catch (e) {
        logger.debug(`Error shutting down PostHog client: ${e}`);
      }
    }
  }
};
var Tel = Telemetry;

// src/client/base.ts
var BaseMCPClient = class {
  static {
    __name(this, "BaseMCPClient");
  }
  config = {};
  sessions = {};
  activeSessions = [];
  constructor(config) {
    if (config) {
      this.config = config;
    }
  }
  static fromDict(_cfg) {
    throw new Error("fromDict must be implemented by concrete class");
  }
  addServer(name, serverConfig) {
    this.config.mcpServers = this.config.mcpServers || {};
    this.config.mcpServers[name] = serverConfig;
    Tel.getInstance().trackClientAddServer(name, serverConfig);
  }
  removeServer(name) {
    if (this.config.mcpServers?.[name]) {
      delete this.config.mcpServers[name];
      this.activeSessions = this.activeSessions.filter((n) => n !== name);
      Tel.getInstance().trackClientRemoveServer(name);
    }
  }
  getServerNames() {
    return Object.keys(this.config.mcpServers ?? {});
  }
  getServerConfig(name) {
    return this.config.mcpServers?.[name];
  }
  getConfig() {
    return this.config ?? {};
  }
  async createSession(serverName, autoInitialize = true) {
    const servers = this.config.mcpServers ?? {};
    if (Object.keys(servers).length === 0) {
      logger.warn("No MCP servers defined in config");
    }
    if (!servers[serverName]) {
      throw new Error(`Server '${serverName}' not found in config`);
    }
    const connector = this.createConnectorFromConfig(servers[serverName]);
    const session = new MCPSession(connector);
    if (autoInitialize) {
      await session.initialize();
    }
    this.sessions[serverName] = session;
    if (!this.activeSessions.includes(serverName)) {
      this.activeSessions.push(serverName);
    }
    return session;
  }
  async createAllSessions(autoInitialize = true) {
    const servers = this.config.mcpServers ?? {};
    if (Object.keys(servers).length === 0) {
      logger.warn("No MCP servers defined in config");
    }
    for (const name of Object.keys(servers)) {
      await this.createSession(name, autoInitialize);
    }
    return this.sessions;
  }
  getSession(serverName) {
    const session = this.sessions[serverName];
    if (!session) {
      return null;
    }
    return session;
  }
  requireSession(serverName) {
    const session = this.sessions[serverName];
    if (!session) {
      throw new Error(
        `Session '${serverName}' not found. Available sessions: ${this.activeSessions.join(", ") || "none"}`
      );
    }
    return session;
  }
  getAllActiveSessions() {
    return Object.fromEntries(
      this.activeSessions.map((n) => [n, this.sessions[n]])
    );
  }
  async closeSession(serverName) {
    const session = this.sessions[serverName];
    if (!session) {
      logger.warn(
        `No session exists for server ${serverName}, nothing to close`
      );
      return;
    }
    try {
      logger.debug(`Closing session for server ${serverName}`);
      await session.disconnect();
    } catch (e) {
      logger.error(`Error closing session for server '${serverName}': ${e}`);
    } finally {
      delete this.sessions[serverName];
      this.activeSessions = this.activeSessions.filter((n) => n !== serverName);
    }
  }
  async closeAllSessions() {
    const serverNames = Object.keys(this.sessions);
    const errors = [];
    for (const serverName of serverNames) {
      try {
        logger.debug(`Closing session for server ${serverName}`);
        await this.closeSession(serverName);
      } catch (e) {
        const errorMsg = `Failed to close session for server '${serverName}': ${e}`;
        logger.error(errorMsg);
        errors.push(errorMsg);
      }
    }
    if (errors.length) {
      logger.error(
        `Encountered ${errors.length} errors while closing sessions`
      );
    } else {
      logger.debug("All sessions closed successfully");
    }
  }
};

// src/client/executors/base.ts
var BaseCodeExecutor = class {
  static {
    __name(this, "BaseCodeExecutor");
  }
  client;
  _connecting = false;
  constructor(client) {
    this.client = client;
  }
  /**
   * Ensure all configured MCP servers are connected before execution.
   * Prevents race conditions with a connection lock.
   */
  async ensureServersConnected() {
    const configuredServers = this.client.getServerNames();
    const activeSessions = Object.keys(this.client.getAllActiveSessions());
    const missingServers = configuredServers.filter(
      (s) => !activeSessions.includes(s)
    );
    if (missingServers.length > 0 && !this._connecting) {
      this._connecting = true;
      try {
        logger.debug(
          `Connecting to configured servers for code execution: ${missingServers.join(", ")}`
        );
        await this.client.createAllSessions();
      } finally {
        this._connecting = false;
      }
    } else if (missingServers.length > 0 && this._connecting) {
      logger.debug("Waiting for ongoing server connection...");
      const startWait = Date.now();
      while (this._connecting && Date.now() - startWait < 5e3) {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    }
  }
  /**
   * Get tool namespace information from all active MCP sessions.
   * Filters out the internal code_mode server.
   */
  getToolNamespaces() {
    const namespaces = [];
    const activeSessions = this.client.getAllActiveSessions();
    for (const [serverName, session] of Object.entries(activeSessions)) {
      if (serverName === "code_mode") continue;
      try {
        const connector = session.connector;
        let tools;
        try {
          tools = connector.tools;
        } catch (e) {
          logger.warn(`Tools not available for server ${serverName}: ${e}`);
          continue;
        }
        if (!tools || tools.length === 0) continue;
        namespaces.push({ serverName, tools, session });
      } catch (e) {
        logger.warn(`Failed to load tools for server ${serverName}: ${e}`);
      }
    }
    return namespaces;
  }
  /**
   * Create a search function for discovering available MCP tools.
   * Used by code execution environments to find tools at runtime.
   */
  createSearchToolsFunction() {
    return async (query = "", detailLevel = "full") => {
      const allTools = [];
      const allNamespaces = /* @__PURE__ */ new Set();
      const queryLower = query.toLowerCase();
      const activeSessions = this.client.getAllActiveSessions();
      for (const [serverName, session] of Object.entries(activeSessions)) {
        if (serverName === "code_mode") continue;
        try {
          const tools = session.connector.tools;
          if (tools && tools.length > 0) {
            allNamespaces.add(serverName);
          }
          for (const tool of tools) {
            if (detailLevel === "names") {
              allTools.push({ name: tool.name, server: serverName });
            } else if (detailLevel === "descriptions") {
              allTools.push({
                name: tool.name,
                server: serverName,
                description: tool.description
              });
            } else {
              allTools.push({
                name: tool.name,
                server: serverName,
                description: tool.description,
                input_schema: tool.inputSchema
              });
            }
          }
        } catch (e) {
          logger.warn(`Failed to search tools in server ${serverName}: ${e}`);
        }
      }
      let filteredTools = allTools;
      if (query) {
        filteredTools = allTools.filter((tool) => {
          const nameMatch = tool.name.toLowerCase().includes(queryLower);
          const descMatch = tool.description?.toLowerCase().includes(queryLower);
          const serverMatch = tool.server.toLowerCase().includes(queryLower);
          return nameMatch || descMatch || serverMatch;
        });
      }
      return {
        meta: {
          total_tools: allTools.length,
          namespaces: Array.from(allNamespaces).sort(),
          result_count: filteredTools.length
        },
        results: filteredTools
      };
    };
  }
};

// src/client/executors/e2b.ts
var E2BCodeExecutor = class extends BaseCodeExecutor {
  static {
    __name(this, "E2BCodeExecutor");
  }
  e2bApiKey;
  codeExecSandbox = null;
  SandboxClass = null;
  timeoutMs;
  constructor(client, options) {
    super(client);
    this.e2bApiKey = options.apiKey;
    this.timeoutMs = options.timeoutMs ?? 3e5;
  }
  /**
   * Lazy load E2B Sandbox class.
   * This allows the library to work without E2B installed.
   */
  async ensureSandboxClass() {
    if (this.SandboxClass) return;
    try {
      const e2b = await import("@e2b/code-interpreter");
      this.SandboxClass = e2b.Sandbox;
    } catch (error) {
      throw new Error(
        "@e2b/code-interpreter is not installed. The E2B code executor requires this optional dependency. Install it with: yarn add @e2b/code-interpreter"
      );
    }
  }
  /**
   * Get or create a dedicated sandbox for code execution.
   */
  async getOrCreateCodeExecSandbox() {
    if (this.codeExecSandbox) return this.codeExecSandbox;
    await this.ensureSandboxClass();
    logger.debug("Starting E2B sandbox for code execution...");
    this.codeExecSandbox = await this.SandboxClass.create("base", {
      apiKey: this.e2bApiKey,
      timeoutMs: this.timeoutMs
    });
    return this.codeExecSandbox;
  }
  /**
   * Generate the shim code that exposes tools to the sandbox environment.
   * Creates a bridge that intercepts tool calls and sends them back to host.
   */
  generateShim(tools) {
    let shim = `
// MCP Bridge Shim
global.__callMcpTool = async (server, tool, args) => {
    const id = Math.random().toString(36).substring(7);
    console.log(JSON.stringify({
        type: '__MCP_TOOL_CALL__',
        id,
        server,
        tool,
        args
    }));
    
    const resultPath = \`/tmp/mcp_result_\${id}.json\`;
    const fs = require('fs');
    
    // Poll for result file
    let attempts = 0;
    while (attempts < 300) { // 30 seconds timeout
        if (fs.existsSync(resultPath)) {
            const content = fs.readFileSync(resultPath, 'utf8');
            const result = JSON.parse(content);
            fs.unlinkSync(resultPath); // Clean up
            
            if (result.error) {
                throw new Error(result.error);
            }
            return result.data;
        }
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
    }
    throw new Error('Tool execution timed out');
};

// Global search_tools helper
global.search_tools = async (query, detailLevel = 'full') => {
    const allTools = ${JSON.stringify(
      Object.entries(tools).flatMap(
        ([server, serverTools]) => serverTools.map((tool) => ({
          name: tool.name,
          description: tool.description,
          server,
          input_schema: tool.inputSchema
        }))
      )
    )};
    
    const filtered = allTools.filter(tool => {
        if (!query) return true;
        const q = query.toLowerCase();
        return tool.name.toLowerCase().includes(q) || 
               (tool.description && tool.description.toLowerCase().includes(q));
    });
    
    if (detailLevel === 'names') {
        return filtered.map(t => ({ name: t.name, server: t.server }));
    } else if (detailLevel === 'descriptions') {
        return filtered.map(t => ({ name: t.name, server: t.server, description: t.description }));
    }
    return filtered;
};
`;
    for (const [serverName, serverTools] of Object.entries(tools)) {
      if (!serverTools || serverTools.length === 0) continue;
      const safeServerName = serverName.replace(/[^a-zA-Z0-9_]/g, "_");
      shim += `
global['${serverName}'] = {`;
      for (const tool of serverTools) {
        shim += `
    '${tool.name}': async (args) => await global.__callMcpTool('${serverName}', '${tool.name}', args),`;
      }
      shim += `
};

// Also expose as safe name if different
if ('${safeServerName}' !== '${serverName}') {
    global['${safeServerName}'] = global['${serverName}'];
}
`;
    }
    return shim;
  }
  /**
   * Build the tool catalog for the shim.
   * Returns a map of server names to their available tools.
   */
  buildToolCatalog() {
    const catalog = {};
    const namespaces = this.getToolNamespaces();
    for (const { serverName, tools } of namespaces) {
      catalog[serverName] = tools;
    }
    return catalog;
  }
  /**
   * Execute JavaScript/TypeScript code in an E2B sandbox with MCP tool access.
   * Tool calls are proxied back to the host via the bridge pattern.
   *
   * @param code - Code to execute
   * @param timeout - Execution timeout in milliseconds (default: 30000)
   */
  async execute(code, timeout = 3e4) {
    const startTime = Date.now();
    let result = null;
    let error = null;
    let logs = [];
    try {
      await this.ensureServersConnected();
      const sandbox = await this.getOrCreateCodeExecSandbox();
      const toolCatalog = this.buildToolCatalog();
      const shim = this.generateShim(toolCatalog);
      const wrappedCode = `
${shim}

(async () => {
    try {
        const func = async () => {
            ${code}
        };
        const result = await func();
        console.log('__MCP_RESULT_START__');
        console.log(JSON.stringify(result));
        console.log('__MCP_RESULT_END__');
    } catch (e) {
        console.error(e);
        process.exit(1);
    }
})();
`;
      const filename = `exec_${Date.now()}.js`;
      await sandbox.files.write(filename, wrappedCode);
      const execution = await sandbox.commands.run(`node ${filename}`, {
        timeoutMs: timeout,
        onStdout: /* @__PURE__ */ __name(async (data) => {
          try {
            const lines = data.split("\n");
            for (const line of lines) {
              if (line.trim().startsWith('{"type":"__MCP_TOOL_CALL__"')) {
                const call = JSON.parse(line);
                if (call.type === "__MCP_TOOL_CALL__") {
                  try {
                    logger.debug(
                      `[E2B Bridge] Calling tool ${call.server}.${call.tool}`
                    );
                    const activeSessions = this.client.getAllActiveSessions();
                    const session = activeSessions[call.server];
                    if (!session) {
                      throw new Error(`Server ${call.server} not found`);
                    }
                    const toolResult = await session.connector.callTool(
                      call.tool,
                      call.args
                    );
                    let extractedResult = toolResult;
                    if (toolResult.content && toolResult.content.length > 0) {
                      const item = toolResult.content[0];
                      if (item.type === "text") {
                        try {
                          extractedResult = JSON.parse(item.text);
                        } catch {
                          extractedResult = item.text;
                        }
                      } else {
                        extractedResult = item;
                      }
                    }
                    const resultPath = `/tmp/mcp_result_${call.id}.json`;
                    await sandbox.files.write(
                      resultPath,
                      JSON.stringify({ data: extractedResult })
                    );
                  } catch (err) {
                    logger.error(
                      `[E2B Bridge] Tool execution failed: ${err.message}`
                    );
                    const resultPath = `/tmp/mcp_result_${call.id}.json`;
                    await sandbox.files.write(
                      resultPath,
                      JSON.stringify({
                        error: err.message || String(err)
                      })
                    );
                  }
                }
              }
            }
          } catch (e) {
          }
        }, "onStdout")
      });
      logs = [execution.stdout, execution.stderr].filter(Boolean);
      if (execution.exitCode !== 0) {
        error = execution.stderr || "Execution failed";
      } else {
        const stdout = execution.stdout;
        const startMarker = "__MCP_RESULT_START__";
        const endMarker = "__MCP_RESULT_END__";
        const startIndex = stdout.indexOf(startMarker);
        const endIndex = stdout.indexOf(endMarker);
        if (startIndex !== -1 && endIndex !== -1) {
          const jsonStr = stdout.substring(startIndex + startMarker.length, endIndex).trim();
          try {
            result = JSON.parse(jsonStr);
          } catch (e) {
            result = jsonStr;
          }
          logs = logs.map((log) => {
            let cleaned = log.replace(
              new RegExp(startMarker + "[\\s\\S]*?" + endMarker),
              "[Result captured]"
            );
            cleaned = cleaned.split("\n").filter((l) => !l.includes("__MCP_TOOL_CALL__")).join("\n");
            return cleaned;
          });
        }
      }
    } catch (e) {
      error = e.message || String(e);
      if (error && (error.includes("timeout") || error.includes("timed out"))) {
        error = "Script execution timed out";
      }
    }
    return {
      result,
      logs,
      error,
      execution_time: (Date.now() - startTime) / 1e3
    };
  }
  /**
   * Clean up the E2B sandbox.
   * Should be called when the executor is no longer needed.
   */
  async cleanup() {
    if (this.codeExecSandbox) {
      try {
        await this.codeExecSandbox.kill();
        this.codeExecSandbox = null;
        logger.debug("E2B code execution sandbox stopped");
      } catch (error) {
        logger.error("Failed to stop E2B code execution sandbox:", error);
      }
    }
  }
};

// src/client/executors/vm.ts
var vm = null;
var vmCheckAttempted = false;
function getVMModuleName() {
  return ["node", "vm"].join(":");
}
__name(getVMModuleName, "getVMModuleName");
function tryLoadVM() {
  if (vmCheckAttempted) {
    return vm !== null;
  }
  vmCheckAttempted = true;
  try {
    const nodeRequire = typeof require !== "undefined" ? require : null;
    if (nodeRequire) {
      vm = nodeRequire(getVMModuleName());
      return true;
    }
  } catch (error) {
    logger.debug("node:vm module not available via require");
  }
  return false;
}
__name(tryLoadVM, "tryLoadVM");
async function tryLoadVMAsync() {
  if (vm !== null) {
    return true;
  }
  if (!vmCheckAttempted) {
    if (tryLoadVM()) {
      return true;
    }
  }
  try {
    vm = await import(
      /* @vite-ignore */
      getVMModuleName()
    );
    return true;
  } catch (error) {
    logger.debug(
      "node:vm module not available in this environment (e.g., Deno)"
    );
    return false;
  }
}
__name(tryLoadVMAsync, "tryLoadVMAsync");
function isVMAvailable() {
  tryLoadVM();
  return vm !== null;
}
__name(isVMAvailable, "isVMAvailable");
var VMCodeExecutor = class extends BaseCodeExecutor {
  static {
    __name(this, "VMCodeExecutor");
  }
  defaultTimeout;
  memoryLimitMb;
  constructor(client, options) {
    super(client);
    this.defaultTimeout = options?.timeoutMs ?? 3e4;
    this.memoryLimitMb = options?.memoryLimitMb;
    tryLoadVM();
  }
  /**
   * Ensure VM module is loaded before execution
   */
  async ensureVMLoaded() {
    if (vm !== null) {
      return;
    }
    const loaded = await tryLoadVMAsync();
    if (!loaded) {
      throw new Error(
        "node:vm module is not available in this environment. Please use E2B executor instead or run in a Node.js environment."
      );
    }
  }
  /**
   * Execute JavaScript/TypeScript code with access to MCP tools.
   *
   * @param code - Code to execute
   * @param timeout - Execution timeout in milliseconds (default: configured timeout or 30000)
   */
  async execute(code, timeout) {
    const effectiveTimeout = timeout ?? this.defaultTimeout;
    await this.ensureVMLoaded();
    await this.ensureServersConnected();
    const logs = [];
    const startTime = Date.now();
    let result = null;
    let error = null;
    try {
      const context = await this._buildContext(logs);
      const wrappedCode = `
        (async () => {
          try {
            ${code}
          } catch (e) {
            throw e;
          }
        })()
      `;
      const script = new vm.Script(wrappedCode, {
        filename: "agent_code.js"
      });
      const promise = script.runInNewContext(context, {
        timeout: effectiveTimeout,
        displayErrors: true
      });
      result = await promise;
    } catch (e) {
      error = e.message || String(e);
      if (e.code === "ERR_SCRIPT_EXECUTION_TIMEOUT" || e.message === "Script execution timed out." || typeof error === "string" && (error.includes("timed out") || error.includes("timeout"))) {
        error = "Script execution timed out";
      }
      if (e.stack) {
        logger.debug(`Code execution error stack: ${e.stack}`);
      }
    }
    const executionTime = (Date.now() - startTime) / 1e3;
    return {
      result,
      logs,
      error,
      execution_time: executionTime
    };
  }
  /**
   * Build the VM execution context with MCP tools and standard globals.
   *
   * @param logs - Array to capture console output
   */
  async _buildContext(logs) {
    const logHandler = /* @__PURE__ */ __name((...args) => {
      logs.push(
        args.map(
          (arg) => typeof arg === "object" ? JSON.stringify(arg, null, 2) : String(arg)
        ).join(" ")
      );
    }, "logHandler");
    const sandbox = {
      console: {
        log: logHandler,
        error: /* @__PURE__ */ __name((...args) => {
          logHandler("[ERROR]", ...args);
        }, "error"),
        warn: /* @__PURE__ */ __name((...args) => {
          logHandler("[WARN]", ...args);
        }, "warn"),
        info: logHandler,
        debug: logHandler
      },
      // Standard globals
      Object,
      Array,
      String,
      Number,
      Boolean,
      Date,
      Math,
      JSON,
      RegExp,
      Map,
      Set,
      Promise,
      parseInt,
      parseFloat,
      isNaN,
      isFinite,
      encodeURI,
      decodeURI,
      encodeURIComponent,
      decodeURIComponent,
      setTimeout,
      clearTimeout,
      // Helper for tools
      search_tools: this.createSearchToolsFunction(),
      __tool_namespaces: []
    };
    const toolNamespaces = {};
    const namespaceInfos = this.getToolNamespaces();
    for (const { serverName, tools, session } of namespaceInfos) {
      const serverNamespace = {};
      for (const tool of tools) {
        const toolName = tool.name;
        serverNamespace[toolName] = async (args) => {
          const result = await session.connector.callTool(toolName, args || {});
          if (result.content && result.content.length > 0) {
            const item = result.content[0];
            if (item.type === "text") {
              try {
                return JSON.parse(item.text);
              } catch {
                return item.text;
              }
            }
            return item;
          }
          return result;
        };
      }
      sandbox[serverName] = serverNamespace;
      toolNamespaces[serverName] = true;
    }
    sandbox.__tool_namespaces = Object.keys(toolNamespaces);
    return vm.createContext(sandbox);
  }
  /**
   * Clean up resources.
   * VM executor doesn't need cleanup, but method kept for interface consistency.
   */
  async cleanup() {
  }
};

// src/connectors/base.ts
var import_types = require("@mcp-use/modelcontextprotocol-sdk/types.js");
var BaseConnector = class {
  static {
    __name(this, "BaseConnector");
  }
  client = null;
  connectionManager = null;
  toolsCache = null;
  capabilitiesCache = null;
  serverInfoCache = null;
  connected = false;
  opts;
  notificationHandlers = [];
  rootsCache = [];
  constructor(opts = {}) {
    this.opts = opts;
    if (opts.roots) {
      this.rootsCache = [...opts.roots];
    }
  }
  /**
   * Track connector initialization event
   * Should be called by subclasses after successful connection
   */
  trackConnectorInit(data) {
    const connectorType = this.constructor.name;
    Telemetry.getInstance().trackConnectorInit({
      connectorType,
      ...data
    }).catch((e) => logger.debug(`Failed to track connector init: ${e}`));
  }
  /**
   * Register a handler for server notifications
   *
   * @param handler - Function to call when a notification is received
   *
   * @example
   * ```typescript
   * connector.onNotification((notification) => {
   *   console.log(`Received: ${notification.method}`, notification.params);
   * });
   * ```
   */
  onNotification(handler) {
    this.notificationHandlers.push(handler);
    if (this.client) {
      this.setupNotificationHandler();
    }
  }
  /**
   * Internal: wire notification handlers to the SDK client
   * Includes automatic handling for list_changed notifications per MCP spec
   */
  setupNotificationHandler() {
    if (!this.client) return;
    this.client.fallbackNotificationHandler = async (notification) => {
      switch (notification.method) {
        case "notifications/tools/list_changed":
          await this.refreshToolsCache();
          break;
        case "notifications/resources/list_changed":
          await this.onResourcesListChanged();
          break;
        case "notifications/prompts/list_changed":
          await this.onPromptsListChanged();
          break;
        default:
          break;
      }
      for (const handler of this.notificationHandlers) {
        try {
          await handler(notification);
        } catch (err) {
          logger.error("Error in notification handler:", err);
        }
      }
    };
  }
  /**
   * Auto-refresh tools cache when server sends tools/list_changed notification
   */
  async refreshToolsCache() {
    if (!this.client) return;
    try {
      logger.debug(
        "[Auto] Refreshing tools cache due to list_changed notification"
      );
      const result = await this.client.listTools();
      this.toolsCache = result.tools ?? [];
      logger.debug(
        `[Auto] Refreshed tools cache: ${this.toolsCache.length} tools`
      );
    } catch (err) {
      logger.warn("[Auto] Failed to refresh tools cache:", err);
    }
  }
  /**
   * Called when server sends resources/list_changed notification
   * Resources aren't cached by default, but we log for user awareness
   */
  async onResourcesListChanged() {
    logger.debug(
      "[Auto] Resources list changed - clients should re-fetch if needed"
    );
  }
  /**
   * Called when server sends prompts/list_changed notification
   * Prompts aren't cached by default, but we log for user awareness
   */
  async onPromptsListChanged() {
    logger.debug(
      "[Auto] Prompts list changed - clients should re-fetch if needed"
    );
  }
  /**
   * Set roots and notify the server.
   * Roots represent directories or files that the client has access to.
   *
   * @param roots - Array of Root objects with `uri` (must start with "file://") and optional `name`
   *
   * @example
   * ```typescript
   * await connector.setRoots([
   *   { uri: "file:///home/user/project", name: "My Project" },
   *   { uri: "file:///home/user/data" }
   * ]);
   * ```
   */
  async setRoots(roots) {
    this.rootsCache = [...roots];
    if (this.client) {
      logger.debug(
        `Sending roots/list_changed notification with ${roots.length} root(s)`
      );
      await this.client.sendRootsListChanged();
    }
  }
  /**
   * Get the current roots.
   */
  getRoots() {
    return [...this.rootsCache];
  }
  /**
   * Internal: set up roots/list request handler.
   * This is called after the client connects to register the handler for server requests.
   */
  setupRootsHandler() {
    if (!this.client) return;
    this.client.setRequestHandler(
      import_types.ListRootsRequestSchema,
      async (_request, _extra) => {
        logger.debug(
          `Server requested roots list, returning ${this.rootsCache.length} root(s)`
        );
        return { roots: this.rootsCache };
      }
    );
  }
  /**
   * Internal: set up sampling/createMessage request handler.
   * This is called after the client connects to register the handler for sampling requests.
   */
  setupSamplingHandler() {
    if (!this.client) {
      logger.debug("setupSamplingHandler: No client available");
      return;
    }
    if (!this.opts.samplingCallback) {
      logger.debug("setupSamplingHandler: No sampling callback provided");
      return;
    }
    logger.debug("setupSamplingHandler: Setting up sampling request handler");
    this.client.setRequestHandler(
      import_types.CreateMessageRequestSchema,
      async (request, _extra) => {
        logger.debug("Server requested sampling, forwarding to callback");
        return await this.opts.samplingCallback(request.params);
      }
    );
    logger.debug(
      "setupSamplingHandler: Sampling handler registered successfully"
    );
  }
  /**
   * Internal: set up elicitation/create request handler.
   * This is called after the client connects to register the handler for elicitation requests.
   */
  setupElicitationHandler() {
    if (!this.client) {
      logger.debug("setupElicitationHandler: No client available");
      return;
    }
    if (!this.opts.elicitationCallback) {
      logger.debug("setupElicitationHandler: No elicitation callback provided");
      return;
    }
    logger.debug(
      "setupElicitationHandler: Setting up elicitation request handler"
    );
    this.client.setRequestHandler(
      import_types.ElicitRequestSchema,
      async (request, _extra) => {
        logger.debug("Server requested elicitation, forwarding to callback");
        return await this.opts.elicitationCallback(request.params);
      }
    );
    logger.debug(
      "setupElicitationHandler: Elicitation handler registered successfully"
    );
  }
  /** Disconnect and release resources. */
  async disconnect() {
    if (!this.connected) {
      logger.debug("Not connected to MCP implementation");
      return;
    }
    logger.debug("Disconnecting from MCP implementation");
    await this.cleanupResources();
    this.connected = false;
    logger.debug("Disconnected from MCP implementation");
  }
  /** Check if the client is connected */
  get isClientConnected() {
    return this.client != null;
  }
  /**
   * Initialise the MCP session **after** `connect()` has succeeded.
   *
   * In the SDK, `Client.connect(transport)` automatically performs the
   * protocollevel `initialize` handshake, so we only need to cache the list of
   * tools and expose some server info.
   */
  async initialize(defaultRequestOptions = this.opts.defaultRequestOptions ?? {}) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Caching server capabilities & tools");
    const capabilities = this.client.getServerCapabilities();
    this.capabilitiesCache = capabilities || null;
    const serverInfo = this.client.getServerVersion();
    this.serverInfoCache = serverInfo || null;
    const listToolsRes = await this.client.listTools(
      void 0,
      defaultRequestOptions
    );
    this.toolsCache = listToolsRes.tools ?? [];
    logger.debug(`Fetched ${this.toolsCache.length} tools from server`);
    logger.debug("Server capabilities:", capabilities);
    logger.debug("Server info:", serverInfo);
    return capabilities;
  }
  /** Lazily expose the cached tools list. */
  get tools() {
    if (!this.toolsCache) {
      throw new Error("MCP client is not initialized; call initialize() first");
    }
    return this.toolsCache;
  }
  /** Expose cached server capabilities. */
  get serverCapabilities() {
    return this.capabilitiesCache || {};
  }
  /** Expose cached server info. */
  get serverInfo() {
    return this.serverInfoCache;
  }
  /** Call a tool on the server. */
  async callTool(name, args, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    const enhancedOptions = options ? { ...options } : void 0;
    if (enhancedOptions?.resetTimeoutOnProgress && !enhancedOptions.onprogress) {
      enhancedOptions.onprogress = () => {
      };
      logger.debug(
        `[BaseConnector] Added onprogress callback for tool '${name}' to enable progressToken`
      );
    }
    logger.debug(`Calling tool '${name}' with args`, args);
    const res = await this.client.callTool(
      { name, arguments: args },
      void 0,
      enhancedOptions
    );
    logger.debug(`Tool '${name}' returned`, res);
    return res;
  }
  /**
   * List all available tools from the MCP server.
   * This method fetches fresh tools from the server, unlike the `tools` getter which returns cached tools.
   *
   * @param options - Optional request options
   * @returns Array of available tools
   */
  async listTools(options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    const result = await this.client.listTools(void 0, options);
    return result.tools ?? [];
  }
  /**
   * List resources from the server with optional pagination
   *
   * @param cursor - Optional cursor for pagination
   * @param options - Request options
   * @returns Resource list with optional nextCursor for pagination
   */
  async listResources(cursor, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Listing resources", cursor ? `with cursor: ${cursor}` : "");
    return await this.client.listResources({ cursor }, options);
  }
  /**
   * List all resources from the server, automatically handling pagination
   *
   * @param options - Request options
   * @returns Complete list of all resources
   */
  async listAllResources(options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    if (!this.capabilitiesCache?.resources) {
      logger.debug("Server does not advertise resources capability, skipping");
      return { resources: [] };
    }
    try {
      logger.debug("Listing all resources (with auto-pagination)");
      const allResources = [];
      let cursor = void 0;
      do {
        const result = await this.client.listResources({ cursor }, options);
        allResources.push(...result.resources || []);
        cursor = result.nextCursor;
      } while (cursor);
      return { resources: allResources };
    } catch (err) {
      const error = err;
      if (error.code === -32601) {
        logger.debug("Server advertised resources but method not found");
        return { resources: [] };
      }
      throw err;
    }
  }
  /**
   * List resource templates from the server
   *
   * @param options - Request options
   * @returns List of available resource templates
   */
  async listResourceTemplates(options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Listing resource templates");
    return await this.client.listResourceTemplates(void 0, options);
  }
  /** Read a resource by URI. */
  async readResource(uri, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Reading resource ${uri}`);
    const res = await this.client.readResource({ uri }, options);
    return res;
  }
  /**
   * Subscribe to resource updates
   *
   * @param uri - URI of the resource to subscribe to
   * @param options - Request options
   */
  async subscribeToResource(uri, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Subscribing to resource: ${uri}`);
    return await this.client.subscribeResource({ uri }, options);
  }
  /**
   * Unsubscribe from resource updates
   *
   * @param uri - URI of the resource to unsubscribe from
   * @param options - Request options
   */
  async unsubscribeFromResource(uri, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Unsubscribing from resource: ${uri}`);
    return await this.client.unsubscribeResource({ uri }, options);
  }
  async listPrompts() {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    if (!this.capabilitiesCache?.prompts) {
      logger.debug("Server does not advertise prompts capability, skipping");
      return { prompts: [] };
    }
    try {
      logger.debug("Listing prompts");
      return await this.client.listPrompts();
    } catch (err) {
      const error = err;
      if (error.code === -32601) {
        logger.debug("Server advertised prompts but method not found");
        return { prompts: [] };
      }
      throw err;
    }
  }
  async getPrompt(name, args) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Getting prompt ${name}`);
    return await this.client.getPrompt({ name, arguments: args });
  }
  /** Send a raw request through the client. */
  async request(method, params = null, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Sending raw request '${method}' with params`, params);
    return await this.client.request(
      { method, params: params ?? {} },
      void 0,
      options
    );
  }
  /**
   * Helper to tear down the client & connection manager safely.
   */
  async cleanupResources() {
    const issues = [];
    if (this.client) {
      try {
        if (typeof this.client.close === "function") {
          await this.client.close();
        }
      } catch (e) {
        const msg = `Error closing client: ${e}`;
        logger.warn(msg);
        issues.push(msg);
      } finally {
        this.client = null;
      }
    }
    if (this.connectionManager) {
      try {
        await this.connectionManager.stop();
      } catch (e) {
        const msg = `Error stopping connection manager: ${e}`;
        logger.warn(msg);
        issues.push(msg);
      } finally {
        this.connectionManager = null;
      }
    }
    this.toolsCache = null;
    if (issues.length) {
      logger.warn(`Resource cleanup finished with ${issues.length} issue(s)`);
    }
  }
};

// src/client/connectors/codeMode.ts
var CodeModeConnector = class extends BaseConnector {
  static {
    __name(this, "CodeModeConnector");
  }
  mcpClient;
  _tools;
  constructor(client) {
    super();
    this.mcpClient = client;
    this.connected = true;
    this._tools = this._createToolsList();
  }
  async connect() {
    this.connected = true;
  }
  async disconnect() {
    this.connected = false;
  }
  get publicIdentifier() {
    return { name: "code_mode", version: "1.0.0" };
  }
  _createToolsList() {
    return [
      {
        name: "execute_code",
        description: "Execute JavaScript/TypeScript code with access to MCP tools. This is the PRIMARY way to interact with MCP servers in code mode. Write code that discovers tools using search_tools(), calls tools as async functions (e.g., await github.get_pull_request(...)), processes data efficiently, and returns results. Use 'await' for async operations and 'return' to return values. Available in code: search_tools(), __tool_namespaces, and server.tool_name() functions.",
        inputSchema: {
          type: "object",
          properties: {
            code: {
              type: "string",
              description: "JavaScript/TypeScript code to execute. Use 'await' for async operations. Use 'return' to return a value. Available: search_tools(), server.tool_name(), __tool_namespaces"
            },
            timeout: {
              type: "number",
              description: "Execution timeout in milliseconds",
              default: 3e4
            }
          },
          required: ["code"]
        }
      },
      {
        name: "search_tools",
        description: "Search and discover available MCP tools across all servers. Use this to find out what tools are available before writing code. Returns tool information including names, descriptions, and schemas. Can filter by query and control detail level.",
        inputSchema: {
          type: "object",
          properties: {
            query: {
              type: "string",
              description: "Search query to filter tools by name or description",
              default: ""
            },
            detail_level: {
              type: "string",
              description: "Detail level: 'names', 'descriptions', or 'full'",
              enum: ["names", "descriptions", "full"],
              default: "full"
            }
          }
        }
      }
    ];
  }
  // Override tools getter to return static list immediately
  get tools() {
    return this._tools;
  }
  async initialize() {
    this.toolsCache = this._tools;
    return { capabilities: {}, version: "1.0.0" };
  }
  async callTool(name, args) {
    if (name === "execute_code") {
      const code = args.code;
      const timeout = args.timeout || 3e4;
      const result = await this.mcpClient.executeCode(code, timeout);
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result)
          }
        ]
      };
    } else if (name === "search_tools") {
      const query = args.query || "";
      const detailLevel = args.detail_level;
      const result = await this.mcpClient.searchTools(
        query,
        detailLevel && detailLevel in ["names", "descriptions", "full"] ? detailLevel : "full"
      );
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result)
          }
        ]
      };
    }
    throw new Error(`Unknown tool: ${name}`);
  }
};

// src/config.ts
var import_node_fs = require("fs");

// src/connectors/http.ts
var import_client = require("@mcp-use/modelcontextprotocol-sdk/client/index.js");
var import_streamableHttp = require("@mcp-use/modelcontextprotocol-sdk/client/streamableHttp.js");

// src/task_managers/sse.ts
var import_sse = require("@mcp-use/modelcontextprotocol-sdk/client/sse.js");

// src/task_managers/base.ts
var ConnectionManager = class {
  static {
    __name(this, "ConnectionManager");
  }
  _readyPromise;
  _readyResolver;
  _donePromise;
  _doneResolver;
  _exception = null;
  _connection = null;
  _task = null;
  _abortController = null;
  constructor() {
    this.reset();
  }
  /**
   * Start the connection manager and establish a connection.
   *
   * @returns The established connection.
   * @throws If the connection cannot be established.
   */
  async start() {
    this.reset();
    logger.debug(`Starting ${this.constructor.name}`);
    this._task = this.connectionTask();
    await this._readyPromise;
    if (this._exception) {
      throw this._exception;
    }
    if (this._connection === null) {
      throw new Error("Connection was not established");
    }
    return this._connection;
  }
  /**
   * Stop the connection manager and close the connection.
   */
  async stop() {
    if (this._task && this._abortController) {
      logger.debug(`Cancelling ${this.constructor.name} task`);
      this._abortController.abort();
      try {
        await this._task;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError") {
          logger.debug(`${this.constructor.name} task aborted successfully`);
        } else {
          logger.warn(`Error stopping ${this.constructor.name} task: ${e}`);
        }
      }
    }
    await this._donePromise;
    logger.debug(`${this.constructor.name} task completed`);
  }
  /**
   * Reset all internal state.
   */
  reset() {
    this._readyPromise = new Promise((res) => this._readyResolver = res);
    this._donePromise = new Promise((res) => this._doneResolver = res);
    this._exception = null;
    this._connection = null;
    this._task = null;
    this._abortController = new AbortController();
  }
  /**
   * The background task responsible for establishing and maintaining the
   * connection until it is cancelled.
   */
  async connectionTask() {
    logger.debug(`Running ${this.constructor.name} task`);
    try {
      this._connection = await this.establishConnection();
      logger.debug(`${this.constructor.name} connected successfully`);
      this._readyResolver();
      await this.waitForAbort();
    } catch (err) {
      this._exception = err;
      logger.error(`Error in ${this.constructor.name} task: ${err}`);
      this._readyResolver();
    } finally {
      if (this._connection !== null) {
        try {
          await this.closeConnection(this._connection);
        } catch (closeErr) {
          logger.warn(
            `Error closing connection in ${this.constructor.name}: ${closeErr}`
          );
        }
        this._connection = null;
      }
      this._doneResolver();
    }
  }
  /**
   * Helper that returns a promise which resolves when the abort signal fires.
   */
  async waitForAbort() {
    return new Promise((_resolve, _reject) => {
      if (!this._abortController) {
        return;
      }
      const signal = this._abortController.signal;
      if (signal.aborted) {
        _resolve();
        return;
      }
      const onAbort = /* @__PURE__ */ __name(() => {
        signal.removeEventListener("abort", onAbort);
        _resolve();
      }, "onAbort");
      signal.addEventListener("abort", onAbort);
    });
  }
};

// src/task_managers/sse.ts
var SseConnectionManager = class extends ConnectionManager {
  static {
    __name(this, "SseConnectionManager");
  }
  url;
  opts;
  _transport = null;
  reinitializing = false;
  /**
   * Create an SSE connection manager.
   *
   * @param url  The SSE endpoint URL.
   * @param opts Optional transport options (auth, headers, etc.).
   */
  constructor(url, opts) {
    super();
    this.url = typeof url === "string" ? new URL(url) : url;
    this.opts = opts;
  }
  /**
   * Spawn a new `SSEClientTransport` and wrap it with 404 handling.
   * Per MCP spec, clients MUST re-initialize when receiving 404 for stale sessions.
   */
  async establishConnection() {
    const transport = new import_sse.SSEClientTransport(this.url, this.opts);
    const originalSend = transport.send.bind(transport);
    transport.send = async (message) => {
      const sendMessage = /* @__PURE__ */ __name(async (msg) => {
        if (Array.isArray(msg)) {
          for (const singleMsg of msg) {
            await originalSend(singleMsg);
          }
        } else {
          await originalSend(msg);
        }
      }, "sendMessage");
      try {
        await sendMessage(message);
      } catch (error) {
        if (error?.code === 404 && transport.sessionId && !this.reinitializing) {
          logger.warn(
            `[SSE] Session not found (404), re-initializing per MCP spec...`
          );
          this.reinitializing = true;
          try {
            transport.sessionId = void 0;
            await this.reinitialize(transport);
            logger.info(`[SSE] Re-initialization successful, retrying request`);
            await sendMessage(message);
          } finally {
            this.reinitializing = false;
          }
        } else {
          throw error;
        }
      }
    };
    this._transport = transport;
    logger.debug(`${this.constructor.name} connected successfully`);
    return transport;
  }
  /**
   * Re-initialize the transport with a new session
   * This is called when the server returns 404 for a stale session
   */
  async reinitialize(transport) {
    logger.debug(`[SSE] Re-initialization triggered`);
  }
  /**
   * Close the underlying transport and clean up resources.
   */
  async closeConnection(_connection) {
    if (this._transport) {
      try {
        await this._transport.close();
      } catch (e) {
        logger.warn(`Error closing SSE transport: ${e}`);
      } finally {
        this._transport = null;
      }
    }
  }
};

// src/connectors/http.ts
var HttpConnector = class extends BaseConnector {
  static {
    __name(this, "HttpConnector");
  }
  baseUrl;
  headers;
  timeout;
  sseReadTimeout;
  clientInfo;
  preferSse;
  disableSseFallback;
  transportType = null;
  streamableTransport = null;
  constructor(baseUrl, opts = {}) {
    super(opts);
    this.baseUrl = baseUrl.replace(/\/$/, "");
    this.headers = { ...opts.headers ?? {} };
    if (opts.authToken) {
      this.headers.Authorization = `Bearer ${opts.authToken}`;
    }
    this.timeout = opts.timeout ?? 3e4;
    this.sseReadTimeout = opts.sseReadTimeout ?? 3e5;
    this.clientInfo = opts.clientInfo ?? {
      name: "http-connector",
      version: "1.0.0"
    };
    this.preferSse = opts.preferSse ?? false;
    this.disableSseFallback = opts.disableSseFallback ?? false;
  }
  /** Establish connection to the MCP implementation via HTTP (streamable or SSE). */
  async connect() {
    if (this.connected) {
      logger.debug("Already connected to MCP implementation");
      return;
    }
    const baseUrl = this.baseUrl;
    if (this.preferSse) {
      logger.debug(`Connecting to MCP implementation via HTTP/SSE: ${baseUrl}`);
      await this.connectWithSse(baseUrl);
      return;
    }
    logger.debug(`Connecting to MCP implementation via HTTP: ${baseUrl}`);
    try {
      logger.info("\u{1F504} Attempting streamable HTTP transport...");
      await this.connectWithStreamableHttp(baseUrl);
      logger.info("\u2705 Successfully connected via streamable HTTP");
    } catch (err) {
      let fallbackReason = "Unknown error";
      let is401Error = false;
      if (err instanceof import_streamableHttp.StreamableHTTPError) {
        const streamableErr = err;
        is401Error = streamableErr.code === 401;
        if (streamableErr.code === 400 && streamableErr.message.includes("Missing session ID")) {
          fallbackReason = "Server requires session ID (FastMCP compatibility) - using SSE transport";
          logger.warn(`\u26A0\uFE0F  ${fallbackReason}`);
        } else if (streamableErr.code === 404 || streamableErr.code === 405) {
          fallbackReason = `Server returned ${streamableErr.code} - server likely doesn't support streamable HTTP`;
          logger.debug(fallbackReason);
        } else {
          fallbackReason = `Server returned ${streamableErr.code}: ${streamableErr.message}`;
          logger.debug(fallbackReason);
        }
      } else if (err instanceof Error) {
        const errorStr = err.toString();
        const errorMsg = err.message || "";
        is401Error = errorStr.includes("401") || errorMsg.includes("Unauthorized");
        if (errorStr.includes("Missing session ID") || errorStr.includes("Bad Request: Missing session ID") || errorMsg.includes("FastMCP session ID error")) {
          fallbackReason = "Server requires session ID (FastMCP compatibility) - using SSE transport";
          logger.warn(`\u26A0\uFE0F  ${fallbackReason}`);
        } else if (errorStr.includes("405 Method Not Allowed") || errorStr.includes("404 Not Found")) {
          fallbackReason = "Server doesn't support streamable HTTP (405/404)";
          logger.debug(fallbackReason);
        } else {
          fallbackReason = `Streamable HTTP failed: ${err.message}`;
          logger.debug(fallbackReason);
        }
      }
      if (is401Error) {
        logger.info("Authentication required - skipping SSE fallback");
        await this.cleanupResources();
        const authError = new Error("Authentication required");
        authError.code = 401;
        throw authError;
      }
      if (this.disableSseFallback) {
        logger.info("SSE fallback disabled - failing connection");
        await this.cleanupResources();
        throw new Error(
          `Streamable HTTP connection failed: ${fallbackReason}. SSE fallback is disabled.`
        );
      }
      logger.info("\u{1F504} Falling back to SSE transport...");
      try {
        await this.connectWithSse(baseUrl);
      } catch (sseErr) {
        logger.error(`Failed to connect with both transports:`);
        logger.error(`  Streamable HTTP: ${fallbackReason}`);
        logger.error(`  SSE: ${sseErr}`);
        await this.cleanupResources();
        const sseIs401 = sseErr?.message?.includes("401") || sseErr?.message?.includes("Unauthorized");
        if (sseIs401) {
          const authError = new Error("Authentication required");
          authError.code = 401;
          throw authError;
        }
        throw new Error(
          "Could not connect to server with any available transport"
        );
      }
    }
  }
  async connectWithStreamableHttp(baseUrl) {
    try {
      const streamableTransport = new import_streamableHttp.StreamableHTTPClientTransport(
        new URL(baseUrl),
        {
          authProvider: this.opts.authProvider,
          //  Pass OAuth provider to SDK
          requestInit: {
            headers: this.headers
          },
          // Pass through reconnection options
          reconnectionOptions: {
            maxReconnectionDelay: 3e4,
            initialReconnectionDelay: 1e3,
            reconnectionDelayGrowFactor: 1.5,
            maxRetries: 2
          }
          // Don't pass sessionId - let the SDK generate it automatically during connect()
        }
      );
      let transport = streamableTransport;
      if (this.opts.wrapTransport) {
        const serverId = this.baseUrl;
        transport = this.opts.wrapTransport(
          transport,
          serverId
        );
      }
      const clientOptions = {
        ...this.opts.clientOptions || {},
        capabilities: {
          ...this.opts.clientOptions?.capabilities || {},
          roots: { listChanged: true },
          // Always advertise roots capability
          // Add sampling capability if callback is provided
          ...this.opts.samplingCallback ? { sampling: {} } : {},
          // Add elicitation capability if callback is provided
          ...this.opts.elicitationCallback ? { elicitation: { form: {}, url: {} } } : {}
        }
      };
      logger.debug(
        `Creating Client with capabilities:`,
        JSON.stringify(clientOptions.capabilities, null, 2)
      );
      this.client = new import_client.Client(this.clientInfo, clientOptions);
      this.setupRootsHandler();
      logger.debug("Roots handler registered before connect");
      try {
        await this.client.connect(transport, {
          timeout: Math.min(this.timeout, 3e3)
        });
        const sessionId = streamableTransport.sessionId;
        if (sessionId) {
          logger.debug(`Session ID obtained: ${sessionId}`);
        } else {
          logger.warn(
            "Session ID not available after connect - this may cause issues with SSE stream"
          );
        }
      } catch (connectErr) {
        if (connectErr instanceof Error) {
          const errMsg = connectErr.message || connectErr.toString();
          if (errMsg.includes("Missing session ID") || errMsg.includes("Bad Request: Missing session ID") || errMsg.includes("Mcp-Session-Id header is required")) {
            const wrappedError = new Error(
              `Session ID error: ${errMsg}. The SDK should automatically extract session ID from initialize response.`
            );
            wrappedError.cause = connectErr;
            throw wrappedError;
          }
        }
        throw connectErr;
      }
      this.streamableTransport = streamableTransport;
      this.connectionManager = {
        stop: /* @__PURE__ */ __name(async () => {
          if (this.streamableTransport) {
            try {
              await this.streamableTransport.terminateSession();
              await this.streamableTransport.close();
            } catch (e) {
              logger.warn(`Error closing Streamable HTTP transport: ${e}`);
            } finally {
              this.streamableTransport = null;
            }
          }
        }, "stop")
      };
      this.connected = true;
      this.transportType = "streamable-http";
      this.setupNotificationHandler();
      this.setupSamplingHandler();
      this.setupElicitationHandler();
      logger.debug(
        `Successfully connected to MCP implementation via streamable HTTP: ${baseUrl}`
      );
      this.trackConnectorInit({
        serverUrl: this.baseUrl,
        publicIdentifier: `${this.baseUrl} (streamable-http)`
      });
    } catch (err) {
      await this.cleanupResources();
      throw err;
    }
  }
  async connectWithSse(baseUrl) {
    try {
      this.connectionManager = new SseConnectionManager(baseUrl, {
        authProvider: this.opts.authProvider,
        //  Pass OAuth provider to SDK (same as streamable HTTP)
        requestInit: {
          headers: this.headers
        }
      });
      let transport = await this.connectionManager.start();
      if (this.opts.wrapTransport) {
        const serverId = this.baseUrl;
        transport = this.opts.wrapTransport(transport, serverId);
      }
      const clientOptions = {
        ...this.opts.clientOptions || {},
        capabilities: {
          ...this.opts.clientOptions?.capabilities || {},
          roots: { listChanged: true },
          // Always advertise roots capability
          // Add sampling capability if callback is provided
          ...this.opts.samplingCallback ? { sampling: {} } : {},
          // Add elicitation capability if callback is provided
          ...this.opts.elicitationCallback ? { elicitation: { form: {}, url: {} } } : {}
        }
      };
      logger.debug(
        `Creating Client with capabilities (SSE):`,
        JSON.stringify(clientOptions.capabilities, null, 2)
      );
      this.client = new import_client.Client(this.clientInfo, clientOptions);
      this.setupRootsHandler();
      logger.debug("Roots handler registered before connect (SSE)");
      await this.client.connect(transport);
      this.connected = true;
      this.transportType = "sse";
      this.setupNotificationHandler();
      this.setupSamplingHandler();
      this.setupElicitationHandler();
      logger.debug(
        `Successfully connected to MCP implementation via HTTP/SSE: ${baseUrl}`
      );
      this.trackConnectorInit({
        serverUrl: this.baseUrl,
        publicIdentifier: `${this.baseUrl} (sse)`
      });
    } catch (err) {
      await this.cleanupResources();
      throw err;
    }
  }
  get publicIdentifier() {
    return {
      type: "http",
      url: this.baseUrl,
      transport: this.transportType || "unknown"
    };
  }
  /**
   * Get the transport type being used (streamable-http or sse)
   */
  getTransportType() {
    return this.transportType;
  }
};

// src/connectors/stdio.ts
var import_node_process = __toESM(require("process"), 1);
var import_client2 = require("@mcp-use/modelcontextprotocol-sdk/client/index.js");

// src/task_managers/stdio.ts
var import_stdio = require("@mcp-use/modelcontextprotocol-sdk/client/stdio.js");
var StdioConnectionManager = class extends ConnectionManager {
  static {
    __name(this, "StdioConnectionManager");
  }
  serverParams;
  errlog;
  _transport = null;
  /**
   * Create a new stdio connection manager.
   *
   * @param serverParams Parameters for the stdio server process.
   * @param errlog       Stream to which the server's stderr should be piped.
   *                     Defaults to `process.stderr`.
   */
  constructor(serverParams, errlog = process.stderr) {
    super();
    this.serverParams = serverParams;
    this.errlog = errlog;
  }
  /**
   * Establish the stdio connection by spawning the server process and starting
   * the SDK's transport. Returns the live `StdioClientTransport` instance.
   */
  async establishConnection() {
    this._transport = new import_stdio.StdioClientTransport(this.serverParams);
    if (this._transport.stderr && typeof this._transport.stderr.pipe === "function") {
      this._transport.stderr.pipe(
        this.errlog
      );
    }
    logger.debug(`${this.constructor.name} connected successfully`);
    return this._transport;
  }
  /**
   * Close the stdio connection, making sure the transport cleans up the child
   * process and associated resources.
   */
  async closeConnection(_connection) {
    if (this._transport) {
      try {
        await this._transport.close();
      } catch (e) {
        logger.warn(`Error closing stdio transport: ${e}`);
      } finally {
        this._transport = null;
      }
    }
  }
};

// src/connectors/stdio.ts
var StdioConnector = class extends BaseConnector {
  static {
    __name(this, "StdioConnector");
  }
  command;
  args;
  env;
  errlog;
  clientInfo;
  constructor({
    command = "npx",
    args = [],
    env,
    errlog = import_node_process.default.stderr,
    ...rest
  } = {}) {
    super(rest);
    this.command = command;
    this.args = args;
    this.env = env;
    this.errlog = errlog;
    this.clientInfo = rest.clientInfo ?? {
      name: "stdio-connector",
      version: "1.0.0"
    };
  }
  /** Establish connection to the MCP implementation. */
  async connect() {
    if (this.connected) {
      logger.debug("Already connected to MCP implementation");
      return;
    }
    logger.debug(`Connecting to MCP implementation via stdio: ${this.command}`);
    try {
      let mergedEnv;
      if (this.env) {
        mergedEnv = {};
        for (const [key, value] of Object.entries(import_node_process.default.env)) {
          if (value !== void 0) {
            mergedEnv[key] = value;
          }
        }
        Object.assign(mergedEnv, this.env);
      }
      const serverParams = {
        command: this.command,
        args: this.args,
        env: mergedEnv
      };
      this.connectionManager = new StdioConnectionManager(
        serverParams,
        this.errlog
      );
      const transport = await this.connectionManager.start();
      const clientOptions = {
        ...this.opts.clientOptions || {},
        capabilities: {
          ...this.opts.clientOptions?.capabilities || {},
          roots: { listChanged: true },
          // Always advertise roots capability
          // Add sampling capability if callback is provided
          ...this.opts.samplingCallback ? { sampling: {} } : {},
          // Add elicitation capability if callback is provided
          ...this.opts.elicitationCallback ? { elicitation: { form: {}, url: {} } } : {}
        }
      };
      this.client = new import_client2.Client(this.clientInfo, clientOptions);
      await this.client.connect(transport);
      this.connected = true;
      this.setupNotificationHandler();
      this.setupRootsHandler();
      this.setupSamplingHandler();
      this.setupElicitationHandler();
      logger.debug(
        `Successfully connected to MCP implementation: ${this.command}`
      );
      this.trackConnectorInit({
        serverCommand: this.command,
        serverArgs: this.args,
        publicIdentifier: `${this.command} ${this.args.join(" ")}`
      });
    } catch (err) {
      logger.error(`Failed to connect to MCP implementation: ${err}`);
      await this.cleanupResources();
      throw err;
    }
  }
  get publicIdentifier() {
    return {
      type: "stdio",
      "command&args": `${this.command} ${this.args.join(" ")}`
    };
  }
};

// src/config.ts
function loadConfigFile(filepath) {
  const raw = (0, import_node_fs.readFileSync)(filepath, "utf-8");
  return JSON.parse(raw);
}
__name(loadConfigFile, "loadConfigFile");
function createConnectorFromConfig(serverConfig, connectorOptions) {
  if ("command" in serverConfig && "args" in serverConfig) {
    return new StdioConnector({
      command: serverConfig.command,
      args: serverConfig.args,
      env: serverConfig.env,
      ...connectorOptions
    });
  }
  if ("url" in serverConfig) {
    const transport = serverConfig.transport || "http";
    return new HttpConnector(serverConfig.url, {
      headers: serverConfig.headers,
      authToken: serverConfig.auth_token || serverConfig.authToken,
      // Only force SSE if explicitly requested
      preferSse: serverConfig.preferSse || transport === "sse",
      // Disable SSE fallback if explicitly disabled in config
      disableSseFallback: serverConfig.disableSseFallback,
      ...connectorOptions
    });
  }
  throw new Error("Cannot determine connector type from config");
}
__name(createConnectorFromConfig, "createConnectorFromConfig");

// src/client.ts
var MCPClient = class _MCPClient extends BaseMCPClient {
  static {
    __name(this, "MCPClient");
  }
  /**
   * Get the mcp-use package version.
   * Works in all environments (Node.js, browser, Cloudflare Workers, Deno, etc.)
   */
  static getPackageVersion() {
    return getPackageVersion();
  }
  codeMode = false;
  _codeExecutor = null;
  _customCodeExecutor = null;
  _codeExecutorConfig = "vm";
  _executorOptions;
  _samplingCallback;
  _elicitationCallback;
  constructor(config, options) {
    if (config) {
      if (typeof config === "string") {
        super(loadConfigFile(config));
      } else {
        super(config);
      }
    } else {
      super();
    }
    let codeModeEnabled = false;
    let executorConfig = "vm";
    let executorOptions;
    if (options?.codeMode) {
      if (typeof options.codeMode === "boolean") {
        codeModeEnabled = options.codeMode;
      } else {
        codeModeEnabled = options.codeMode.enabled;
        executorConfig = options.codeMode.executor ?? "vm";
        executorOptions = options.codeMode.executorOptions;
      }
    }
    this.codeMode = codeModeEnabled;
    this._codeExecutorConfig = executorConfig;
    this._executorOptions = executorOptions;
    this._samplingCallback = options?.samplingCallback;
    this._elicitationCallback = options?.elicitationCallback;
    if (this.codeMode) {
      this._setupCodeModeConnector();
    }
    this._trackClientInit();
  }
  _trackClientInit() {
    const servers = Object.keys(this.config.mcpServers ?? {});
    const hasSamplingCallback = !!this._samplingCallback;
    const hasElicitationCallback = !!this._elicitationCallback;
    Tel.getInstance().trackMCPClientInit({
      codeMode: this.codeMode,
      sandbox: false,
      // Sandbox not supported in TS yet
      allCallbacks: hasSamplingCallback && hasElicitationCallback,
      verify: false,
      // No verify option in TS client
      servers,
      numServers: servers.length,
      isBrowser: false
      // Node.js MCPClient
    }).catch((e) => logger.debug(`Failed to track MCPClient init: ${e}`));
  }
  static fromDict(cfg, options) {
    return new _MCPClient(cfg, options);
  }
  static fromConfigFile(path2, options) {
    return new _MCPClient(loadConfigFile(path2), options);
  }
  /**
   * Save configuration to a file (Node.js only)
   */
  saveConfig(filepath) {
    const dir = import_node_path.default.dirname(filepath);
    if (!import_node_fs2.default.existsSync(dir)) {
      import_node_fs2.default.mkdirSync(dir, { recursive: true });
    }
    import_node_fs2.default.writeFileSync(filepath, JSON.stringify(this.config, null, 2), "utf-8");
  }
  /**
   * Create a connector from server configuration (Node.js version)
   * Supports all connector types including StdioConnector
   */
  createConnectorFromConfig(serverConfig) {
    return createConnectorFromConfig(serverConfig, {
      samplingCallback: this._samplingCallback,
      elicitationCallback: this._elicitationCallback
    });
  }
  _setupCodeModeConnector() {
    logger.debug("Code mode connector initialized as internal meta server");
    const connector = new CodeModeConnector(this);
    const session = new MCPSession(connector);
    this.sessions["code_mode"] = session;
    this.activeSessions.push("code_mode");
  }
  _ensureCodeExecutor() {
    if (!this._codeExecutor) {
      const config = this._codeExecutorConfig;
      if (config instanceof BaseCodeExecutor) {
        this._codeExecutor = config;
      } else if (typeof config === "function") {
        this._customCodeExecutor = config;
        throw new Error(
          "Custom executor function should be handled in executeCode"
        );
      } else if (config === "e2b") {
        const opts = this._executorOptions;
        if (!opts?.apiKey) {
          logger.warn("E2B executor requires apiKey. Falling back to VM.");
          try {
            this._codeExecutor = new VMCodeExecutor(
              this,
              this._executorOptions
            );
          } catch (error) {
            throw new Error(
              "VM executor is not available in this environment and E2B API key is not provided. Please provide an E2B API key or run in a Node.js environment."
            );
          }
        } else {
          this._codeExecutor = new E2BCodeExecutor(this, opts);
        }
      } else {
        try {
          this._codeExecutor = new VMCodeExecutor(
            this,
            this._executorOptions
          );
        } catch (error) {
          const e2bOpts = this._executorOptions;
          const e2bApiKey = e2bOpts?.apiKey || process.env.E2B_API_KEY;
          if (e2bApiKey) {
            logger.info(
              "VM executor not available in this environment. Falling back to E2B."
            );
            this._codeExecutor = new E2BCodeExecutor(this, {
              ...e2bOpts,
              apiKey: e2bApiKey
            });
          } else {
            throw new Error(
              "VM executor is not available in this environment. Please provide an E2B API key via executorOptions or E2B_API_KEY environment variable, or run in a Node.js environment."
            );
          }
        }
      }
    }
    return this._codeExecutor;
  }
  /**
   * Execute code in code mode
   */
  async executeCode(code, timeout) {
    if (!this.codeMode) {
      throw new Error("Code execution mode is not enabled");
    }
    if (this._customCodeExecutor) {
      return this._customCodeExecutor(code, timeout);
    }
    return this._ensureCodeExecutor().execute(code, timeout);
  }
  /**
   * Search available tools (used by code mode)
   */
  async searchTools(query = "", detailLevel = "full") {
    if (!this.codeMode) {
      throw new Error("Code execution mode is not enabled");
    }
    return this._ensureCodeExecutor().createSearchToolsFunction()(
      query,
      detailLevel
    );
  }
  /**
   * Override getServerNames to exclude internal code_mode server
   */
  getServerNames() {
    const isCodeModeEnabled = this.codeMode;
    return super.getServerNames().filter((name) => {
      return !isCodeModeEnabled || name !== "code_mode";
    });
  }
  /**
   * Close the client and clean up resources including code executors.
   * This ensures E2B sandboxes and other resources are properly released.
   */
  async close() {
    if (this._codeExecutor) {
      await this._codeExecutor.cleanup();
      this._codeExecutor = null;
    }
    await this.closeAllSessions();
  }
};
