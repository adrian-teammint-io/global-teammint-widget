"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/react/index.ts
var react_exports = {};
__export(react_exports, {
  BrowserTelemetry: () => Tel,
  ErrorBoundary: () => ErrorBoundary,
  Image: () => Image,
  McpUseProvider: () => McpUseProvider,
  Tel: () => Tel,
  Telemetry: () => Telemetry,
  ThemeProvider: () => ThemeProvider,
  WidgetControls: () => WidgetControls,
  onMcpAuthorization: () => onMcpAuthorization,
  setBrowserTelemetrySource: () => setTelemetrySource,
  setTelemetrySource: () => setTelemetrySource,
  useMcp: () => useMcp,
  useWidget: () => useWidget,
  useWidgetProps: () => useWidgetProps,
  useWidgetState: () => useWidgetState,
  useWidgetTheme: () => useWidgetTheme
});
module.exports = __toCommonJS(react_exports);

// src/react/useMcp.ts
var import_react = require("react");

// src/utils/url-sanitize.ts
function sanitizeUrl(raw) {
  const abort = /* @__PURE__ */ __name(() => {
    throw new Error(`Invalid url to pass to open(): ${raw}`);
  }, "abort");
  let url;
  try {
    url = new URL(raw);
  } catch (_) {
    abort();
  }
  if (url.protocol !== "https:" && url.protocol !== "http:") abort();
  if (url.hostname !== encodeURIComponent(url.hostname)) abort();
  if (url.username) url.username = encodeURIComponent(url.username);
  if (url.password) url.password = encodeURIComponent(url.password);
  url.pathname = url.pathname.slice(0, 1) + encodeURIComponent(url.pathname.slice(1)).replace(/%2f/gi, "/");
  url.search = url.search.slice(0, 1) + Array.from(url.searchParams.entries()).map(sanitizeParam).join("&");
  url.hash = url.hash.slice(0, 1) + encodeURIComponent(url.hash.slice(1));
  return url.href;
}
__name(sanitizeUrl, "sanitizeUrl");
function sanitizeParam([k, v]) {
  return `${encodeURIComponent(k)}${v.length > 0 ? `=${encodeURIComponent(v)}` : ""}`;
}
__name(sanitizeParam, "sanitizeParam");

// src/connectors/http.ts
var import_client = require("@mcp-use/modelcontextprotocol-sdk/client/index.js");
var import_streamableHttp = require("@mcp-use/modelcontextprotocol-sdk/client/streamableHttp.js");

// src/logging.ts
async function getNodeModules() {
  if (typeof process !== "undefined" && process.platform) {
    try {
      const fs = await import("fs");
      const path = await import("path");
      return { fs: fs.default, path: path.default };
    } catch {
      return { fs: null, path: null };
    }
  }
  return { fs: null, path: null };
}
__name(getNodeModules, "getNodeModules");
var winston = null;
function loadWinstonSync() {
  if (typeof require !== "undefined") {
    try {
      winston = require("winston");
    } catch {
    }
  }
}
__name(loadWinstonSync, "loadWinstonSync");
async function getWinston() {
  if (!winston) {
    winston = await import("winston");
  }
  return winston;
}
__name(getWinston, "getWinston");
var DEFAULT_LOGGER_NAME = "mcp-use";
function isNodeJSEnvironment() {
  try {
    if (typeof navigator !== "undefined" && navigator.userAgent?.includes("Cloudflare-Workers")) {
      return false;
    }
    if (typeof globalThis.EdgeRuntime !== "undefined" || typeof globalThis.Deno !== "undefined") {
      return false;
    }
    const hasNodeGlobals = typeof process !== "undefined" && typeof process.platform !== "undefined" && typeof __dirname !== "undefined";
    return hasNodeGlobals;
  } catch {
    return false;
  }
}
__name(isNodeJSEnvironment, "isNodeJSEnvironment");
var SimpleConsoleLogger = class {
  static {
    __name(this, "SimpleConsoleLogger");
  }
  _level;
  name;
  constructor(name = DEFAULT_LOGGER_NAME, level = "info") {
    this.name = name;
    this._level = level;
  }
  shouldLog(level) {
    const levels = [
      "error",
      "warn",
      "info",
      "http",
      "verbose",
      "debug",
      "silly"
    ];
    const currentIndex = levels.indexOf(this._level);
    const messageIndex = levels.indexOf(level);
    return messageIndex <= currentIndex;
  }
  formatMessage(level, message) {
    const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", { hour12: false });
    return `${timestamp} [${this.name}] ${level}: ${message}`;
  }
  error(message) {
    if (this.shouldLog("error")) {
      console.error(this.formatMessage("error", message));
    }
  }
  warn(message) {
    if (this.shouldLog("warn")) {
      console.warn(this.formatMessage("warn", message));
    }
  }
  info(message) {
    if (this.shouldLog("info")) {
      console.info(this.formatMessage("info", message));
    }
  }
  debug(message) {
    if (this.shouldLog("debug")) {
      console.debug(this.formatMessage("debug", message));
    }
  }
  http(message) {
    if (this.shouldLog("http")) {
      console.log(this.formatMessage("http", message));
    }
  }
  verbose(message) {
    if (this.shouldLog("verbose")) {
      console.log(this.formatMessage("verbose", message));
    }
  }
  silly(message) {
    if (this.shouldLog("silly")) {
      console.log(this.formatMessage("silly", message));
    }
  }
  // Make it compatible with Winston interface
  get level() {
    return this._level;
  }
  set level(newLevel) {
    this._level = newLevel;
  }
};
function resolveLevel(env) {
  const envValue = typeof process !== "undefined" && process.env ? env : void 0;
  switch (envValue?.trim()) {
    case "2":
      return "debug";
    case "1":
      return "info";
    default:
      return "info";
  }
}
__name(resolveLevel, "resolveLevel");
var Logger = class {
  static {
    __name(this, "Logger");
  }
  static instances = {};
  static simpleInstances = {};
  static currentFormat = "minimal";
  static get(name = DEFAULT_LOGGER_NAME) {
    if (!isNodeJSEnvironment()) {
      if (!this.simpleInstances[name]) {
        const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
        this.simpleInstances[name] = new SimpleConsoleLogger(
          name,
          resolveLevel(debugEnv)
        );
      }
      return this.simpleInstances[name];
    }
    if (!this.instances[name]) {
      if (!winston) {
        throw new Error("Winston not loaded - call Logger.configure() first");
      }
      const { createLogger, format } = winston;
      const { combine, timestamp, label, colorize, splat } = format;
      this.instances[name] = createLogger({
        level: resolveLevel(process.env.DEBUG),
        format: combine(
          colorize(),
          splat(),
          label({ label: name }),
          timestamp({ format: "HH:mm:ss" }),
          this.getFormatter()
        ),
        transports: [new winston.transports.Console()]
      });
    }
    return this.instances[name];
  }
  static getFormatter() {
    if (!winston) {
      throw new Error("Winston not loaded");
    }
    const { format } = winston;
    const { printf } = format;
    const minimalFormatter = printf(({ level, message, label, timestamp }) => {
      return `${timestamp} [${label}] ${level}: ${message}`;
    });
    const detailedFormatter = printf(({ level, message, label, timestamp }) => {
      return `${timestamp} [${label}] ${level.toUpperCase()}: ${message}`;
    });
    const emojiFormatter = printf(({ level, message, label, timestamp }) => {
      return `${timestamp} [${label}] ${level.toUpperCase()}: ${message}`;
    });
    switch (this.currentFormat) {
      case "minimal":
        return minimalFormatter;
      case "detailed":
        return detailedFormatter;
      case "emoji":
        return emojiFormatter;
      default:
        return minimalFormatter;
    }
  }
  static async configure(options = {}) {
    const { level, console: console2 = true, file, format = "minimal" } = options;
    const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
    const resolvedLevel = level ?? resolveLevel(debugEnv);
    this.currentFormat = format;
    if (!isNodeJSEnvironment()) {
      Object.values(this.simpleInstances).forEach((logger2) => {
        logger2.level = resolvedLevel;
      });
      return;
    }
    await getWinston();
    if (!winston) {
      throw new Error("Failed to load winston");
    }
    const root = this.get();
    root.level = resolvedLevel;
    const winstonRoot = root;
    winstonRoot.clear();
    if (console2) {
      winstonRoot.add(new winston.transports.Console());
    }
    if (file) {
      const { fs: nodeFs, path: nodePath } = await getNodeModules();
      if (nodeFs && nodePath) {
        const dir = nodePath.dirname(nodePath.resolve(file));
        if (!nodeFs.existsSync(dir)) {
          nodeFs.mkdirSync(dir, { recursive: true });
        }
        winstonRoot.add(new winston.transports.File({ filename: file }));
      }
    }
    const { format: winstonFormat } = winston;
    const { combine, timestamp, label, colorize, splat } = winstonFormat;
    Object.values(this.instances).forEach((logger2) => {
      if (logger2 && "format" in logger2) {
        logger2.level = resolvedLevel;
        logger2.format = combine(
          colorize(),
          splat(),
          label({ label: DEFAULT_LOGGER_NAME }),
          timestamp({ format: "HH:mm:ss" }),
          this.getFormatter()
        );
      }
    });
  }
  static setDebug(enabled) {
    let level;
    if (enabled === 2 || enabled === true) level = "debug";
    else if (enabled === 1) level = "info";
    else level = "info";
    Object.values(this.simpleInstances).forEach((logger2) => {
      logger2.level = level;
    });
    Object.values(this.instances).forEach((logger2) => {
      if (logger2) {
        logger2.level = level;
      }
    });
    if (typeof process !== "undefined" && process.env) {
      process.env.DEBUG = enabled ? enabled === true ? "2" : String(enabled) : "0";
    }
  }
  static setFormat(format) {
    this.currentFormat = format;
    this.configure({ format });
  }
};
if (isNodeJSEnvironment()) {
  loadWinstonSync();
  if (winston) {
    Logger.configure();
  }
}
var logger = Logger.get();

// src/task_managers/sse.ts
var import_sse = require("@mcp-use/modelcontextprotocol-sdk/client/sse.js");

// src/task_managers/base.ts
var ConnectionManager = class {
  static {
    __name(this, "ConnectionManager");
  }
  _readyPromise;
  _readyResolver;
  _donePromise;
  _doneResolver;
  _exception = null;
  _connection = null;
  _task = null;
  _abortController = null;
  constructor() {
    this.reset();
  }
  /**
   * Start the connection manager and establish a connection.
   *
   * @returns The established connection.
   * @throws If the connection cannot be established.
   */
  async start() {
    this.reset();
    logger.debug(`Starting ${this.constructor.name}`);
    this._task = this.connectionTask();
    await this._readyPromise;
    if (this._exception) {
      throw this._exception;
    }
    if (this._connection === null) {
      throw new Error("Connection was not established");
    }
    return this._connection;
  }
  /**
   * Stop the connection manager and close the connection.
   */
  async stop() {
    if (this._task && this._abortController) {
      logger.debug(`Cancelling ${this.constructor.name} task`);
      this._abortController.abort();
      try {
        await this._task;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError") {
          logger.debug(`${this.constructor.name} task aborted successfully`);
        } else {
          logger.warn(`Error stopping ${this.constructor.name} task: ${e}`);
        }
      }
    }
    await this._donePromise;
    logger.debug(`${this.constructor.name} task completed`);
  }
  /**
   * Reset all internal state.
   */
  reset() {
    this._readyPromise = new Promise((res) => this._readyResolver = res);
    this._donePromise = new Promise((res) => this._doneResolver = res);
    this._exception = null;
    this._connection = null;
    this._task = null;
    this._abortController = new AbortController();
  }
  /**
   * The background task responsible for establishing and maintaining the
   * connection until it is cancelled.
   */
  async connectionTask() {
    logger.debug(`Running ${this.constructor.name} task`);
    try {
      this._connection = await this.establishConnection();
      logger.debug(`${this.constructor.name} connected successfully`);
      this._readyResolver();
      await this.waitForAbort();
    } catch (err) {
      this._exception = err;
      logger.error(`Error in ${this.constructor.name} task: ${err}`);
      this._readyResolver();
    } finally {
      if (this._connection !== null) {
        try {
          await this.closeConnection(this._connection);
        } catch (closeErr) {
          logger.warn(
            `Error closing connection in ${this.constructor.name}: ${closeErr}`
          );
        }
        this._connection = null;
      }
      this._doneResolver();
    }
  }
  /**
   * Helper that returns a promise which resolves when the abort signal fires.
   */
  async waitForAbort() {
    return new Promise((_resolve, _reject) => {
      if (!this._abortController) {
        return;
      }
      const signal = this._abortController.signal;
      if (signal.aborted) {
        _resolve();
        return;
      }
      const onAbort = /* @__PURE__ */ __name(() => {
        signal.removeEventListener("abort", onAbort);
        _resolve();
      }, "onAbort");
      signal.addEventListener("abort", onAbort);
    });
  }
};

// src/task_managers/sse.ts
var SseConnectionManager = class extends ConnectionManager {
  static {
    __name(this, "SseConnectionManager");
  }
  url;
  opts;
  _transport = null;
  reinitializing = false;
  /**
   * Create an SSE connection manager.
   *
   * @param url  The SSE endpoint URL.
   * @param opts Optional transport options (auth, headers, etc.).
   */
  constructor(url, opts) {
    super();
    this.url = typeof url === "string" ? new URL(url) : url;
    this.opts = opts;
  }
  /**
   * Spawn a new `SSEClientTransport` and wrap it with 404 handling.
   * Per MCP spec, clients MUST re-initialize when receiving 404 for stale sessions.
   */
  async establishConnection() {
    const transport = new import_sse.SSEClientTransport(this.url, this.opts);
    const originalSend = transport.send.bind(transport);
    transport.send = async (message) => {
      const sendMessage = /* @__PURE__ */ __name(async (msg) => {
        if (Array.isArray(msg)) {
          for (const singleMsg of msg) {
            await originalSend(singleMsg);
          }
        } else {
          await originalSend(msg);
        }
      }, "sendMessage");
      try {
        await sendMessage(message);
      } catch (error) {
        if (error?.code === 404 && transport.sessionId && !this.reinitializing) {
          logger.warn(
            `[SSE] Session not found (404), re-initializing per MCP spec...`
          );
          this.reinitializing = true;
          try {
            transport.sessionId = void 0;
            await this.reinitialize(transport);
            logger.info(`[SSE] Re-initialization successful, retrying request`);
            await sendMessage(message);
          } finally {
            this.reinitializing = false;
          }
        } else {
          throw error;
        }
      }
    };
    this._transport = transport;
    logger.debug(`${this.constructor.name} connected successfully`);
    return transport;
  }
  /**
   * Re-initialize the transport with a new session
   * This is called when the server returns 404 for a stale session
   */
  async reinitialize(transport) {
    logger.debug(`[SSE] Re-initialization triggered`);
  }
  /**
   * Close the underlying transport and clean up resources.
   */
  async closeConnection(_connection) {
    if (this._transport) {
      try {
        await this._transport.close();
      } catch (e) {
        logger.warn(`Error closing SSE transport: ${e}`);
      } finally {
        this._transport = null;
      }
    }
  }
};

// src/connectors/base.ts
var import_types = require("@mcp-use/modelcontextprotocol-sdk/types.js");

// src/telemetry/events.ts
var BaseTelemetryEvent = class {
  static {
    __name(this, "BaseTelemetryEvent");
  }
};
var MCPAgentExecutionEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "MCPAgentExecutionEvent");
  }
  get name() {
    return "mcp_agent_execution";
  }
  get properties() {
    return {
      // Core execution info
      execution_method: this.data.executionMethod,
      query: this.data.query,
      query_length: this.data.query.length,
      success: this.data.success,
      // Agent configuration
      model_provider: this.data.modelProvider,
      model_name: this.data.modelName,
      server_count: this.data.serverCount,
      server_identifiers: this.data.serverIdentifiers,
      total_tools_available: this.data.totalToolsAvailable,
      tools_available_names: this.data.toolsAvailableNames,
      max_steps_configured: this.data.maxStepsConfigured,
      memory_enabled: this.data.memoryEnabled,
      use_server_manager: this.data.useServerManager,
      // Execution parameters (always include, even if null)
      max_steps_used: this.data.maxStepsUsed,
      manage_connector: this.data.manageConnector,
      external_history_used: this.data.externalHistoryUsed,
      // Execution results (always include, even if null)
      steps_taken: this.data.stepsTaken ?? null,
      tools_used_count: this.data.toolsUsedCount ?? null,
      tools_used_names: this.data.toolsUsedNames ?? null,
      response: this.data.response ?? null,
      response_length: this.data.response ? this.data.response.length : null,
      execution_time_ms: this.data.executionTimeMs ?? null,
      error_type: this.data.errorType ?? null,
      conversation_history_length: this.data.conversationHistoryLength ?? null
    };
  }
};
function createServerRunEventData(server, transport) {
  const toolRegistrations = Array.from(server.registrations.tools.values());
  const promptRegistrations = Array.from(server.registrations.prompts.values());
  const resourceRegistrations = Array.from(
    server.registrations.resources.values()
  );
  const templateRegistrations = Array.from(
    server.registrations.resourceTemplates.values()
  );
  const allResources = resourceRegistrations.map((r) => ({
    name: r.config.name,
    title: r.config.title ?? null,
    description: r.config.description ?? null,
    uri: r.config.uri ?? null,
    mime_type: r.config.mimeType ?? null
  }));
  const appsSdkResources = allResources.filter(
    (r) => r.mime_type === "text/html+skybridge"
  );
  const mcpUiResources = allResources.filter(
    (r) => r.mime_type === "text/uri-list" || r.mime_type === "text/html"
  );
  const mcpAppsResources = allResources.filter(
    (r) => r.mime_type === "text/html+mcp"
  );
  return {
    transport,
    toolsNumber: server.registeredTools.length,
    resourcesNumber: server.registeredResources.length,
    promptsNumber: server.registeredPrompts.length,
    auth: !!server.oauthProvider,
    name: server.config.name,
    description: server.config.description ?? null,
    baseUrl: server.serverBaseUrl ?? null,
    toolNames: server.registeredTools.length > 0 ? server.registeredTools : null,
    resourceNames: server.registeredResources.length > 0 ? server.registeredResources : null,
    promptNames: server.registeredPrompts.length > 0 ? server.registeredPrompts : null,
    tools: toolRegistrations.length > 0 ? toolRegistrations.map((r) => ({
      name: r.config.name,
      title: r.config.title ?? null,
      description: r.config.description ?? null,
      input_schema: r.config.schema ? JSON.stringify(r.config.schema) : null,
      output_schema: r.config.outputSchema ? JSON.stringify(r.config.outputSchema) : null
    })) : null,
    resources: allResources.length > 0 ? allResources : null,
    prompts: promptRegistrations.length > 0 ? promptRegistrations.map((r) => ({
      name: r.config.name,
      title: r.config.title ?? null,
      description: r.config.description ?? null,
      args: r.config.args ? JSON.stringify(r.config.args) : null
    })) : null,
    templates: templateRegistrations.length > 0 ? templateRegistrations.map((r) => ({
      name: r.config.name,
      title: r.config.title ?? null,
      description: r.config.description ?? null
    })) : null,
    capabilities: {
      logging: true,
      resources: { subscribe: true, listChanged: true }
    },
    appsSdkResources: appsSdkResources.length > 0 ? appsSdkResources : null,
    appsSdkResourcesNumber: appsSdkResources.length,
    mcpUiResources: mcpUiResources.length > 0 ? mcpUiResources : null,
    mcpUiResourcesNumber: mcpUiResources.length,
    mcpAppsResources: mcpAppsResources.length > 0 ? mcpAppsResources : null,
    mcpAppsResourcesNumber: mcpAppsResources.length
  };
}
__name(createServerRunEventData, "createServerRunEventData");
var ServerRunEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerRunEvent");
  }
  get name() {
    return "server_run";
  }
  get properties() {
    return {
      transport: this.data.transport,
      tools_number: this.data.toolsNumber,
      resources_number: this.data.resourcesNumber,
      prompts_number: this.data.promptsNumber,
      auth: this.data.auth,
      name: this.data.name,
      description: this.data.description ?? null,
      base_url: this.data.baseUrl ?? null,
      tool_names: this.data.toolNames ?? null,
      resource_names: this.data.resourceNames ?? null,
      prompt_names: this.data.promptNames ?? null,
      tools: this.data.tools ?? null,
      resources: this.data.resources ?? null,
      prompts: this.data.prompts ?? null,
      templates: this.data.templates ?? null,
      capabilities: this.data.capabilities ? JSON.stringify(this.data.capabilities) : null,
      apps_sdk_resources: this.data.appsSdkResources ? JSON.stringify(this.data.appsSdkResources) : null,
      apps_sdk_resources_number: this.data.appsSdkResourcesNumber ?? 0,
      mcp_ui_resources: this.data.mcpUiResources ? JSON.stringify(this.data.mcpUiResources) : null,
      mcp_ui_resources_number: this.data.mcpUiResourcesNumber ?? 0,
      mcp_apps_resources: this.data.mcpAppsResources ? JSON.stringify(this.data.mcpAppsResources) : null,
      mcp_apps_resources_number: this.data.mcpAppsResourcesNumber ?? 0
    };
  }
};
var ServerInitializeEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerInitializeEvent");
  }
  get name() {
    return "server_initialize_call";
  }
  get properties() {
    return {
      protocol_version: this.data.protocolVersion,
      client_info: JSON.stringify(this.data.clientInfo),
      client_capabilities: JSON.stringify(this.data.clientCapabilities),
      session_id: this.data.sessionId ?? null
    };
  }
};
var ServerToolCallEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerToolCallEvent");
  }
  get name() {
    return "server_tool_call";
  }
  get properties() {
    return {
      tool_name: this.data.toolName,
      length_input_argument: this.data.lengthInputArgument,
      success: this.data.success,
      error_type: this.data.errorType ?? null,
      execution_time_ms: this.data.executionTimeMs ?? null
    };
  }
};
var ServerResourceCallEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerResourceCallEvent");
  }
  get name() {
    return "server_resource_call";
  }
  get properties() {
    return {
      name: this.data.name,
      description: this.data.description,
      contents: this.data.contents,
      success: this.data.success,
      error_type: this.data.errorType ?? null
    };
  }
};
var ServerPromptCallEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerPromptCallEvent");
  }
  get name() {
    return "server_prompt_call";
  }
  get properties() {
    return {
      name: this.data.name,
      description: this.data.description,
      success: this.data.success,
      error_type: this.data.errorType ?? null
    };
  }
};
var ServerContextEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerContextEvent");
  }
  get name() {
    return `server_context_${this.data.contextType}`;
  }
  get properties() {
    return {
      context_type: this.data.contextType,
      notification_type: this.data.notificationType ?? null
    };
  }
};
var MCPClientInitEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "MCPClientInitEvent");
  }
  get name() {
    return "mcpclient_init";
  }
  get properties() {
    return {
      code_mode: this.data.codeMode,
      sandbox: this.data.sandbox,
      all_callbacks: this.data.allCallbacks,
      verify: this.data.verify,
      servers: this.data.servers,
      num_servers: this.data.numServers,
      is_browser: this.data.isBrowser
    };
  }
};
var ConnectorInitEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ConnectorInitEvent");
  }
  get name() {
    return "connector_init";
  }
  get properties() {
    return {
      connector_type: this.data.connectorType,
      server_command: this.data.serverCommand ?? null,
      server_args: this.data.serverArgs ?? null,
      server_url: this.data.serverUrl ?? null,
      public_identifier: this.data.publicIdentifier ?? null
    };
  }
};
var ClientAddServerEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ClientAddServerEvent");
  }
  get name() {
    return "client_add_server";
  }
  get properties() {
    const { serverName, serverConfig } = this.data;
    const url = serverConfig.url;
    return {
      server_name: serverName,
      server_url_domain: url ? this._extractHostname(url) : null,
      transport: serverConfig.transport ?? null,
      has_auth: !!(serverConfig.authToken || serverConfig.authProvider)
    };
  }
  _extractHostname(url) {
    try {
      return new URL(url).hostname;
    } catch {
      return null;
    }
  }
};
var ClientRemoveServerEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ClientRemoveServerEvent");
  }
  get name() {
    return "client_remove_server";
  }
  get properties() {
    return {
      server_name: this.data.serverName
    };
  }
};

// src/server/utils/runtime.ts
var isDeno = typeof globalThis.Deno !== "undefined";
function generateUUID() {
  return globalThis.crypto.randomUUID();
}
__name(generateUUID, "generateUUID");

// src/version.ts
var VERSION = "1.11.1";
function getPackageVersion() {
  return VERSION;
}
__name(getPackageVersion, "getPackageVersion");

// src/telemetry/telemetry.ts
function secureRandomString() {
  if (typeof window !== "undefined" && window.crypto && typeof window.crypto.getRandomValues === "function") {
    const array = new Uint8Array(8);
    window.crypto.getRandomValues(array);
    return Array.from(array, (v) => v.toString(16).padStart(2, "0")).join("");
  }
  try {
    const crypto = require("crypto");
    return crypto.randomBytes(8).toString("hex");
  } catch (e) {
    return Math.random().toString(36).substring(2, 15);
  }
}
__name(secureRandomString, "secureRandomString");
var USER_ID_STORAGE_KEY = "mcp_use_user_id";
function detectRuntimeEnvironment() {
  try {
    if (typeof globalThis.Bun !== "undefined") {
      return "bun";
    }
    if (typeof globalThis.Deno !== "undefined") {
      return "deno";
    }
    if (typeof navigator !== "undefined" && navigator.userAgent?.includes("Cloudflare-Workers")) {
      return "cloudflare-workers";
    }
    if (typeof globalThis.EdgeRuntime !== "undefined") {
      return "edge";
    }
    if (typeof window !== "undefined" && typeof document !== "undefined") {
      return "browser";
    }
    if (typeof process !== "undefined" && typeof process.versions?.node !== "undefined") {
      return "node";
    }
    return "unknown";
  } catch {
    return "unknown";
  }
}
__name(detectRuntimeEnvironment, "detectRuntimeEnvironment");
function getStorageCapability(env) {
  switch (env) {
    case "node":
    case "bun":
      return "filesystem";
    case "browser":
      try {
        if (typeof localStorage !== "undefined") {
          localStorage.setItem("__mcp_use_test__", "1");
          localStorage.removeItem("__mcp_use_test__");
          return "localStorage";
        }
      } catch {
      }
      return "session-only";
    case "deno":
      return "session-only";
    default:
      return "session-only";
  }
}
__name(getStorageCapability, "getStorageCapability");
var cachedEnvironment = null;
function getRuntimeEnvironment() {
  if (cachedEnvironment === null) {
    cachedEnvironment = detectRuntimeEnvironment();
  }
  return cachedEnvironment;
}
__name(getRuntimeEnvironment, "getRuntimeEnvironment");
var ScarfEventLogger = class {
  static {
    __name(this, "ScarfEventLogger");
  }
  endpoint;
  timeout;
  constructor(endpoint, timeout = 3e3) {
    this.endpoint = endpoint;
    this.timeout = timeout;
  }
  async logEvent(properties) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.timeout);
      const response = await fetch(this.endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(properties),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      logger.debug(`Failed to send Scarf event: ${error}`);
    }
  }
};
var Telemetry = class _Telemetry {
  static {
    __name(this, "Telemetry");
  }
  static instance = null;
  PROJECT_API_KEY = "phc_lyTtbYwvkdSbrcMQNPiKiiRWrrM1seyKIMjycSvItEI";
  HOST = "https://eu.i.posthog.com";
  SCARF_GATEWAY_URL = "https://mcpuse.gateway.scarf.sh/events-ts";
  UNKNOWN_USER_ID = "UNKNOWN_USER_ID";
  _currUserId = null;
  _posthogNodeClient = null;
  _posthogBrowserClient = null;
  _posthogLoading = null;
  _scarfClient = null;
  _runtimeEnvironment;
  _storageCapability;
  _source;
  // Node.js specific paths (lazily computed)
  _userIdPath = null;
  _versionDownloadPath = null;
  constructor() {
    this._runtimeEnvironment = getRuntimeEnvironment();
    this._storageCapability = getStorageCapability(this._runtimeEnvironment);
    this._source = typeof process !== "undefined" && process.env?.MCP_USE_TELEMETRY_SOURCE || this._runtimeEnvironment;
    const telemetryDisabled = this._checkTelemetryDisabled();
    const canSupportTelemetry = this._runtimeEnvironment !== "unknown";
    if (telemetryDisabled) {
      this._posthogNodeClient = null;
      this._posthogBrowserClient = null;
      this._scarfClient = null;
      logger.debug("Telemetry disabled via environment/localStorage");
    } else if (!canSupportTelemetry) {
      this._posthogNodeClient = null;
      this._posthogBrowserClient = null;
      this._scarfClient = null;
      logger.debug(
        `Telemetry disabled - unknown environment: ${this._runtimeEnvironment}`
      );
    } else {
      logger.info(
        "Anonymized telemetry enabled. Set MCP_USE_ANONYMIZED_TELEMETRY=false to disable."
      );
      this._posthogLoading = this._initPostHog();
      if (this._runtimeEnvironment !== "browser") {
        try {
          this._scarfClient = new ScarfEventLogger(
            this.SCARF_GATEWAY_URL,
            3e3
          );
        } catch (e) {
          logger.warn(`Failed to initialize Scarf telemetry: ${e}`);
          this._scarfClient = null;
        }
      } else {
        this._scarfClient = null;
      }
      if (this._storageCapability === "filesystem" && this._scarfClient) {
        setTimeout(() => {
          this.trackPackageDownload({ triggered_by: "initialization" }).catch(
            (e) => logger.debug(`Failed to track package download: ${e}`)
          );
        }, 0);
      }
    }
  }
  _checkTelemetryDisabled() {
    if (typeof process !== "undefined" && process.env?.MCP_USE_ANONYMIZED_TELEMETRY?.toLowerCase() === "false") {
      return true;
    }
    if (typeof localStorage !== "undefined" && localStorage.getItem("MCP_USE_ANONYMIZED_TELEMETRY") === "false") {
      return true;
    }
    return false;
  }
  async _initPostHog() {
    const isBrowser = this._runtimeEnvironment === "browser";
    if (isBrowser) {
      await this._initPostHogBrowser();
    } else {
      await this._initPostHogNode();
    }
  }
  async _initPostHogBrowser() {
    try {
      const posthogModule = await import("posthog-js");
      const posthog = posthogModule.default || posthogModule.posthog;
      if (!posthog || typeof posthog.init !== "function") {
        throw new Error("posthog-js module did not export expected interface");
      }
      posthog.init(this.PROJECT_API_KEY, {
        api_host: this.HOST,
        persistence: "localStorage",
        autocapture: false,
        // We only want explicit captures
        capture_pageview: false,
        // We don't want automatic pageview tracking
        disable_session_recording: true,
        // No session recording
        loaded: /* @__PURE__ */ __name(() => {
          logger.debug("PostHog browser client initialized");
        }, "loaded")
      });
      this._posthogBrowserClient = posthog;
    } catch (e) {
      logger.warn(`Failed to initialize PostHog browser telemetry: ${e}`);
      this._posthogBrowserClient = null;
    }
  }
  async _initPostHogNode() {
    try {
      const { PostHog } = await import("posthog-node");
      const isServerlessEnvironment = [
        "cloudflare-workers",
        "edge",
        "deno"
      ].includes(this._runtimeEnvironment);
      const posthogOptions = {
        host: this.HOST,
        disableGeoip: false
      };
      if (isServerlessEnvironment) {
        posthogOptions.flushAt = 1;
        posthogOptions.flushInterval = 0;
      }
      this._posthogNodeClient = new PostHog(
        this.PROJECT_API_KEY,
        posthogOptions
      );
      logger.debug("PostHog Node.js client initialized");
    } catch (e) {
      logger.warn(`Failed to initialize PostHog Node.js telemetry: ${e}`);
      this._posthogNodeClient = null;
    }
  }
  /**
   * Get the detected runtime environment
   */
  get runtimeEnvironment() {
    return this._runtimeEnvironment;
  }
  /**
   * Get the storage capability for this environment
   */
  get storageCapability() {
    return this._storageCapability;
  }
  static getInstance() {
    if (!_Telemetry.instance) {
      _Telemetry.instance = new _Telemetry();
    }
    return _Telemetry.instance;
  }
  /**
   * Set the source identifier for telemetry events.
   * This allows tracking usage from different applications.
   * @param source - The source identifier (e.g., "my-app", "cli", "vs-code-extension")
   */
  setSource(source) {
    this._source = source;
    logger.debug(`Telemetry source set to: ${source}`);
  }
  /**
   * Get the current source identifier.
   */
  getSource() {
    return this._source;
  }
  /**
   * Check if telemetry is enabled.
   */
  get isEnabled() {
    return this._posthogNodeClient !== null || this._posthogBrowserClient !== null || this._scarfClient !== null;
  }
  get userId() {
    if (this._currUserId) {
      return this._currUserId;
    }
    try {
      switch (this._storageCapability) {
        case "filesystem":
          this._currUserId = this._getUserIdFromFilesystem();
          break;
        case "localStorage":
          this._currUserId = this._getUserIdFromLocalStorage();
          break;
        case "session-only":
        default:
          try {
            this._currUserId = `session-${generateUUID()}`;
          } catch (uuidError) {
            this._currUserId = `session-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
          }
          break;
      }
    } catch (e) {
      this._currUserId = this.UNKNOWN_USER_ID;
    }
    return this._currUserId;
  }
  /**
   * Get or create user ID from filesystem (Node.js/Bun)
   * Falls back to session ID if filesystem operations fail
   */
  _getUserIdFromFilesystem() {
    try {
      let fs, os, path;
      try {
        fs = require("fs");
        os = require("os");
        path = require("path");
      } catch (requireError) {
        try {
          const sessionId = `session-${generateUUID()}`;
          return sessionId;
        } catch (uuidError) {
          return `session-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
        }
      }
      if (!this._userIdPath) {
        this._userIdPath = path.join(
          this._getCacheHome(os, path),
          "mcp_use_3",
          "telemetry_user_id"
        );
      }
      const isFirstTime = !fs.existsSync(this._userIdPath);
      if (isFirstTime) {
        fs.mkdirSync(path.dirname(this._userIdPath), { recursive: true });
        let newUserId;
        try {
          newUserId = generateUUID();
        } catch (uuidError) {
          newUserId = `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
        }
        fs.writeFileSync(this._userIdPath, newUserId);
        return newUserId;
      }
      const userId = fs.readFileSync(this._userIdPath, "utf-8").trim();
      return userId;
    } catch (e) {
      try {
        return `session-${generateUUID()}`;
      } catch (uuidError) {
        return `session-${Date.now()}-${secureRandomString()}`;
      }
    }
  }
  /**
   * Get or create user ID from localStorage (Browser)
   */
  _getUserIdFromLocalStorage() {
    try {
      let userId = localStorage.getItem(USER_ID_STORAGE_KEY);
      if (!userId) {
        try {
          userId = generateUUID();
        } catch (uuidError) {
          userId = `${Date.now()}-${secureRandomString()}`;
        }
        localStorage.setItem(USER_ID_STORAGE_KEY, userId);
      }
      return userId;
    } catch (e) {
      let sessionId;
      try {
        sessionId = `session-${generateUUID()}`;
      } catch (uuidError) {
        sessionId = `session-${Date.now()}-${secureRandomString()}`;
      }
      return sessionId;
    }
  }
  _getCacheHome(os, path) {
    const envVar = process.env.XDG_CACHE_HOME;
    if (envVar && path.isAbsolute(envVar)) {
      return envVar;
    }
    const platform = process.platform;
    const homeDir = os.homedir();
    if (platform === "win32") {
      const appdata = process.env.LOCALAPPDATA || process.env.APPDATA;
      if (appdata) {
        return appdata;
      }
      return path.join(homeDir, "AppData", "Local");
    } else if (platform === "darwin") {
      return path.join(homeDir, "Library", "Caches");
    } else {
      return path.join(homeDir, ".cache");
    }
  }
  async capture(event) {
    if (this._posthogLoading) {
      await this._posthogLoading;
    }
    if (!this._posthogNodeClient && !this._posthogBrowserClient && !this._scarfClient) {
      return;
    }
    const currentUserId = this.userId;
    const properties = { ...event.properties };
    properties.mcp_use_version = getPackageVersion();
    properties.language = "typescript";
    properties.source = this._source;
    properties.runtime = this._runtimeEnvironment;
    if (this._posthogNodeClient) {
      try {
        this._posthogNodeClient.capture({
          distinctId: currentUserId,
          event: event.name,
          properties
        });
      } catch (e) {
        logger.debug(`Failed to track PostHog Node event ${event.name}: ${e}`);
      }
    }
    if (this._posthogBrowserClient) {
      try {
        this._posthogBrowserClient.capture(event.name, {
          ...properties,
          distinct_id: currentUserId
        });
      } catch (e) {
        logger.debug(
          `Failed to track PostHog Browser event ${event.name}: ${e}`
        );
      }
    }
    if (this._scarfClient) {
      try {
        const scarfProperties = {
          ...properties,
          user_id: currentUserId,
          event: event.name
        };
        await this._scarfClient.logEvent(scarfProperties);
      } catch (e) {
        logger.debug(`Failed to track Scarf event ${event.name}: ${e}`);
      }
    }
  }
  // ============================================================================
  // Package Download Tracking (Node.js only)
  // ============================================================================
  /**
   * Track package download event.
   * This is a public wrapper that safely accesses userId.
   */
  async trackPackageDownload(properties) {
    return this._trackPackageDownloadInternal(this.userId, properties);
  }
  /**
   * Internal method to track package download with explicit userId.
   */
  async _trackPackageDownloadInternal(userId, properties) {
    if (!this._scarfClient) {
      return;
    }
    if (this._storageCapability !== "filesystem") {
      return;
    }
    try {
      const fs = require("fs");
      const path = require("path");
      const os = require("os");
      if (!this._versionDownloadPath) {
        this._versionDownloadPath = path.join(
          this._getCacheHome(os, path),
          "mcp_use",
          "download_version"
        );
      }
      const currentVersion = getPackageVersion();
      let shouldTrack = false;
      let firstDownload = false;
      if (!fs.existsSync(this._versionDownloadPath)) {
        shouldTrack = true;
        firstDownload = true;
        fs.mkdirSync(path.dirname(this._versionDownloadPath), {
          recursive: true
        });
        fs.writeFileSync(this._versionDownloadPath, currentVersion);
      } else {
        const savedVersion = fs.readFileSync(this._versionDownloadPath, "utf-8").trim();
        if (currentVersion > savedVersion) {
          shouldTrack = true;
          firstDownload = false;
          fs.writeFileSync(this._versionDownloadPath, currentVersion);
        }
      }
      if (shouldTrack) {
        logger.debug(
          `Tracking package download event with properties: ${JSON.stringify(properties)}`
        );
        const eventProperties = { ...properties || {} };
        eventProperties.mcp_use_version = currentVersion;
        eventProperties.user_id = userId;
        eventProperties.event = "package_download";
        eventProperties.first_download = firstDownload;
        eventProperties.language = "typescript";
        eventProperties.source = this._source;
        eventProperties.runtime = this._runtimeEnvironment;
        await this._scarfClient.logEvent(eventProperties);
      }
    } catch (e) {
      logger.debug(`Failed to track Scarf package_download event: ${e}`);
    }
  }
  // ============================================================================
  // Agent Events
  // ============================================================================
  async trackAgentExecution(data) {
    if (!this.isEnabled) return;
    const event = new MCPAgentExecutionEvent(data);
    await this.capture(event);
  }
  // ============================================================================
  // Server Events
  // ============================================================================
  /**
   * Track server run event directly from an MCPServer instance.
   */
  async trackServerRunFromServer(server, transport) {
    if (!this.isEnabled) return;
    const data = createServerRunEventData(server, transport);
    const event = new ServerRunEvent(data);
    await this.capture(event);
  }
  async trackServerInitialize(data) {
    if (!this.isEnabled) return;
    const event = new ServerInitializeEvent(data);
    await this.capture(event);
  }
  async trackServerToolCall(data) {
    if (!this.isEnabled) return;
    const event = new ServerToolCallEvent(data);
    await this.capture(event);
  }
  async trackServerResourceCall(data) {
    if (!this.isEnabled) return;
    const event = new ServerResourceCallEvent(data);
    await this.capture(event);
  }
  async trackServerPromptCall(data) {
    if (!this.isEnabled) return;
    const event = new ServerPromptCallEvent(data);
    await this.capture(event);
  }
  async trackServerContext(data) {
    if (!this.isEnabled) return;
    const event = new ServerContextEvent(data);
    await this.capture(event);
  }
  // ============================================================================
  // Client Events
  // ============================================================================
  async trackMCPClientInit(data) {
    if (!this.isEnabled) return;
    const event = new MCPClientInitEvent(data);
    await this.capture(event);
  }
  async trackConnectorInit(data) {
    if (!this.isEnabled) return;
    const event = new ConnectorInitEvent(data);
    await this.capture(event);
  }
  async trackClientAddServer(serverName, serverConfig) {
    if (!this.isEnabled) return;
    const event = new ClientAddServerEvent({ serverName, serverConfig });
    await this.capture(event);
  }
  async trackClientRemoveServer(serverName) {
    if (!this.isEnabled) return;
    const event = new ClientRemoveServerEvent({ serverName });
    await this.capture(event);
  }
  // ============================================================================
  // React Hook / Browser specific events
  // ============================================================================
  async trackUseMcpConnection(data) {
    if (!this.isEnabled) return;
    await this.capture({
      name: "usemcp_connection",
      properties: {
        url_domain: new URL(data.url).hostname,
        // Only domain for privacy
        transport_type: data.transportType,
        success: data.success,
        error_type: data.errorType ?? null,
        connection_time_ms: data.connectionTimeMs ?? null,
        has_oauth: data.hasOAuth,
        has_sampling: data.hasSampling,
        has_elicitation: data.hasElicitation
      }
    });
  }
  async trackUseMcpToolCall(data) {
    if (!this.isEnabled) return;
    await this.capture({
      name: "usemcp_tool_call",
      properties: {
        tool_name: data.toolName,
        success: data.success,
        error_type: data.errorType ?? null,
        execution_time_ms: data.executionTimeMs ?? null
      }
    });
  }
  async trackUseMcpResourceRead(data) {
    if (!this.isEnabled) return;
    await this.capture({
      name: "usemcp_resource_read",
      properties: {
        resource_uri_scheme: data.resourceUri.split(":")[0],
        // Only scheme for privacy
        success: data.success,
        error_type: data.errorType ?? null
      }
    });
  }
  // ============================================================================
  // Browser-specific Methods
  // ============================================================================
  /**
   * Identify the current user (useful for linking sessions)
   * Browser only - no-op in Node.js
   */
  identify(userId, properties) {
    if (this._posthogBrowserClient) {
      try {
        this._posthogBrowserClient.identify(userId, properties);
      } catch (e) {
        logger.debug(`Failed to identify user: ${e}`);
      }
    }
  }
  /**
   * Reset the user identity (useful for logout)
   * Browser only - no-op in Node.js
   */
  reset() {
    if (this._posthogBrowserClient) {
      try {
        this._posthogBrowserClient.reset();
      } catch (e) {
        logger.debug(`Failed to reset user: ${e}`);
      }
    }
    this._currUserId = null;
  }
  // ============================================================================
  // Node.js-specific Methods
  // ============================================================================
  /**
   * Flush the telemetry queue (Node.js only)
   */
  flush() {
    if (this._posthogNodeClient) {
      try {
        this._posthogNodeClient.flush();
        logger.debug("PostHog client telemetry queue flushed");
      } catch (e) {
        logger.debug(`Failed to flush PostHog client: ${e}`);
      }
    }
  }
  /**
   * Shutdown the telemetry client (Node.js only)
   */
  shutdown() {
    if (this._posthogNodeClient) {
      try {
        this._posthogNodeClient.shutdown();
        logger.debug("PostHog client shutdown successfully");
      } catch (e) {
        logger.debug(`Error shutting down PostHog client: ${e}`);
      }
    }
  }
};
var Tel = Telemetry;
function setTelemetrySource(source) {
  Tel.getInstance().setSource(source);
}
__name(setTelemetrySource, "setTelemetrySource");

// src/connectors/base.ts
var BaseConnector = class {
  static {
    __name(this, "BaseConnector");
  }
  client = null;
  connectionManager = null;
  toolsCache = null;
  capabilitiesCache = null;
  serverInfoCache = null;
  connected = false;
  opts;
  notificationHandlers = [];
  rootsCache = [];
  constructor(opts = {}) {
    this.opts = opts;
    if (opts.roots) {
      this.rootsCache = [...opts.roots];
    }
  }
  /**
   * Track connector initialization event
   * Should be called by subclasses after successful connection
   */
  trackConnectorInit(data) {
    const connectorType = this.constructor.name;
    Telemetry.getInstance().trackConnectorInit({
      connectorType,
      ...data
    }).catch((e) => logger.debug(`Failed to track connector init: ${e}`));
  }
  /**
   * Register a handler for server notifications
   *
   * @param handler - Function to call when a notification is received
   *
   * @example
   * ```typescript
   * connector.onNotification((notification) => {
   *   console.log(`Received: ${notification.method}`, notification.params);
   * });
   * ```
   */
  onNotification(handler) {
    this.notificationHandlers.push(handler);
    if (this.client) {
      this.setupNotificationHandler();
    }
  }
  /**
   * Internal: wire notification handlers to the SDK client
   * Includes automatic handling for list_changed notifications per MCP spec
   */
  setupNotificationHandler() {
    if (!this.client) return;
    this.client.fallbackNotificationHandler = async (notification) => {
      switch (notification.method) {
        case "notifications/tools/list_changed":
          await this.refreshToolsCache();
          break;
        case "notifications/resources/list_changed":
          await this.onResourcesListChanged();
          break;
        case "notifications/prompts/list_changed":
          await this.onPromptsListChanged();
          break;
        default:
          break;
      }
      for (const handler of this.notificationHandlers) {
        try {
          await handler(notification);
        } catch (err) {
          logger.error("Error in notification handler:", err);
        }
      }
    };
  }
  /**
   * Auto-refresh tools cache when server sends tools/list_changed notification
   */
  async refreshToolsCache() {
    if (!this.client) return;
    try {
      logger.debug(
        "[Auto] Refreshing tools cache due to list_changed notification"
      );
      const result = await this.client.listTools();
      this.toolsCache = result.tools ?? [];
      logger.debug(
        `[Auto] Refreshed tools cache: ${this.toolsCache.length} tools`
      );
    } catch (err) {
      logger.warn("[Auto] Failed to refresh tools cache:", err);
    }
  }
  /**
   * Called when server sends resources/list_changed notification
   * Resources aren't cached by default, but we log for user awareness
   */
  async onResourcesListChanged() {
    logger.debug(
      "[Auto] Resources list changed - clients should re-fetch if needed"
    );
  }
  /**
   * Called when server sends prompts/list_changed notification
   * Prompts aren't cached by default, but we log for user awareness
   */
  async onPromptsListChanged() {
    logger.debug(
      "[Auto] Prompts list changed - clients should re-fetch if needed"
    );
  }
  /**
   * Set roots and notify the server.
   * Roots represent directories or files that the client has access to.
   *
   * @param roots - Array of Root objects with `uri` (must start with "file://") and optional `name`
   *
   * @example
   * ```typescript
   * await connector.setRoots([
   *   { uri: "file:///home/user/project", name: "My Project" },
   *   { uri: "file:///home/user/data" }
   * ]);
   * ```
   */
  async setRoots(roots) {
    this.rootsCache = [...roots];
    if (this.client) {
      logger.debug(
        `Sending roots/list_changed notification with ${roots.length} root(s)`
      );
      await this.client.sendRootsListChanged();
    }
  }
  /**
   * Get the current roots.
   */
  getRoots() {
    return [...this.rootsCache];
  }
  /**
   * Internal: set up roots/list request handler.
   * This is called after the client connects to register the handler for server requests.
   */
  setupRootsHandler() {
    if (!this.client) return;
    this.client.setRequestHandler(
      import_types.ListRootsRequestSchema,
      async (_request, _extra) => {
        logger.debug(
          `Server requested roots list, returning ${this.rootsCache.length} root(s)`
        );
        return { roots: this.rootsCache };
      }
    );
  }
  /**
   * Internal: set up sampling/createMessage request handler.
   * This is called after the client connects to register the handler for sampling requests.
   */
  setupSamplingHandler() {
    if (!this.client) {
      logger.debug("setupSamplingHandler: No client available");
      return;
    }
    if (!this.opts.samplingCallback) {
      logger.debug("setupSamplingHandler: No sampling callback provided");
      return;
    }
    logger.debug("setupSamplingHandler: Setting up sampling request handler");
    this.client.setRequestHandler(
      import_types.CreateMessageRequestSchema,
      async (request, _extra) => {
        logger.debug("Server requested sampling, forwarding to callback");
        return await this.opts.samplingCallback(request.params);
      }
    );
    logger.debug(
      "setupSamplingHandler: Sampling handler registered successfully"
    );
  }
  /**
   * Internal: set up elicitation/create request handler.
   * This is called after the client connects to register the handler for elicitation requests.
   */
  setupElicitationHandler() {
    if (!this.client) {
      logger.debug("setupElicitationHandler: No client available");
      return;
    }
    if (!this.opts.elicitationCallback) {
      logger.debug("setupElicitationHandler: No elicitation callback provided");
      return;
    }
    logger.debug(
      "setupElicitationHandler: Setting up elicitation request handler"
    );
    this.client.setRequestHandler(
      import_types.ElicitRequestSchema,
      async (request, _extra) => {
        logger.debug("Server requested elicitation, forwarding to callback");
        return await this.opts.elicitationCallback(request.params);
      }
    );
    logger.debug(
      "setupElicitationHandler: Elicitation handler registered successfully"
    );
  }
  /** Disconnect and release resources. */
  async disconnect() {
    if (!this.connected) {
      logger.debug("Not connected to MCP implementation");
      return;
    }
    logger.debug("Disconnecting from MCP implementation");
    await this.cleanupResources();
    this.connected = false;
    logger.debug("Disconnected from MCP implementation");
  }
  /** Check if the client is connected */
  get isClientConnected() {
    return this.client != null;
  }
  /**
   * Initialise the MCP session **after** `connect()` has succeeded.
   *
   * In the SDK, `Client.connect(transport)` automatically performs the
   * protocollevel `initialize` handshake, so we only need to cache the list of
   * tools and expose some server info.
   */
  async initialize(defaultRequestOptions = this.opts.defaultRequestOptions ?? {}) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Caching server capabilities & tools");
    const capabilities = this.client.getServerCapabilities();
    this.capabilitiesCache = capabilities || null;
    const serverInfo = this.client.getServerVersion();
    this.serverInfoCache = serverInfo || null;
    const listToolsRes = await this.client.listTools(
      void 0,
      defaultRequestOptions
    );
    this.toolsCache = listToolsRes.tools ?? [];
    logger.debug(`Fetched ${this.toolsCache.length} tools from server`);
    logger.debug("Server capabilities:", capabilities);
    logger.debug("Server info:", serverInfo);
    return capabilities;
  }
  /** Lazily expose the cached tools list. */
  get tools() {
    if (!this.toolsCache) {
      throw new Error("MCP client is not initialized; call initialize() first");
    }
    return this.toolsCache;
  }
  /** Expose cached server capabilities. */
  get serverCapabilities() {
    return this.capabilitiesCache || {};
  }
  /** Expose cached server info. */
  get serverInfo() {
    return this.serverInfoCache;
  }
  /** Call a tool on the server. */
  async callTool(name, args, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    const enhancedOptions = options ? { ...options } : void 0;
    if (enhancedOptions?.resetTimeoutOnProgress && !enhancedOptions.onprogress) {
      enhancedOptions.onprogress = () => {
      };
      logger.debug(
        `[BaseConnector] Added onprogress callback for tool '${name}' to enable progressToken`
      );
    }
    logger.debug(`Calling tool '${name}' with args`, args);
    const res = await this.client.callTool(
      { name, arguments: args },
      void 0,
      enhancedOptions
    );
    logger.debug(`Tool '${name}' returned`, res);
    return res;
  }
  /**
   * List all available tools from the MCP server.
   * This method fetches fresh tools from the server, unlike the `tools` getter which returns cached tools.
   *
   * @param options - Optional request options
   * @returns Array of available tools
   */
  async listTools(options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    const result = await this.client.listTools(void 0, options);
    return result.tools ?? [];
  }
  /**
   * List resources from the server with optional pagination
   *
   * @param cursor - Optional cursor for pagination
   * @param options - Request options
   * @returns Resource list with optional nextCursor for pagination
   */
  async listResources(cursor, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Listing resources", cursor ? `with cursor: ${cursor}` : "");
    return await this.client.listResources({ cursor }, options);
  }
  /**
   * List all resources from the server, automatically handling pagination
   *
   * @param options - Request options
   * @returns Complete list of all resources
   */
  async listAllResources(options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    if (!this.capabilitiesCache?.resources) {
      logger.debug("Server does not advertise resources capability, skipping");
      return { resources: [] };
    }
    try {
      logger.debug("Listing all resources (with auto-pagination)");
      const allResources = [];
      let cursor = void 0;
      do {
        const result = await this.client.listResources({ cursor }, options);
        allResources.push(...result.resources || []);
        cursor = result.nextCursor;
      } while (cursor);
      return { resources: allResources };
    } catch (err) {
      const error = err;
      if (error.code === -32601) {
        logger.debug("Server advertised resources but method not found");
        return { resources: [] };
      }
      throw err;
    }
  }
  /**
   * List resource templates from the server
   *
   * @param options - Request options
   * @returns List of available resource templates
   */
  async listResourceTemplates(options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Listing resource templates");
    return await this.client.listResourceTemplates(void 0, options);
  }
  /** Read a resource by URI. */
  async readResource(uri, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Reading resource ${uri}`);
    const res = await this.client.readResource({ uri }, options);
    return res;
  }
  /**
   * Subscribe to resource updates
   *
   * @param uri - URI of the resource to subscribe to
   * @param options - Request options
   */
  async subscribeToResource(uri, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Subscribing to resource: ${uri}`);
    return await this.client.subscribeResource({ uri }, options);
  }
  /**
   * Unsubscribe from resource updates
   *
   * @param uri - URI of the resource to unsubscribe from
   * @param options - Request options
   */
  async unsubscribeFromResource(uri, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Unsubscribing from resource: ${uri}`);
    return await this.client.unsubscribeResource({ uri }, options);
  }
  async listPrompts() {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    if (!this.capabilitiesCache?.prompts) {
      logger.debug("Server does not advertise prompts capability, skipping");
      return { prompts: [] };
    }
    try {
      logger.debug("Listing prompts");
      return await this.client.listPrompts();
    } catch (err) {
      const error = err;
      if (error.code === -32601) {
        logger.debug("Server advertised prompts but method not found");
        return { prompts: [] };
      }
      throw err;
    }
  }
  async getPrompt(name, args) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Getting prompt ${name}`);
    return await this.client.getPrompt({ name, arguments: args });
  }
  /** Send a raw request through the client. */
  async request(method, params = null, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Sending raw request '${method}' with params`, params);
    return await this.client.request(
      { method, params: params ?? {} },
      void 0,
      options
    );
  }
  /**
   * Helper to tear down the client & connection manager safely.
   */
  async cleanupResources() {
    const issues = [];
    if (this.client) {
      try {
        if (typeof this.client.close === "function") {
          await this.client.close();
        }
      } catch (e) {
        const msg = `Error closing client: ${e}`;
        logger.warn(msg);
        issues.push(msg);
      } finally {
        this.client = null;
      }
    }
    if (this.connectionManager) {
      try {
        await this.connectionManager.stop();
      } catch (e) {
        const msg = `Error stopping connection manager: ${e}`;
        logger.warn(msg);
        issues.push(msg);
      } finally {
        this.connectionManager = null;
      }
    }
    this.toolsCache = null;
    if (issues.length) {
      logger.warn(`Resource cleanup finished with ${issues.length} issue(s)`);
    }
  }
};

// src/connectors/http.ts
var HttpConnector = class extends BaseConnector {
  static {
    __name(this, "HttpConnector");
  }
  baseUrl;
  headers;
  timeout;
  sseReadTimeout;
  clientInfo;
  preferSse;
  disableSseFallback;
  transportType = null;
  streamableTransport = null;
  constructor(baseUrl, opts = {}) {
    super(opts);
    this.baseUrl = baseUrl.replace(/\/$/, "");
    this.headers = { ...opts.headers ?? {} };
    if (opts.authToken) {
      this.headers.Authorization = `Bearer ${opts.authToken}`;
    }
    this.timeout = opts.timeout ?? 3e4;
    this.sseReadTimeout = opts.sseReadTimeout ?? 3e5;
    this.clientInfo = opts.clientInfo ?? {
      name: "http-connector",
      version: "1.0.0"
    };
    this.preferSse = opts.preferSse ?? false;
    this.disableSseFallback = opts.disableSseFallback ?? false;
  }
  /** Establish connection to the MCP implementation via HTTP (streamable or SSE). */
  async connect() {
    if (this.connected) {
      logger.debug("Already connected to MCP implementation");
      return;
    }
    const baseUrl = this.baseUrl;
    if (this.preferSse) {
      logger.debug(`Connecting to MCP implementation via HTTP/SSE: ${baseUrl}`);
      await this.connectWithSse(baseUrl);
      return;
    }
    logger.debug(`Connecting to MCP implementation via HTTP: ${baseUrl}`);
    try {
      logger.info("\u{1F504} Attempting streamable HTTP transport...");
      await this.connectWithStreamableHttp(baseUrl);
      logger.info("\u2705 Successfully connected via streamable HTTP");
    } catch (err) {
      let fallbackReason = "Unknown error";
      let is401Error = false;
      if (err instanceof import_streamableHttp.StreamableHTTPError) {
        const streamableErr = err;
        is401Error = streamableErr.code === 401;
        if (streamableErr.code === 400 && streamableErr.message.includes("Missing session ID")) {
          fallbackReason = "Server requires session ID (FastMCP compatibility) - using SSE transport";
          logger.warn(`\u26A0\uFE0F  ${fallbackReason}`);
        } else if (streamableErr.code === 404 || streamableErr.code === 405) {
          fallbackReason = `Server returned ${streamableErr.code} - server likely doesn't support streamable HTTP`;
          logger.debug(fallbackReason);
        } else {
          fallbackReason = `Server returned ${streamableErr.code}: ${streamableErr.message}`;
          logger.debug(fallbackReason);
        }
      } else if (err instanceof Error) {
        const errorStr = err.toString();
        const errorMsg = err.message || "";
        is401Error = errorStr.includes("401") || errorMsg.includes("Unauthorized");
        if (errorStr.includes("Missing session ID") || errorStr.includes("Bad Request: Missing session ID") || errorMsg.includes("FastMCP session ID error")) {
          fallbackReason = "Server requires session ID (FastMCP compatibility) - using SSE transport";
          logger.warn(`\u26A0\uFE0F  ${fallbackReason}`);
        } else if (errorStr.includes("405 Method Not Allowed") || errorStr.includes("404 Not Found")) {
          fallbackReason = "Server doesn't support streamable HTTP (405/404)";
          logger.debug(fallbackReason);
        } else {
          fallbackReason = `Streamable HTTP failed: ${err.message}`;
          logger.debug(fallbackReason);
        }
      }
      if (is401Error) {
        logger.info("Authentication required - skipping SSE fallback");
        await this.cleanupResources();
        const authError = new Error("Authentication required");
        authError.code = 401;
        throw authError;
      }
      if (this.disableSseFallback) {
        logger.info("SSE fallback disabled - failing connection");
        await this.cleanupResources();
        throw new Error(
          `Streamable HTTP connection failed: ${fallbackReason}. SSE fallback is disabled.`
        );
      }
      logger.info("\u{1F504} Falling back to SSE transport...");
      try {
        await this.connectWithSse(baseUrl);
      } catch (sseErr) {
        logger.error(`Failed to connect with both transports:`);
        logger.error(`  Streamable HTTP: ${fallbackReason}`);
        logger.error(`  SSE: ${sseErr}`);
        await this.cleanupResources();
        const sseIs401 = sseErr?.message?.includes("401") || sseErr?.message?.includes("Unauthorized");
        if (sseIs401) {
          const authError = new Error("Authentication required");
          authError.code = 401;
          throw authError;
        }
        throw new Error(
          "Could not connect to server with any available transport"
        );
      }
    }
  }
  async connectWithStreamableHttp(baseUrl) {
    try {
      const streamableTransport = new import_streamableHttp.StreamableHTTPClientTransport(
        new URL(baseUrl),
        {
          authProvider: this.opts.authProvider,
          //  Pass OAuth provider to SDK
          requestInit: {
            headers: this.headers
          },
          // Pass through reconnection options
          reconnectionOptions: {
            maxReconnectionDelay: 3e4,
            initialReconnectionDelay: 1e3,
            reconnectionDelayGrowFactor: 1.5,
            maxRetries: 2
          }
          // Don't pass sessionId - let the SDK generate it automatically during connect()
        }
      );
      let transport = streamableTransport;
      if (this.opts.wrapTransport) {
        const serverId = this.baseUrl;
        transport = this.opts.wrapTransport(
          transport,
          serverId
        );
      }
      const clientOptions = {
        ...this.opts.clientOptions || {},
        capabilities: {
          ...this.opts.clientOptions?.capabilities || {},
          roots: { listChanged: true },
          // Always advertise roots capability
          // Add sampling capability if callback is provided
          ...this.opts.samplingCallback ? { sampling: {} } : {},
          // Add elicitation capability if callback is provided
          ...this.opts.elicitationCallback ? { elicitation: { form: {}, url: {} } } : {}
        }
      };
      logger.debug(
        `Creating Client with capabilities:`,
        JSON.stringify(clientOptions.capabilities, null, 2)
      );
      this.client = new import_client.Client(this.clientInfo, clientOptions);
      this.setupRootsHandler();
      logger.debug("Roots handler registered before connect");
      try {
        await this.client.connect(transport, {
          timeout: Math.min(this.timeout, 3e3)
        });
        const sessionId = streamableTransport.sessionId;
        if (sessionId) {
          logger.debug(`Session ID obtained: ${sessionId}`);
        } else {
          logger.warn(
            "Session ID not available after connect - this may cause issues with SSE stream"
          );
        }
      } catch (connectErr) {
        if (connectErr instanceof Error) {
          const errMsg = connectErr.message || connectErr.toString();
          if (errMsg.includes("Missing session ID") || errMsg.includes("Bad Request: Missing session ID") || errMsg.includes("Mcp-Session-Id header is required")) {
            const wrappedError = new Error(
              `Session ID error: ${errMsg}. The SDK should automatically extract session ID from initialize response.`
            );
            wrappedError.cause = connectErr;
            throw wrappedError;
          }
        }
        throw connectErr;
      }
      this.streamableTransport = streamableTransport;
      this.connectionManager = {
        stop: /* @__PURE__ */ __name(async () => {
          if (this.streamableTransport) {
            try {
              await this.streamableTransport.terminateSession();
              await this.streamableTransport.close();
            } catch (e) {
              logger.warn(`Error closing Streamable HTTP transport: ${e}`);
            } finally {
              this.streamableTransport = null;
            }
          }
        }, "stop")
      };
      this.connected = true;
      this.transportType = "streamable-http";
      this.setupNotificationHandler();
      this.setupSamplingHandler();
      this.setupElicitationHandler();
      logger.debug(
        `Successfully connected to MCP implementation via streamable HTTP: ${baseUrl}`
      );
      this.trackConnectorInit({
        serverUrl: this.baseUrl,
        publicIdentifier: `${this.baseUrl} (streamable-http)`
      });
    } catch (err) {
      await this.cleanupResources();
      throw err;
    }
  }
  async connectWithSse(baseUrl) {
    try {
      this.connectionManager = new SseConnectionManager(baseUrl, {
        authProvider: this.opts.authProvider,
        //  Pass OAuth provider to SDK (same as streamable HTTP)
        requestInit: {
          headers: this.headers
        }
      });
      let transport = await this.connectionManager.start();
      if (this.opts.wrapTransport) {
        const serverId = this.baseUrl;
        transport = this.opts.wrapTransport(transport, serverId);
      }
      const clientOptions = {
        ...this.opts.clientOptions || {},
        capabilities: {
          ...this.opts.clientOptions?.capabilities || {},
          roots: { listChanged: true },
          // Always advertise roots capability
          // Add sampling capability if callback is provided
          ...this.opts.samplingCallback ? { sampling: {} } : {},
          // Add elicitation capability if callback is provided
          ...this.opts.elicitationCallback ? { elicitation: { form: {}, url: {} } } : {}
        }
      };
      logger.debug(
        `Creating Client with capabilities (SSE):`,
        JSON.stringify(clientOptions.capabilities, null, 2)
      );
      this.client = new import_client.Client(this.clientInfo, clientOptions);
      this.setupRootsHandler();
      logger.debug("Roots handler registered before connect (SSE)");
      await this.client.connect(transport);
      this.connected = true;
      this.transportType = "sse";
      this.setupNotificationHandler();
      this.setupSamplingHandler();
      this.setupElicitationHandler();
      logger.debug(
        `Successfully connected to MCP implementation via HTTP/SSE: ${baseUrl}`
      );
      this.trackConnectorInit({
        serverUrl: this.baseUrl,
        publicIdentifier: `${this.baseUrl} (sse)`
      });
    } catch (err) {
      await this.cleanupResources();
      throw err;
    }
  }
  get publicIdentifier() {
    return {
      type: "http",
      url: this.baseUrl,
      transport: this.transportType || "unknown"
    };
  }
  /**
   * Get the transport type being used (streamable-http or sse)
   */
  getTransportType() {
    return this.transportType;
  }
};

// src/session.ts
var MCPSession = class {
  static {
    __name(this, "MCPSession");
  }
  connector;
  autoConnect;
  constructor(connector, autoConnect = true) {
    this.connector = connector;
    this.autoConnect = autoConnect;
  }
  async connect() {
    await this.connector.connect();
  }
  async disconnect() {
    await this.connector.disconnect();
  }
  async initialize() {
    if (!this.isConnected && this.autoConnect) {
      await this.connect();
    }
    await this.connector.initialize();
  }
  get isConnected() {
    return this.connector && this.connector.isClientConnected;
  }
  /**
   * Register an event handler for session events
   *
   * @param event - The event type to listen for
   * @param handler - The handler function to call when the event occurs
   *
   * @example
   * ```typescript
   * session.on("notification", async (notification) => {
   *   console.log(`Received: ${notification.method}`, notification.params);
   *
   *   if (notification.method === "notifications/tools/list_changed") {
   *     // Refresh tools list
   *   }
   * });
   * ```
   */
  on(event, handler) {
    if (event === "notification") {
      this.connector.onNotification(handler);
    }
  }
  /**
   * Set roots and notify the server.
   * Roots represent directories or files that the client has access to.
   *
   * @param roots - Array of Root objects with `uri` (must start with "file://") and optional `name`
   *
   * @example
   * ```typescript
   * await session.setRoots([
   *   { uri: "file:///home/user/project", name: "My Project" },
   *   { uri: "file:///home/user/data" }
   * ]);
   * ```
   */
  async setRoots(roots) {
    return this.connector.setRoots(roots);
  }
  /**
   * Get the current roots.
   */
  getRoots() {
    return this.connector.getRoots();
  }
  /**
   * Get the cached list of tools from the server.
   *
   * @returns Array of available tools
   *
   * @example
   * ```typescript
   * const tools = session.tools;
   * console.log(`Available tools: ${tools.map(t => t.name).join(", ")}`);
   * ```
   */
  get tools() {
    return this.connector.tools;
  }
  /**
   * List all available tools from the MCP server.
   * This method fetches fresh tools from the server, unlike the `tools` getter which returns cached tools.
   *
   * @param options - Optional request options
   * @returns Array of available tools
   *
   * @example
   * ```typescript
   * const tools = await session.listTools();
   * console.log(`Available tools: ${tools.map(t => t.name).join(", ")}`);
   * ```
   */
  async listTools(options) {
    return this.connector.listTools(options);
  }
  /**
   * Get the server capabilities advertised during initialization.
   *
   * @returns Server capabilities object
   */
  get serverCapabilities() {
    return this.connector.serverCapabilities;
  }
  /**
   * Get the server information (name and version).
   *
   * @returns Server info object or null if not available
   */
  get serverInfo() {
    return this.connector.serverInfo;
  }
  /**
   * Call a tool on the server.
   *
   * @param name - Name of the tool to call
   * @param args - Arguments to pass to the tool (defaults to empty object)
   * @param options - Optional request options (timeout, progress handlers, etc.)
   * @returns Result from the tool execution
   *
   * @example
   * ```typescript
   * const result = await session.callTool("add", { a: 5, b: 3 });
   * console.log(`Result: ${result.content[0].text}`);
   * ```
   */
  async callTool(name, args = {}, options) {
    return this.connector.callTool(name, args, options);
  }
  /**
   * List resources from the server with optional pagination.
   *
   * @param cursor - Optional cursor for pagination
   * @param options - Request options
   * @returns Resource list with optional nextCursor for pagination
   *
   * @example
   * ```typescript
   * const result = await session.listResources();
   * console.log(`Found ${result.resources.length} resources`);
   * ```
   */
  async listResources(cursor, options) {
    return this.connector.listResources(cursor, options);
  }
  /**
   * List all resources from the server, automatically handling pagination.
   *
   * @param options - Request options
   * @returns Complete list of all resources
   *
   * @example
   * ```typescript
   * const result = await session.listAllResources();
   * console.log(`Total resources: ${result.resources.length}`);
   * ```
   */
  async listAllResources(options) {
    return this.connector.listAllResources(options);
  }
  /**
   * List resource templates from the server.
   *
   * @param options - Request options
   * @returns List of available resource templates
   *
   * @example
   * ```typescript
   * const result = await session.listResourceTemplates();
   * console.log(`Available templates: ${result.resourceTemplates.length}`);
   * ```
   */
  async listResourceTemplates(options) {
    return this.connector.listResourceTemplates(options);
  }
  /**
   * Read a resource by URI.
   *
   * @param uri - URI of the resource to read
   * @param options - Request options
   * @returns Resource content
   *
   * @example
   * ```typescript
   * const resource = await session.readResource("file:///path/to/file.txt");
   * console.log(resource.contents);
   * ```
   */
  async readResource(uri, options) {
    return this.connector.readResource(uri, options);
  }
  /**
   * Subscribe to resource updates.
   *
   * @param uri - URI of the resource to subscribe to
   * @param options - Request options
   *
   * @example
   * ```typescript
   * await session.subscribeToResource("file:///path/to/file.txt");
   * // Now you'll receive notifications when this resource changes
   * ```
   */
  async subscribeToResource(uri, options) {
    return this.connector.subscribeToResource(uri, options);
  }
  /**
   * Unsubscribe from resource updates.
   *
   * @param uri - URI of the resource to unsubscribe from
   * @param options - Request options
   *
   * @example
   * ```typescript
   * await session.unsubscribeFromResource("file:///path/to/file.txt");
   * ```
   */
  async unsubscribeFromResource(uri, options) {
    return this.connector.unsubscribeFromResource(uri, options);
  }
  /**
   * List available prompts from the server.
   *
   * @returns List of available prompts
   *
   * @example
   * ```typescript
   * const result = await session.listPrompts();
   * console.log(`Available prompts: ${result.prompts.length}`);
   * ```
   */
  async listPrompts() {
    return this.connector.listPrompts();
  }
  /**
   * Get a specific prompt with arguments.
   *
   * @param name - Name of the prompt to get
   * @param args - Arguments for the prompt
   * @returns Prompt result
   *
   * @example
   * ```typescript
   * const prompt = await session.getPrompt("greeting", { name: "Alice" });
   * console.log(prompt.messages);
   * ```
   */
  async getPrompt(name, args) {
    return this.connector.getPrompt(name, args);
  }
  /**
   * Send a raw request through the client.
   *
   * @param method - MCP method name
   * @param params - Request parameters
   * @param options - Request options
   * @returns Response from the server
   *
   * @example
   * ```typescript
   * const result = await session.request("custom/method", { key: "value" });
   * ```
   */
  async request(method, params = null, options) {
    return this.connector.request(method, params, options);
  }
};

// src/client/base.ts
var BaseMCPClient = class {
  static {
    __name(this, "BaseMCPClient");
  }
  config = {};
  sessions = {};
  activeSessions = [];
  constructor(config) {
    if (config) {
      this.config = config;
    }
  }
  static fromDict(_cfg) {
    throw new Error("fromDict must be implemented by concrete class");
  }
  addServer(name, serverConfig) {
    this.config.mcpServers = this.config.mcpServers || {};
    this.config.mcpServers[name] = serverConfig;
    Tel.getInstance().trackClientAddServer(name, serverConfig);
  }
  removeServer(name) {
    if (this.config.mcpServers?.[name]) {
      delete this.config.mcpServers[name];
      this.activeSessions = this.activeSessions.filter((n) => n !== name);
      Tel.getInstance().trackClientRemoveServer(name);
    }
  }
  getServerNames() {
    return Object.keys(this.config.mcpServers ?? {});
  }
  getServerConfig(name) {
    return this.config.mcpServers?.[name];
  }
  getConfig() {
    return this.config ?? {};
  }
  async createSession(serverName, autoInitialize = true) {
    const servers = this.config.mcpServers ?? {};
    if (Object.keys(servers).length === 0) {
      logger.warn("No MCP servers defined in config");
    }
    if (!servers[serverName]) {
      throw new Error(`Server '${serverName}' not found in config`);
    }
    const connector = this.createConnectorFromConfig(servers[serverName]);
    const session = new MCPSession(connector);
    if (autoInitialize) {
      await session.initialize();
    }
    this.sessions[serverName] = session;
    if (!this.activeSessions.includes(serverName)) {
      this.activeSessions.push(serverName);
    }
    return session;
  }
  async createAllSessions(autoInitialize = true) {
    const servers = this.config.mcpServers ?? {};
    if (Object.keys(servers).length === 0) {
      logger.warn("No MCP servers defined in config");
    }
    for (const name of Object.keys(servers)) {
      await this.createSession(name, autoInitialize);
    }
    return this.sessions;
  }
  getSession(serverName) {
    const session = this.sessions[serverName];
    if (!session) {
      return null;
    }
    return session;
  }
  requireSession(serverName) {
    const session = this.sessions[serverName];
    if (!session) {
      throw new Error(
        `Session '${serverName}' not found. Available sessions: ${this.activeSessions.join(", ") || "none"}`
      );
    }
    return session;
  }
  getAllActiveSessions() {
    return Object.fromEntries(
      this.activeSessions.map((n) => [n, this.sessions[n]])
    );
  }
  async closeSession(serverName) {
    const session = this.sessions[serverName];
    if (!session) {
      logger.warn(
        `No session exists for server ${serverName}, nothing to close`
      );
      return;
    }
    try {
      logger.debug(`Closing session for server ${serverName}`);
      await session.disconnect();
    } catch (e) {
      logger.error(`Error closing session for server '${serverName}': ${e}`);
    } finally {
      delete this.sessions[serverName];
      this.activeSessions = this.activeSessions.filter((n) => n !== serverName);
    }
  }
  async closeAllSessions() {
    const serverNames = Object.keys(this.sessions);
    const errors = [];
    for (const serverName of serverNames) {
      try {
        logger.debug(`Closing session for server ${serverName}`);
        await this.closeSession(serverName);
      } catch (e) {
        const errorMsg = `Failed to close session for server '${serverName}': ${e}`;
        logger.error(errorMsg);
        errors.push(errorMsg);
      }
    }
    if (errors.length) {
      logger.error(
        `Encountered ${errors.length} errors while closing sessions`
      );
    } else {
      logger.debug("All sessions closed successfully");
    }
  }
};

// src/client/browser.ts
var BrowserMCPClient = class _BrowserMCPClient extends BaseMCPClient {
  static {
    __name(this, "BrowserMCPClient");
  }
  /**
   * Get the mcp-use package version.
   * Works in all environments (Node.js, browser, Cloudflare Workers, Deno, etc.)
   */
  static getPackageVersion() {
    return getPackageVersion();
  }
  constructor(config) {
    super(config);
    this._trackClientInit();
  }
  _trackClientInit() {
    const servers = Object.keys(this.config.mcpServers ?? {});
    Tel.getInstance().trackMCPClientInit({
      codeMode: false,
      // Browser client doesn't support code mode
      sandbox: false,
      // Sandbox not supported in browser
      allCallbacks: false,
      // Will be set per-server
      verify: false,
      servers,
      numServers: servers.length,
      isBrowser: true
      // Browser MCPClient
    }).catch(
      (e) => logger.debug(`Failed to track BrowserMCPClient init: ${e}`)
    );
  }
  static fromDict(cfg) {
    return new _BrowserMCPClient(cfg);
  }
  /**
   * Create a connector from server configuration (Browser version)
   * Supports HTTP connector only
   */
  createConnectorFromConfig(serverConfig) {
    const {
      url,
      headers,
      authToken,
      authProvider,
      wrapTransport,
      clientOptions,
      samplingCallback,
      elicitationCallback,
      disableSseFallback,
      preferSse
    } = serverConfig;
    if (!url) {
      throw new Error("Server URL is required");
    }
    const connectorOptions = {
      headers,
      authToken,
      authProvider,
      //  Pass OAuth provider to connector
      wrapTransport,
      //  Pass transport wrapper if provided
      clientOptions,
      //  Pass client options (capabilities, etc.) to connector
      samplingCallback,
      //  Pass sampling callback to connector
      elicitationCallback,
      //  Pass elicitation callback to connector
      disableSseFallback,
      //  Disable automatic SSE fallback
      preferSse
      //  Use SSE transport directly
    };
    if (clientOptions) {
      console.log(
        "[BrowserMCPClient] Passing clientOptions to connector:",
        JSON.stringify(clientOptions, null, 2)
      );
    } else {
      console.warn(
        "[BrowserMCPClient] No clientOptions provided to connector!"
      );
    }
    return new HttpConnector(url, connectorOptions);
  }
};

// src/auth/browser-provider.ts
var BrowserOAuthClientProvider = class {
  static {
    __name(this, "BrowserOAuthClientProvider");
  }
  serverUrl;
  storageKeyPrefix;
  serverUrlHash;
  clientName;
  clientUri;
  callbackUrl;
  preventAutoAuth;
  useRedirectFlow;
  onPopupWindow;
  constructor(serverUrl, options = {}) {
    this.serverUrl = serverUrl;
    this.storageKeyPrefix = options.storageKeyPrefix || "mcp:auth";
    this.serverUrlHash = this.hashString(serverUrl);
    this.clientName = options.clientName || "mcp-use";
    this.clientUri = options.clientUri || (typeof window !== "undefined" ? window.location.origin : "");
    this.callbackUrl = sanitizeUrl(
      options.callbackUrl || (typeof window !== "undefined" ? new URL("/oauth/callback", window.location.origin).toString() : "/oauth/callback")
    );
    this.preventAutoAuth = options.preventAutoAuth;
    this.useRedirectFlow = options.useRedirectFlow;
    this.onPopupWindow = options.onPopupWindow;
  }
  // --- SDK Interface Methods ---
  get redirectUrl() {
    return sanitizeUrl(this.callbackUrl);
  }
  get clientMetadata() {
    return {
      redirect_uris: [this.redirectUrl],
      token_endpoint_auth_method: "none",
      // Public client
      grant_types: ["authorization_code", "refresh_token"],
      response_types: ["code"],
      client_name: this.clientName,
      client_uri: this.clientUri
      // scope: 'openid profile email mcp', // Example scopes, adjust as needed
    };
  }
  async clientInformation() {
    const key = this.getKey("client_info");
    const data = localStorage.getItem(key);
    if (!data) return void 0;
    try {
      return JSON.parse(data);
    } catch (e) {
      console.warn(
        `[${this.storageKeyPrefix}] Failed to parse client information:`,
        e
      );
      localStorage.removeItem(key);
      return void 0;
    }
  }
  // NOTE: The SDK's auth() function uses this if dynamic registration is needed.
  // Ensure your OAuthClientInformationFull matches the expected structure if DCR is used.
  async saveClientInformation(clientInformation) {
    const key = this.getKey("client_info");
    localStorage.setItem(key, JSON.stringify(clientInformation));
  }
  async tokens() {
    const key = this.getKey("tokens");
    const data = localStorage.getItem(key);
    if (!data) return void 0;
    try {
      return JSON.parse(data);
    } catch (e) {
      console.warn(`[${this.storageKeyPrefix}] Failed to parse tokens:`, e);
      localStorage.removeItem(key);
      return void 0;
    }
  }
  async saveTokens(tokens) {
    const key = this.getKey("tokens");
    localStorage.setItem(key, JSON.stringify(tokens));
    localStorage.removeItem(this.getKey("code_verifier"));
    localStorage.removeItem(this.getKey("last_auth_url"));
  }
  async saveCodeVerifier(codeVerifier) {
    const key = this.getKey("code_verifier");
    localStorage.setItem(key, codeVerifier);
  }
  async codeVerifier() {
    const key = this.getKey("code_verifier");
    const verifier = localStorage.getItem(key);
    if (!verifier) {
      throw new Error(
        `[${this.storageKeyPrefix}] Code verifier not found in storage for key ${key}. Auth flow likely corrupted or timed out.`
      );
    }
    return verifier;
  }
  /**
   * Generates and stores the authorization URL with state, without opening a popup.
   * Used when preventAutoAuth is enabled to provide the URL for manual navigation.
   * @param authorizationUrl The fully constructed authorization URL from the SDK.
   * @returns The full authorization URL with state parameter.
   */
  async prepareAuthorizationUrl(authorizationUrl) {
    const state = globalThis.crypto.randomUUID();
    const stateKey = `${this.storageKeyPrefix}:state_${state}`;
    const stateData = {
      serverUrlHash: this.serverUrlHash,
      expiry: Date.now() + 1e3 * 60 * 10,
      // State expires in 10 minutes
      // Store provider options needed to reconstruct on callback
      providerOptions: {
        serverUrl: this.serverUrl,
        storageKeyPrefix: this.storageKeyPrefix,
        clientName: this.clientName,
        clientUri: this.clientUri,
        callbackUrl: this.callbackUrl
      },
      // Store flow type so callback knows how to handle the response
      flowType: this.useRedirectFlow ? "redirect" : "popup",
      // Store current URL for redirect flow so we can return to it
      returnUrl: this.useRedirectFlow && typeof window !== "undefined" ? window.location.href : void 0
    };
    localStorage.setItem(stateKey, JSON.stringify(stateData));
    authorizationUrl.searchParams.set("state", state);
    const authUrlString = authorizationUrl.toString();
    const sanitizedAuthUrl = sanitizeUrl(authUrlString);
    localStorage.setItem(this.getKey("last_auth_url"), sanitizedAuthUrl);
    return sanitizedAuthUrl;
  }
  /**
   * Redirects the user agent to the authorization URL, storing necessary state.
   * This now adheres to the SDK's void return type expectation for the interface.
   * @param authorizationUrl The fully constructed authorization URL from the SDK.
   */
  async redirectToAuthorization(authorizationUrl) {
    const sanitizedAuthUrl = await this.prepareAuthorizationUrl(authorizationUrl);
    if (this.preventAutoAuth) {
      console.info(
        `[${this.storageKeyPrefix}] Auto-auth prevented. Authorization URL stored for manual trigger.`
      );
      return;
    }
    if (this.useRedirectFlow) {
      console.info(
        `[${this.storageKeyPrefix}] Redirecting to authorization URL (full-page redirect).`
      );
      window.location.href = sanitizedAuthUrl;
      return;
    }
    const popupFeatures = "width=600,height=700,resizable=yes,scrollbars=yes,status=yes";
    try {
      const popup = window.open(
        sanitizedAuthUrl,
        `mcp_auth_${this.serverUrlHash}`,
        popupFeatures
      );
      if (this.onPopupWindow) {
        this.onPopupWindow(sanitizedAuthUrl, popupFeatures, popup);
      }
      if (!popup || popup.closed || typeof popup.closed === "undefined") {
        console.warn(
          `[${this.storageKeyPrefix}] Popup likely blocked by browser. Manual navigation might be required using the stored URL.`
        );
      } else {
        popup.focus();
        console.info(
          `[${this.storageKeyPrefix}] Redirecting to authorization URL in popup.`
        );
      }
    } catch (e) {
      console.error(
        `[${this.storageKeyPrefix}] Error opening popup window:`,
        e
      );
    }
  }
  // --- Helper Methods ---
  /**
   * Retrieves the last URL passed to `redirectToAuthorization`. Useful for manual fallback.
   */
  getLastAttemptedAuthUrl() {
    const storedUrl = localStorage.getItem(this.getKey("last_auth_url"));
    return storedUrl ? sanitizeUrl(storedUrl) : null;
  }
  clearStorage() {
    const prefixPattern = `${this.storageKeyPrefix}_${this.serverUrlHash}_`;
    const statePattern = `${this.storageKeyPrefix}:state_`;
    const keysToRemove = [];
    let count = 0;
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (!key) continue;
      if (key.startsWith(prefixPattern)) {
        keysToRemove.push(key);
      } else if (key.startsWith(statePattern)) {
        try {
          const item = localStorage.getItem(key);
          if (item) {
            const state = JSON.parse(item);
            if (state.serverUrlHash === this.serverUrlHash) {
              keysToRemove.push(key);
            }
          }
        } catch (e) {
          console.warn(
            `[${this.storageKeyPrefix}] Error parsing state key ${key} during clearStorage:`,
            e
          );
        }
      }
    }
    const uniqueKeysToRemove = [...new Set(keysToRemove)];
    uniqueKeysToRemove.forEach((key) => {
      localStorage.removeItem(key);
      count++;
    });
    return count;
  }
  hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16);
  }
  getKey(keySuffix) {
    return `${this.storageKeyPrefix}_${this.serverUrlHash}_${keySuffix}`;
  }
};

// src/utils/assert.ts
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
__name(assert, "assert");

// src/react/useMcp.ts
var DEFAULT_RECONNECT_DELAY = 3e3;
var DEFAULT_RETRY_DELAY = 5e3;
function useMcp(options) {
  const {
    url,
    enabled = true,
    clientName,
    clientUri,
    callbackUrl = typeof window !== "undefined" ? sanitizeUrl(
      new URL("/oauth/callback", window.location.origin).toString()
    ) : "/oauth/callback",
    storageKeyPrefix = "mcp:auth",
    clientConfig = {},
    customHeaders = {},
    debug: _debug = false,
    autoRetry = false,
    autoReconnect = DEFAULT_RECONNECT_DELAY,
    transportType = "auto",
    preventAutoAuth = false,
    // Default to false for backward compatibility (auto-trigger OAuth)
    useRedirectFlow = false,
    // Default to false for backward compatibility (use popup)
    onPopupWindow,
    timeout = 3e4,
    // 30 seconds default for connection timeout
    sseReadTimeout = 3e5,
    // 5 minutes default for SSE read timeout
    wrapTransport,
    onNotification,
    samplingCallback,
    onElicitation
  } = options;
  const [state, setState] = (0, import_react.useState)("discovering");
  const [tools, setTools] = (0, import_react.useState)([]);
  const [resources, setResources] = (0, import_react.useState)([]);
  const [resourceTemplates, setResourceTemplates] = (0, import_react.useState)([]);
  const [prompts, setPrompts] = (0, import_react.useState)([]);
  const [serverInfo, setServerInfo] = (0, import_react.useState)();
  const [capabilities, setCapabilities] = (0, import_react.useState)();
  const [error, setError] = (0, import_react.useState)(void 0);
  const [log, setLog] = (0, import_react.useState)([]);
  const [authUrl, setAuthUrl] = (0, import_react.useState)(void 0);
  const clientRef = (0, import_react.useRef)(null);
  const authProviderRef = (0, import_react.useRef)(null);
  const connectingRef = (0, import_react.useRef)(false);
  const isMountedRef = (0, import_react.useRef)(true);
  const connectAttemptRef = (0, import_react.useRef)(0);
  const authTimeoutRef = (0, import_react.useRef)(null);
  const stateRef = (0, import_react.useRef)(state);
  const autoReconnectRef = (0, import_react.useRef)(autoReconnect);
  const successfulTransportRef = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(() => {
    stateRef.current = state;
    autoReconnectRef.current = autoReconnect;
  }, [state, autoReconnect]);
  const addLog = (0, import_react.useCallback)(
    (level, message, ...args) => {
      const fullMessage = args.length > 0 ? `${message} ${args.map((arg) => JSON.stringify(arg)).join(" ")}` : message;
      console[level](`[useMcp] ${fullMessage}`);
      if (isMountedRef.current) {
        setLog((prevLog) => [
          ...prevLog.slice(-100),
          { level, message: fullMessage, timestamp: Date.now() }
        ]);
      }
    },
    []
  );
  const disconnect = (0, import_react.useCallback)(
    async (quiet = false) => {
      if (!quiet) addLog("info", "Disconnecting...");
      connectingRef.current = false;
      if (authTimeoutRef.current) clearTimeout(authTimeoutRef.current);
      authTimeoutRef.current = null;
      if (clientRef.current) {
        try {
          const serverName = "inspector-server";
          const session = clientRef.current.getSession(serverName);
          if (session && session._healthCheckCleanup) {
            session._healthCheckCleanup();
            session._healthCheckCleanup = null;
          }
          await clientRef.current.closeSession(serverName);
        } catch (err) {
          if (!quiet) addLog("warn", "Error closing session:", err);
        }
      }
      clientRef.current = null;
      if (isMountedRef.current && !quiet) {
        setState("discovering");
        setTools([]);
        setResources([]);
        setResourceTemplates([]);
        setPrompts([]);
        setError(void 0);
        setAuthUrl(void 0);
      }
    },
    [addLog]
  );
  const failConnection = (0, import_react.useCallback)(
    (errorMessage, connectionError) => {
      addLog("error", errorMessage, connectionError ?? "");
      if (isMountedRef.current) {
        setState("failed");
        setError(errorMessage);
        const manualUrl = authProviderRef.current?.getLastAttemptedAuthUrl();
        if (manualUrl) {
          setAuthUrl(manualUrl);
          addLog(
            "info",
            "Manual authentication URL may be available.",
            manualUrl
          );
        }
      }
      connectingRef.current = false;
      if (url) {
        Tel.getInstance().trackUseMcpConnection({
          url,
          transportType,
          success: false,
          errorType: connectionError?.name || "UnknownError",
          hasOAuth: !!authProviderRef.current,
          hasSampling: !!samplingCallback,
          hasElicitation: !!onElicitation
        }).catch(() => {
        });
      }
    },
    [addLog, url, transportType, samplingCallback, onElicitation]
  );
  const connect = (0, import_react.useCallback)(async () => {
    if (!enabled || !url) {
      addLog(
        "debug",
        enabled ? "No server URL provided, skipping connection." : "Connection disabled via enabled flag."
      );
      return;
    }
    if (connectingRef.current) {
      addLog("debug", "Connection attempt already in progress.");
      return;
    }
    if (!isMountedRef.current) {
      addLog("debug", "Connect called after unmount, aborting.");
      return;
    }
    connectingRef.current = true;
    connectAttemptRef.current += 1;
    setError(void 0);
    setAuthUrl(void 0);
    successfulTransportRef.current = null;
    setState("discovering");
    addLog(
      "info",
      `Connecting attempt #${connectAttemptRef.current} to ${url}...`
    );
    if (!authProviderRef.current) {
      authProviderRef.current = new BrowserOAuthClientProvider(url, {
        storageKeyPrefix,
        clientName,
        clientUri,
        callbackUrl,
        preventAutoAuth,
        useRedirectFlow,
        onPopupWindow
      });
      addLog("debug", "BrowserOAuthClientProvider initialized in connect.");
    }
    if (!clientRef.current) {
      clientRef.current = new BrowserMCPClient();
      addLog("debug", "BrowserMCPClient initialized in connect.");
    }
    const tryConnectWithTransport = /* @__PURE__ */ __name(async (transportTypeParam, isAuthRetry = false) => {
      addLog(
        "info",
        `Attempting connection with transport: ${transportTypeParam}`
      );
      try {
        const serverName = "inspector-server";
        const serverConfig = {
          url,
          transport: transportTypeParam === "sse" ? "http" : transportTypeParam,
          // Disable SSE fallback when using explicit HTTP transport (not SSE)
          // This prevents automatic HTTP  SSE fallback at the connector level
          disableSseFallback: transportTypeParam === "http",
          // Use SSE transport when explicitly requested
          preferSse: transportTypeParam === "sse"
        };
        if (customHeaders && Object.keys(customHeaders).length > 0) {
          serverConfig.headers = customHeaders;
        }
        if (authProviderRef.current) {
          const tokens = await authProviderRef.current.tokens();
          if (tokens?.access_token) {
            serverConfig.headers = {
              ...serverConfig.headers,
              Authorization: `Bearer ${tokens.access_token}`
            };
          }
        }
        clientRef.current.addServer(serverName, {
          ...serverConfig,
          authProvider: authProviderRef.current,
          //  SDK handles OAuth automatically!
          clientOptions: clientConfig,
          //  Pass client config to connector
          samplingCallback,
          //  Pass sampling callback to connector
          elicitationCallback: onElicitation,
          //  Pass elicitation callback to connector
          wrapTransport: wrapTransport ? (transport) => {
            console.log(
              "[useMcp] Applying transport wrapper for server:",
              serverName,
              "url:",
              url
            );
            return wrapTransport(transport, url);
          } : void 0
        });
        const session = await clientRef.current.createSession(
          serverName,
          false
        );
        session.on("notification", (notification) => {
          onNotification?.(notification);
          if (notification.method === "notifications/tools/list_changed") {
            addLog("info", "Tools list changed, auto-refreshing...");
            refreshTools().catch(
              (err) => addLog("warn", "Auto-refresh tools failed:", err)
            );
          } else if (notification.method === "notifications/resources/list_changed") {
            addLog("info", "Resources list changed, auto-refreshing...");
            refreshResources().catch(
              (err) => addLog("warn", "Auto-refresh resources failed:", err)
            );
          } else if (notification.method === "notifications/prompts/list_changed") {
            addLog("info", "Prompts list changed, auto-refreshing...");
            refreshPrompts().catch(
              (err) => addLog("warn", "Auto-refresh prompts failed:", err)
            );
          }
        });
        await session.initialize();
        addLog("info", "\u2705 Successfully connected to MCP server");
        addLog("info", "Server info:", session.connector.serverInfo);
        addLog(
          "info",
          "Server capabilities:",
          session.connector.serverCapabilities
        );
        console.log("[useMcp] Server info:", session.connector.serverInfo);
        console.log(
          "[useMcp] Server capabilities:",
          session.connector.serverCapabilities
        );
        setState("ready");
        successfulTransportRef.current = transportTypeParam;
        const setupConnectionMonitoring = /* @__PURE__ */ __name(() => {
          let healthCheckInterval = null;
          let lastSuccessfulCheck = Date.now();
          const HEALTH_CHECK_INTERVAL = 1e4;
          const HEALTH_CHECK_TIMEOUT = 3e4;
          const checkConnectionHealth = /* @__PURE__ */ __name(async () => {
            if (!isMountedRef.current || stateRef.current !== "ready") {
              if (healthCheckInterval) {
                clearInterval(healthCheckInterval);
                healthCheckInterval = null;
              }
              return;
            }
            try {
              await session.connector.listTools();
              lastSuccessfulCheck = Date.now();
            } catch (err) {
              const timeSinceLastSuccess = Date.now() - lastSuccessfulCheck;
              if (timeSinceLastSuccess > HEALTH_CHECK_TIMEOUT) {
                addLog(
                  "warn",
                  `Connection appears to be broken (no response for ${Math.round(timeSinceLastSuccess / 1e3)}s), attempting to reconnect...`
                );
                if (healthCheckInterval) {
                  clearInterval(healthCheckInterval);
                  healthCheckInterval = null;
                }
                if (autoReconnectRef.current && isMountedRef.current) {
                  setState("discovering");
                  addLog("info", "Auto-reconnecting to MCP server...");
                  setTimeout(
                    () => {
                      if (isMountedRef.current && stateRef.current === "discovering") {
                        connect();
                      }
                    },
                    typeof autoReconnectRef.current === "number" ? autoReconnectRef.current : DEFAULT_RECONNECT_DELAY
                  );
                }
              }
            }
          }, "checkConnectionHealth");
          healthCheckInterval = setInterval(
            checkConnectionHealth,
            HEALTH_CHECK_INTERVAL
          );
          return () => {
            if (healthCheckInterval) {
              clearInterval(healthCheckInterval);
              healthCheckInterval = null;
            }
          };
        }, "setupConnectionMonitoring");
        if (autoReconnect) {
          const cleanup = setupConnectionMonitoring();
          session._healthCheckCleanup = cleanup;
        }
        Tel.getInstance().trackUseMcpConnection({
          url,
          transportType: transportTypeParam,
          success: true,
          hasOAuth: !!authProviderRef.current,
          hasSampling: !!samplingCallback,
          hasElicitation: !!onElicitation
        }).catch(() => {
        });
        setTools(session.connector.tools || []);
        const resourcesResult = await session.connector.listAllResources();
        setResources(resourcesResult.resources || []);
        const promptsResult = await session.connector.listPrompts();
        setPrompts(promptsResult.prompts || []);
        const serverInfo2 = session.connector.serverInfo;
        const capabilities2 = session.connector.serverCapabilities;
        if (serverInfo2) {
          console.log("[useMcp] Server info:", serverInfo2);
          setServerInfo(serverInfo2);
        }
        if (capabilities2) {
          console.log("[useMcp] Server capabilities:", capabilities2);
          setCapabilities(capabilities2);
        }
        return "success";
      } catch (err) {
        const error2 = err;
        const errorMessage = error2?.message || String(err);
        if (error2.code === 401 || errorMessage.includes("401") || errorMessage.includes("Unauthorized")) {
          if (authProviderRef.current) {
            addLog(
              "info",
              "Authentication required. OAuth provider available."
            );
            try {
              const { auth: auth2 } = await import("@mcp-use/modelcontextprotocol-sdk/client/auth.js");
              const baseUrl = new URL(url).origin;
              auth2(authProviderRef.current, { serverUrl: baseUrl }).catch(
                () => {
                }
              );
              setTimeout(() => {
                if (isMountedRef.current) {
                  const manualUrl = authProviderRef.current?.getLastAttemptedAuthUrl();
                  if (manualUrl) {
                    setAuthUrl(manualUrl);
                    addLog(
                      "info",
                      "Manual authentication URL available:",
                      manualUrl
                    );
                  } else {
                    addLog("warn", "Could not generate authentication URL");
                  }
                }
              }, 100);
            } catch (authGenError) {
              addLog("warn", "Error generating auth URL:", authGenError);
            }
            if (isMountedRef.current) {
              setState("pending_auth");
            }
            connectingRef.current = false;
            return "auth_redirect";
          }
          if (customHeaders && Object.keys(customHeaders).length > 0) {
            failConnection(
              "Authentication failed: Server returned 401 Unauthorized. Check your Authorization header value is correct."
            );
            return "failed";
          }
          failConnection(
            "Authentication required: Server returned 401 Unauthorized. Add an Authorization header in the Custom Headers section (e.g., Authorization: Bearer YOUR_API_KEY)."
          );
          return "failed";
        }
        failConnection(
          errorMessage,
          error2 instanceof Error ? error2 : new Error(String(error2))
        );
        return "failed";
      }
    }, "tryConnectWithTransport");
    let finalStatus = "failed";
    if (transportType === "sse") {
      addLog("debug", "Using SSE-only transport mode");
      finalStatus = await tryConnectWithTransport("sse");
    } else if (transportType === "http") {
      addLog("debug", "Using HTTP-only transport mode");
      finalStatus = await tryConnectWithTransport("http");
    } else {
      addLog("debug", "Using auto transport mode (HTTP with SSE fallback)");
      const httpResult = await tryConnectWithTransport("http");
      if (httpResult === "fallback" && isMountedRef.current && stateRef.current !== "authenticating") {
        addLog("info", "HTTP failed, attempting SSE fallback...");
        const sseResult = await tryConnectWithTransport("sse");
        finalStatus = sseResult;
      } else {
        finalStatus = httpResult;
      }
    }
    if (finalStatus === "success" || finalStatus === "failed" || finalStatus === "auth_redirect") {
      connectingRef.current = false;
    }
    addLog("debug", `Connection sequence finished with status: ${finalStatus}`);
  }, [
    addLog,
    failConnection,
    disconnect,
    url,
    storageKeyPrefix,
    clientName,
    clientUri,
    callbackUrl,
    clientConfig.name,
    clientConfig.version,
    customHeaders,
    transportType,
    preventAutoAuth,
    useRedirectFlow,
    onPopupWindow,
    enabled,
    timeout,
    sseReadTimeout
  ]);
  const callTool = (0, import_react.useCallback)(
    async (name, args, options2) => {
      if (stateRef.current !== "ready" || !clientRef.current) {
        throw new Error(
          `MCP client is not ready (current state: ${state}). Cannot call tool "${name}".`
        );
      }
      addLog("info", `Calling tool: ${name}`, args);
      const startTime = Date.now();
      try {
        const serverName = "inspector-server";
        const session = clientRef.current.getSession(serverName);
        if (!session) {
          throw new Error("No active session found");
        }
        const result = await session.connector.callTool(
          name,
          args || {},
          options2
        );
        addLog("info", `Tool "${name}" call successful:`, result);
        Tel.getInstance().trackUseMcpToolCall({
          toolName: name,
          success: true,
          executionTimeMs: Date.now() - startTime
        }).catch(() => {
        });
        return result;
      } catch (err) {
        addLog("error", `Tool "${name}" call failed:`, err);
        Tel.getInstance().trackUseMcpToolCall({
          toolName: name,
          success: false,
          errorType: err instanceof Error ? err.name : "UnknownError",
          executionTimeMs: Date.now() - startTime
        }).catch(() => {
        });
        throw err;
      }
    },
    [state]
  );
  const retry = (0, import_react.useCallback)(() => {
    if (stateRef.current === "failed") {
      addLog("info", "Retry requested...");
      connect();
    } else {
      addLog(
        "warn",
        `Retry called but state is not 'failed' (state: ${stateRef.current}). Ignoring.`
      );
    }
  }, [addLog, connect]);
  const authenticate = (0, import_react.useCallback)(async () => {
    addLog("info", "Manual authentication requested...");
    const currentState = stateRef.current;
    if (currentState === "failed") {
      addLog("info", "Attempting to reconnect and authenticate via retry...");
      retry();
    } else if (currentState === "pending_auth") {
      addLog("info", "Proceeding with authentication from pending state...");
      try {
        assert(
          authProviderRef.current,
          "Auth Provider not available for manual auth"
        );
        assert(url, "Server URL is required for authentication");
        addLog("info", "Clearing all OAuth state and initiating fresh flow...");
        const hashPrefix = `${storageKeyPrefix}:${authProviderRef.current.serverUrlHash}`;
        Object.keys(localStorage).forEach((key) => {
          if (key.startsWith(hashPrefix)) {
            addLog("debug", `Removing stale OAuth key: ${key}`);
            localStorage.removeItem(key);
          }
          if (key.startsWith(`${storageKeyPrefix}:state_`)) {
            addLog("debug", `Removing orphaned state: ${key}`);
            localStorage.removeItem(key);
          }
        });
        setState("authenticating");
        const freshAuthProvider = new BrowserOAuthClientProvider(url, {
          storageKeyPrefix,
          clientName,
          clientUri,
          callbackUrl,
          preventAutoAuth: false,
          //  Allow OAuth to proceed
          useRedirectFlow,
          onPopupWindow
        });
        authProviderRef.current = freshAuthProvider;
        addLog("info", "Triggering fresh OAuth authorization...");
        const { auth: auth2 } = await import("@mcp-use/modelcontextprotocol-sdk/client/auth.js");
        const baseUrl = new URL(url).origin;
        auth2(freshAuthProvider, {
          serverUrl: baseUrl
        }).catch((err) => {
          addLog(
            "info",
            "OAuth flow initiated:",
            err instanceof Error ? err.message : "Redirecting..."
          );
        });
      } catch (authError) {
        if (!isMountedRef.current) return;
        setState("pending_auth");
        addLog(
          "error",
          `Manual authentication failed: ${authError instanceof Error ? authError.message : String(authError)}`
        );
      }
    } else if (currentState === "authenticating") {
      addLog(
        "warn",
        "Already attempting authentication. Check for blocked popups or wait for timeout."
      );
      const manualUrl = authProviderRef.current?.getLastAttemptedAuthUrl();
      if (manualUrl && !authUrl) {
        setAuthUrl(manualUrl);
        addLog("info", "Manual authentication URL retrieved:", manualUrl);
      }
    } else {
      addLog(
        "info",
        `Client not in a state requiring manual authentication trigger (state: ${currentState}). If needed, try disconnecting and reconnecting.`
      );
    }
  }, [
    addLog,
    retry,
    authUrl,
    url,
    useRedirectFlow,
    onPopupWindow,
    storageKeyPrefix,
    clientName,
    clientUri,
    callbackUrl
  ]);
  const clearStorage = (0, import_react.useCallback)(() => {
    if (authProviderRef.current) {
      const count = authProviderRef.current.clearStorage();
      addLog("info", `Cleared ${count} item(s) from localStorage for ${url}.`);
      setAuthUrl(void 0);
      disconnect();
    } else {
      addLog("warn", "Auth provider not initialized, cannot clear storage.");
    }
  }, [url, addLog, disconnect]);
  const listResources = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      throw new Error(
        `MCP client is not ready (current state: ${state}). Cannot list resources.`
      );
    }
    addLog("info", "Listing resources");
    try {
      const serverName = "inspector-server";
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        throw new Error("No active session found");
      }
      const resourcesResult = await session.connector.listAllResources();
      setResources(resourcesResult.resources || []);
      addLog("info", "Resources listed successfully");
    } catch (err) {
      addLog("error", "List resources failed:", err);
      throw err;
    }
  }, [state]);
  const readResource = (0, import_react.useCallback)(
    async (uri) => {
      if (stateRef.current !== "ready" || !clientRef.current) {
        throw new Error(
          `MCP client is not ready (current state: ${state}). Cannot read resource.`
        );
      }
      addLog("info", `Reading resource: ${uri}`);
      try {
        const serverName = "inspector-server";
        const session = clientRef.current.getSession(serverName);
        if (!session) {
          throw new Error("No active session found");
        }
        const result = await session.connector.readResource(uri);
        addLog("info", "Resource read successful:", result);
        Tel.getInstance().trackUseMcpResourceRead({
          resourceUri: uri,
          success: true
        }).catch(() => {
        });
        return result;
      } catch (err) {
        addLog("error", "Resource read failed:", err);
        Tel.getInstance().trackUseMcpResourceRead({
          resourceUri: uri,
          success: false,
          errorType: err instanceof Error ? err.name : "UnknownError"
        }).catch(() => {
        });
        throw err;
      }
    },
    [state]
  );
  const listPrompts = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      throw new Error(
        `MCP client is not ready (current state: ${state}). Cannot list prompts.`
      );
    }
    addLog("info", "Listing prompts");
    try {
      const serverName = "inspector-server";
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        throw new Error("No active session found");
      }
      const promptsResult = await session.connector.listPrompts();
      setPrompts(promptsResult.prompts || []);
      addLog("info", "Prompts listed successfully");
    } catch (err) {
      addLog("error", "List prompts failed:", err);
      throw err;
    }
  }, [state]);
  const refreshTools = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      addLog("debug", "Cannot refresh tools - client not ready");
      return;
    }
    addLog("debug", "Refreshing tools list");
    try {
      const serverName = "inspector-server";
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        addLog("warn", "No active session found for tools refresh");
        return;
      }
      const toolsResult = await session.connector.listTools();
      setTools(toolsResult || []);
      addLog("info", "Tools list refreshed successfully");
    } catch (err) {
      addLog("warn", "Failed to refresh tools:", err);
    }
  }, [addLog]);
  const refreshResources = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      addLog("debug", "Cannot refresh resources - client not ready");
      return;
    }
    addLog("debug", "Refreshing resources list");
    try {
      const serverName = "inspector-server";
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        addLog("warn", "No active session found for resources refresh");
        return;
      }
      const resourcesResult = await session.connector.listAllResources();
      setResources(resourcesResult.resources || []);
      addLog("info", "Resources list refreshed successfully");
    } catch (err) {
      addLog("warn", "Failed to refresh resources:", err);
    }
  }, [addLog]);
  const refreshPrompts = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      addLog("debug", "Cannot refresh prompts - client not ready");
      return;
    }
    addLog("debug", "Refreshing prompts list");
    try {
      const serverName = "inspector-server";
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        addLog("warn", "No active session found for prompts refresh");
        return;
      }
      const promptsResult = await session.connector.listPrompts();
      setPrompts(promptsResult.prompts || []);
      addLog("info", "Prompts list refreshed successfully");
    } catch (err) {
      addLog("warn", "Failed to refresh prompts:", err);
    }
  }, [addLog]);
  const refreshAll = (0, import_react.useCallback)(async () => {
    addLog("info", "Refreshing all lists (tools, resources, prompts)");
    await Promise.all([refreshTools(), refreshResources(), refreshPrompts()]);
  }, [refreshTools, refreshResources, refreshPrompts, addLog]);
  const getPrompt = (0, import_react.useCallback)(
    async (name, args) => {
      if (stateRef.current !== "ready" || !clientRef.current) {
        throw new Error(
          `MCP client is not ready (current state: ${state}). Cannot get prompt.`
        );
      }
      addLog("info", `Getting prompt: ${name}`, args);
      try {
        const serverName = "inspector-server";
        const session = clientRef.current.getSession(serverName);
        if (!session) {
          throw new Error("No active session found");
        }
        const result = await session.connector.getPrompt(name, args || {});
        addLog("info", `Prompt "${name}" retrieved successfully:`, result);
        return result;
      } catch (err) {
        addLog("error", `Prompt "${name}" retrieval failed:`, err);
        throw err;
      }
    },
    [state]
  );
  const connectRef = (0, import_react.useRef)(connect);
  const failConnectionRef = (0, import_react.useRef)(failConnection);
  (0, import_react.useEffect)(() => {
    connectRef.current = connect;
    failConnectionRef.current = failConnection;
  });
  (0, import_react.useEffect)(() => {
    const messageHandler = /* @__PURE__ */ __name((event) => {
      if (event.origin !== window.location.origin) return;
      if (event.data?.type === "mcp_auth_callback") {
        addLog("info", "Received auth callback message.", event.data);
        if (authTimeoutRef.current) clearTimeout(authTimeoutRef.current);
        authTimeoutRef.current = null;
        if (event.data.success) {
          addLog(
            "info",
            "Authentication successful via popup. Reconnecting client..."
          );
          if (connectingRef.current) {
            addLog(
              "debug",
              "Connection attempt already in progress, resetting flag to allow reconnection."
            );
          }
          connectingRef.current = false;
          setTimeout(() => {
            if (isMountedRef.current) {
              addLog(
                "debug",
                "Initiating reconnection after successful auth callback."
              );
              connectRef.current();
            }
          }, 100);
        } else {
          failConnectionRef.current(
            `Authentication failed in callback: ${event.data.error || "Unknown reason."}`
          );
        }
      }
    }, "messageHandler");
    window.addEventListener("message", messageHandler);
    addLog("debug", "Auth callback message listener added.");
    return () => {
      window.removeEventListener("message", messageHandler);
      addLog("debug", "Auth callback message listener removed.");
      if (authTimeoutRef.current) clearTimeout(authTimeoutRef.current);
    };
  }, [addLog]);
  (0, import_react.useEffect)(() => {
    isMountedRef.current = true;
    if (!enabled || !url) {
      addLog(
        "debug",
        enabled ? "No server URL provided, skipping connection." : "Connection disabled via enabled flag."
      );
      setState("discovering");
      return () => {
        isMountedRef.current = false;
      };
    }
    addLog("debug", "useMcp mounted, initiating connection.");
    connectAttemptRef.current = 0;
    if (!authProviderRef.current || authProviderRef.current.serverUrl !== url) {
      authProviderRef.current = new BrowserOAuthClientProvider(url, {
        storageKeyPrefix,
        clientName,
        clientUri,
        callbackUrl,
        preventAutoAuth,
        useRedirectFlow,
        onPopupWindow
      });
      addLog(
        "debug",
        "BrowserOAuthClientProvider initialized/updated on mount/option change."
      );
    }
    connect();
    return () => {
      isMountedRef.current = false;
      addLog("debug", "useMcp unmounting, disconnecting.");
      disconnect(true);
    };
  }, [
    url,
    enabled,
    storageKeyPrefix,
    callbackUrl,
    clientName,
    clientUri,
    clientConfig.name,
    clientConfig.version,
    useRedirectFlow
  ]);
  (0, import_react.useEffect)(() => {
    let retryTimeoutId = null;
    if (state === "failed" && autoRetry && connectAttemptRef.current > 0) {
      const delay = typeof autoRetry === "number" ? autoRetry : DEFAULT_RETRY_DELAY;
      addLog("info", `Connection failed, auto-retrying in ${delay}ms...`);
      retryTimeoutId = setTimeout(() => {
        if (isMountedRef.current && stateRef.current === "failed") {
          retry();
        }
      }, delay);
    }
    return () => {
      if (retryTimeoutId) clearTimeout(retryTimeoutId);
    };
  }, [state, autoRetry, retry, addLog]);
  return {
    state,
    tools,
    resources,
    resourceTemplates,
    prompts,
    serverInfo,
    capabilities,
    error,
    log,
    authUrl,
    client: clientRef.current,
    callTool,
    readResource,
    listResources,
    listPrompts,
    getPrompt,
    refreshTools,
    refreshResources,
    refreshPrompts,
    refreshAll,
    retry,
    disconnect,
    authenticate,
    clearStorage
  };
}
__name(useMcp, "useMcp");

// src/auth/callback.ts
var import_auth = require("@mcp-use/modelcontextprotocol-sdk/client/auth.js");
async function onMcpAuthorization() {
  const queryParams = new URLSearchParams(window.location.search);
  const code = queryParams.get("code");
  const state = queryParams.get("state");
  const error = queryParams.get("error");
  const errorDescription = queryParams.get("error_description");
  const logPrefix = "[mcp-callback]";
  console.log(`${logPrefix} Handling callback...`, {
    code,
    state,
    error,
    errorDescription
  });
  let provider = null;
  let storedStateData = null;
  const stateKey = state ? `mcp:auth:state_${state}` : null;
  try {
    if (error) {
      throw new Error(
        `OAuth error: ${error} - ${errorDescription || "No description provided."}`
      );
    }
    if (!code) {
      throw new Error(
        "Authorization code not found in callback query parameters."
      );
    }
    if (!state || !stateKey) {
      throw new Error(
        "State parameter not found or invalid in callback query parameters."
      );
    }
    const storedStateJSON = localStorage.getItem(stateKey);
    if (!storedStateJSON) {
      throw new Error(
        `Invalid or expired state parameter "${state}". No matching state found in storage.`
      );
    }
    try {
      storedStateData = JSON.parse(storedStateJSON);
    } catch (e) {
      throw new Error("Failed to parse stored OAuth state.");
    }
    if (!storedStateData.expiry || storedStateData.expiry < Date.now()) {
      localStorage.removeItem(stateKey);
      throw new Error(
        "OAuth state has expired. Please try initiating authentication again."
      );
    }
    if (!storedStateData.providerOptions) {
      throw new Error("Stored state is missing required provider options.");
    }
    const { serverUrl, ...providerOptions } = storedStateData.providerOptions;
    console.log(
      `${logPrefix} Re-instantiating provider for server: ${serverUrl}`
    );
    provider = new BrowserOAuthClientProvider(serverUrl, providerOptions);
    console.log(`${logPrefix} Calling SDK auth() to exchange code...`);
    const baseUrl = new URL(serverUrl).origin;
    const authResult = await (0, import_auth.auth)(provider, {
      serverUrl: baseUrl,
      authorizationCode: code
    });
    if (authResult === "AUTHORIZED") {
      console.log(`${logPrefix} Authorization successful via SDK auth().`);
      const isRedirectFlow = storedStateData.flowType === "redirect";
      if (isRedirectFlow && storedStateData.returnUrl) {
        console.log(
          `${logPrefix} Redirect flow complete. Returning to: ${storedStateData.returnUrl}`
        );
        localStorage.removeItem(stateKey);
        window.location.href = storedStateData.returnUrl;
      } else if (window.opener && !window.opener.closed) {
        console.log(`${logPrefix} Popup flow complete. Notifying opener...`);
        window.opener.postMessage(
          { type: "mcp_auth_callback", success: true },
          window.location.origin
        );
        localStorage.removeItem(stateKey);
        window.close();
      } else {
        console.warn(
          `${logPrefix} No opener window or return URL detected. Redirecting to root.`
        );
        localStorage.removeItem(stateKey);
        const pathParts = window.location.pathname.split("/").filter(Boolean);
        const basePath = pathParts.length > 0 && pathParts[pathParts.length - 1] === "callback" ? "/" + pathParts.slice(0, -2).join("/") : "/";
        window.location.href = basePath || "/";
      }
    } else {
      console.warn(
        `${logPrefix} SDK auth() returned unexpected status: ${authResult}`
      );
      throw new Error(
        `Unexpected result from authentication library: ${authResult}`
      );
    }
  } catch (err) {
    console.error(`${logPrefix} Error during OAuth callback handling:`, err);
    const errorMessage = err instanceof Error ? err.message : String(err);
    if (window.opener && !window.opener.closed) {
      window.opener.postMessage(
        { type: "mcp_auth_callback", success: false, error: errorMessage },
        window.location.origin
      );
    }
    try {
      document.body.innerHTML = "";
      const container = document.createElement("div");
      container.style.fontFamily = "sans-serif";
      container.style.padding = "20px";
      const heading = document.createElement("h1");
      heading.textContent = "Authentication Error";
      container.appendChild(heading);
      const errorPara = document.createElement("p");
      errorPara.style.color = "red";
      errorPara.style.backgroundColor = "#ffebeb";
      errorPara.style.border = "1px solid red";
      errorPara.style.padding = "10px";
      errorPara.style.borderRadius = "4px";
      errorPara.textContent = errorMessage;
      container.appendChild(errorPara);
      const closePara = document.createElement("p");
      closePara.textContent = "You can close this window or ";
      const closeLink = document.createElement("a");
      closeLink.href = "#";
      closeLink.textContent = "click here to close";
      closeLink.onclick = (e) => {
        e.preventDefault();
        window.close();
        return false;
      };
      closePara.appendChild(closeLink);
      closePara.appendChild(document.createTextNode("."));
      container.appendChild(closePara);
      if (err instanceof Error && err.stack) {
        const stackPre = document.createElement("pre");
        stackPre.style.fontSize = "0.8em";
        stackPre.style.color = "#555";
        stackPre.style.marginTop = "20px";
        stackPre.style.whiteSpace = "pre-wrap";
        stackPre.textContent = err.stack;
        container.appendChild(stackPre);
      }
      document.body.appendChild(container);
    } catch (displayError) {
      console.error(
        `${logPrefix} Could not display error in callback window:`,
        displayError
      );
    }
    if (stateKey) {
      localStorage.removeItem(stateKey);
    }
    if (provider) {
      localStorage.removeItem(provider.getKey("code_verifier"));
      localStorage.removeItem(provider.getKey("last_auth_url"));
    }
  }
}
__name(onMcpAuthorization, "onMcpAuthorization");

// src/react/ErrorBoundary.tsx
var import_react2 = __toESM(require("react"), 1);
var ErrorBoundary = class extends import_react2.default.Component {
  static {
    __name(this, "ErrorBoundary");
  }
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, errorInfo) {
    console.error("Widget Error:", error, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      return /* @__PURE__ */ import_react2.default.createElement("div", { className: "p-4 border border-red-500 bg-red-50 text-red-900 rounded-md dark:bg-red-900/20 dark:text-red-100" }, /* @__PURE__ */ import_react2.default.createElement("h3", { className: "font-bold mb-2" }, "Widget Error"), /* @__PURE__ */ import_react2.default.createElement("pre", { className: "text-sm whitespace-pre-wrap" }, this.state.error?.message));
    }
    return this.props.children;
  }
};

// src/react/Image.tsx
var import_react3 = __toESM(require("react"), 1);
var Image = /* @__PURE__ */ __name(({ src, ...props }) => {
  const publicUrl = typeof window !== "undefined" ? window.__mcpPublicAssetsUrl || window.__mcpPublicUrl || "" : "";
  const getFinalSrc = /* @__PURE__ */ __name((source) => {
    if (!source) return source;
    if (source.startsWith("http://") || source.startsWith("https://") || source.startsWith("data:")) {
      return source;
    }
    if (!publicUrl) {
      return source;
    }
    const cleanSrc = source.startsWith("/") ? source.slice(1) : source;
    return `${publicUrl}/${cleanSrc}`;
  }, "getFinalSrc");
  const finalSrc = getFinalSrc(src);
  return /* @__PURE__ */ import_react3.default.createElement("img", { src: finalSrc, ...props });
}, "Image");

// src/react/ThemeProvider.tsx
var import_react5 = __toESM(require("react"), 1);

// src/react/useWidget.ts
var import_react4 = require("react");

// src/react/widget-types.ts
var SET_GLOBALS_EVENT_TYPE = "openai:set_globals";

// src/react/useWidget.ts
function useOpenAiGlobal(key) {
  return (0, import_react4.useSyncExternalStore)(
    (onChange) => {
      const handleSetGlobal = /* @__PURE__ */ __name((event) => {
        const customEvent = event;
        const value = customEvent.detail.globals[key];
        if (value === void 0) {
          return;
        }
        onChange();
      }, "handleSetGlobal");
      if (typeof window !== "undefined") {
        window.addEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobal);
      }
      return () => {
        if (typeof window !== "undefined") {
          window.removeEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobal);
        }
      };
    },
    () => typeof window !== "undefined" && window.openai ? window.openai[key] : void 0
  );
}
__name(useOpenAiGlobal, "useOpenAiGlobal");
function useWidget(defaultProps) {
  const [isOpenAiAvailable, setIsOpenAiAvailable] = (0, import_react4.useState)(
    () => typeof window !== "undefined" && !!window.openai
  );
  (0, import_react4.useEffect)(() => {
    if (typeof window !== "undefined" && window.openai) {
      setIsOpenAiAvailable(true);
      return;
    }
    const checkInterval = setInterval(() => {
      if (typeof window !== "undefined" && window.openai) {
        setIsOpenAiAvailable(true);
        clearInterval(checkInterval);
      }
    }, 100);
    const handleSetGlobals = /* @__PURE__ */ __name(() => {
      if (typeof window !== "undefined" && window.openai) {
        setIsOpenAiAvailable(true);
        clearInterval(checkInterval);
      }
    }, "handleSetGlobals");
    if (typeof window !== "undefined") {
      window.addEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobals);
    }
    const timeout = setTimeout(() => {
      clearInterval(checkInterval);
      if (typeof window !== "undefined") {
        window.removeEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobals);
      }
    }, 5e3);
    return () => {
      clearInterval(checkInterval);
      clearTimeout(timeout);
      if (typeof window !== "undefined") {
        window.removeEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobals);
      }
    };
  }, []);
  const provider = (0, import_react4.useMemo)(() => {
    return isOpenAiAvailable ? "openai" : "mcp-ui";
  }, [isOpenAiAvailable]);
  const searchString = typeof window !== "undefined" ? window.location.search : "";
  const urlParams = (0, import_react4.useMemo)(() => {
    const urlParams2 = new URLSearchParams(searchString);
    if (urlParams2.has("mcpUseParams")) {
      return JSON.parse(urlParams2.get("mcpUseParams"));
    }
    return {
      toolInput: {},
      toolOutput: {},
      toolId: ""
    };
  }, [searchString]);
  const toolInput = provider === "openai" ? useOpenAiGlobal("toolInput") : urlParams.toolInput;
  const toolOutput = provider === "openai" ? useOpenAiGlobal("toolOutput") : urlParams.toolOutput;
  const toolResponseMetadata = useOpenAiGlobal("toolResponseMetadata");
  const widgetProps = (0, import_react4.useMemo)(() => {
    if (toolResponseMetadata && typeof toolResponseMetadata === "object") {
      const metaProps = toolResponseMetadata["mcp-use/props"];
      if (metaProps) {
        return metaProps;
      }
    }
    return defaultProps || {};
  }, [toolResponseMetadata, defaultProps]);
  const widgetState = useOpenAiGlobal("widgetState");
  const theme = useOpenAiGlobal("theme");
  const displayMode = useOpenAiGlobal("displayMode");
  const safeArea = useOpenAiGlobal("safeArea");
  const maxHeight = useOpenAiGlobal("maxHeight");
  const userAgent = useOpenAiGlobal("userAgent");
  const locale = useOpenAiGlobal("locale");
  const mcp_url = (0, import_react4.useMemo)(() => {
    if (typeof window !== "undefined" && window.__mcpPublicUrl) {
      return window.__mcpPublicUrl.replace(/\/mcp-use\/public$/, "");
    }
    return "";
  }, []);
  const [localWidgetState, setLocalWidgetState] = (0, import_react4.useState)(null);
  (0, import_react4.useEffect)(() => {
    if (widgetState !== void 0) {
      setLocalWidgetState(widgetState);
    }
  }, [widgetState]);
  const callTool = (0, import_react4.useCallback)(
    async (name, args) => {
      if (!window.openai?.callTool) {
        throw new Error("window.openai.callTool is not available");
      }
      return window.openai.callTool(name, args);
    },
    []
  );
  const sendFollowUpMessage = (0, import_react4.useCallback)(
    async (prompt) => {
      if (!window.openai?.sendFollowUpMessage) {
        throw new Error("window.openai.sendFollowUpMessage is not available");
      }
      return window.openai.sendFollowUpMessage({ prompt });
    },
    []
  );
  const openExternal = (0, import_react4.useCallback)((href) => {
    if (!window.openai?.openExternal) {
      throw new Error("window.openai.openExternal is not available");
    }
    window.openai.openExternal({ href });
  }, []);
  const requestDisplayMode = (0, import_react4.useCallback)(
    async (mode) => {
      if (!window.openai?.requestDisplayMode) {
        throw new Error("window.openai.requestDisplayMode is not available");
      }
      return window.openai.requestDisplayMode({ mode });
    },
    []
  );
  const setState = (0, import_react4.useCallback)(
    async (state) => {
      if (!window.openai?.setWidgetState) {
        throw new Error("window.openai.setWidgetState is not available");
      }
      const currentState = widgetState !== void 0 ? widgetState : localWidgetState;
      const newState = typeof state === "function" ? state(currentState) : state;
      setLocalWidgetState(newState);
      return window.openai.setWidgetState(newState);
    },
    [widgetState, localWidgetState]
  );
  const isPending = (0, import_react4.useMemo)(() => {
    return provider === "openai" && toolResponseMetadata === null;
  }, [provider, toolResponseMetadata]);
  return {
    // Props and state (with defaults)
    props: widgetProps,
    toolInput: toolInput || {},
    output: toolOutput ?? null,
    metadata: toolResponseMetadata ?? null,
    state: localWidgetState,
    setState,
    // Layout and theme (with safe defaults)
    theme: theme || "light",
    displayMode: displayMode || "inline",
    safeArea: safeArea || { insets: { top: 0, bottom: 0, left: 0, right: 0 } },
    maxHeight: maxHeight || 600,
    userAgent: userAgent || {
      device: { type: "desktop" },
      capabilities: { hover: true, touch: false }
    },
    locale: locale || "en",
    mcp_url,
    // Actions
    callTool,
    sendFollowUpMessage,
    openExternal,
    requestDisplayMode,
    // Availability
    isAvailable: isOpenAiAvailable,
    isPending
  };
}
__name(useWidget, "useWidget");
function useWidgetProps(defaultProps) {
  const { props } = useWidget(defaultProps);
  return props;
}
__name(useWidgetProps, "useWidgetProps");
function useWidgetTheme() {
  const { theme } = useWidget();
  return theme;
}
__name(useWidgetTheme, "useWidgetTheme");
function useWidgetState(defaultState) {
  const { state, setState } = useWidget();
  (0, import_react4.useEffect)(() => {
    if (state === null && defaultState !== void 0 && window.openai?.setWidgetState) {
      setState(defaultState);
    }
  }, []);
  return [state, setState];
}
__name(useWidgetState, "useWidgetState");

// src/react/ThemeProvider.tsx
var ThemeProvider = /* @__PURE__ */ __name(({
  children
}) => {
  const { theme, isAvailable } = useWidget();
  console.log("theme", theme);
  const [systemPreference, setSystemPreference] = (0, import_react5.useState)(
    () => {
      if (typeof window === "undefined") return "light";
      return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
  );
  (0, import_react5.useEffect)(() => {
    if (typeof window === "undefined") return;
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    const handleChange = /* @__PURE__ */ __name((e) => {
      setSystemPreference(e.matches ? "dark" : "light");
    }, "handleChange");
    mediaQuery.addEventListener("change", handleChange);
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, []);
  const effectiveTheme = isAvailable ? theme : systemPreference;
  (0, import_react5.useLayoutEffect)(() => {
    if (typeof document === "undefined") return;
    if (effectiveTheme === "dark") {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  }, [effectiveTheme]);
  return /* @__PURE__ */ import_react5.default.createElement(import_react5.default.Fragment, null, children);
}, "ThemeProvider");

// src/react/WidgetControls.tsx
var import_react6 = __toESM(require("react"), 1);
function WidgetControls({
  children,
  className = "",
  position = "top-right",
  attachTo,
  showLabels = true,
  debugger: enableDebugger = false,
  viewControls = false
}) {
  const {
    props,
    output,
    metadata,
    state,
    theme,
    displayMode,
    safeArea,
    maxHeight,
    userAgent,
    locale,
    isAvailable,
    callTool,
    sendFollowUpMessage,
    openExternal,
    requestDisplayMode,
    setState
  } = useWidget();
  const [isHovered, setIsHovered] = (0, import_react6.useState)(false);
  const [isOverlayOpen, setIsOverlayOpen] = (0, import_react6.useState)(false);
  const containerRef = (0, import_react6.useRef)(null);
  const overlayRef = (0, import_react6.useRef)(null);
  const [windowOpenAiKeys, setWindowOpenAiKeys] = (0, import_react6.useState)([]);
  const [actionResult, setActionResult] = (0, import_react6.useState)("");
  const [toolName, setToolName] = (0, import_react6.useState)("get-my-city");
  const [toolArgs, setToolArgs] = (0, import_react6.useState)("{}");
  const [followUpMessage, setFollowUpMessage] = (0, import_react6.useState)(
    "Test follow-up message"
  );
  const [externalUrl, setExternalUrl] = (0, import_react6.useState)(
    "https://docs.mcp-use.com"
  );
  const isFullscreen = displayMode === "fullscreen" && isAvailable;
  const isPip = displayMode === "pip" && isAvailable;
  const isInInspector = typeof window !== "undefined" && window.location.pathname.includes("/inspector/api/");
  (0, import_react6.useEffect)(() => {
    const timeoutId = setTimeout(() => {
      if (typeof window !== "undefined" && window.openai) {
        try {
          const keys = Object.keys(window.openai);
          setWindowOpenAiKeys(keys);
        } catch (e) {
          setWindowOpenAiKeys([]);
        }
      } else {
        setWindowOpenAiKeys([]);
      }
    }, 100);
    return () => {
      clearTimeout(timeoutId);
    };
  }, []);
  const isDark = theme === "dark";
  const getPositionClasses = /* @__PURE__ */ __name(() => {
    const baseClasses = [
      "absolute",
      "z-[1000]",
      "flex",
      "gap-2",
      "transition-opacity",
      "duration-200",
      "ease-in-out",
      isHovered ? "opacity-100" : "opacity-0",
      isHovered ? "pointer-events-auto" : "pointer-events-none"
    ];
    switch (position) {
      case "top-left":
        return [...baseClasses, "top-4", "left-4"];
      case "top-center":
        return [...baseClasses, "top-4", "left-1/2", "-translate-x-1/2"];
      case "top-right":
        return [...baseClasses, "top-4", "right-4"];
      case "center-left":
        return [...baseClasses, "top-1/2", "left-4", "-translate-y-1/2"];
      case "center-right":
        return [...baseClasses, "top-1/2", "right-4", "-translate-y-1/2"];
      case "bottom-left":
        return [...baseClasses, "bottom-4", "left-4"];
      case "bottom-center":
        return [...baseClasses, "bottom-4", "left-1/2", "-translate-x-1/2"];
      case "bottom-right":
        return [...baseClasses, "bottom-4", "right-4"];
      default:
        return [...baseClasses, "top-4", "right-4"];
    }
  }, "getPositionClasses");
  const getPositionOffsetStyles = /* @__PURE__ */ __name(() => {
    const baseOffset = 16;
    const topOffset = safeArea?.insets?.top ? Math.max(baseOffset, safeArea.insets.top + 8) : baseOffset;
    const rightOffset = safeArea?.insets?.right ? Math.max(baseOffset, safeArea.insets.right + 8) : baseOffset;
    const bottomOffset = safeArea?.insets?.bottom ? Math.max(baseOffset, safeArea.insets.bottom + 8) : baseOffset;
    const leftOffset = safeArea?.insets?.left ? Math.max(baseOffset, safeArea.insets.left + 8) : baseOffset;
    const styles = {};
    switch (position) {
      case "top-left":
        styles.top = `${topOffset}px`;
        styles.left = `${leftOffset}px`;
        break;
      case "top-center":
        styles.top = `${topOffset}px`;
        break;
      case "top-right":
        styles.top = `${topOffset}px`;
        styles.right = `${rightOffset}px`;
        break;
      case "center-left":
        styles.left = `${leftOffset}px`;
        break;
      case "center-right":
        styles.right = `${rightOffset}px`;
        break;
      case "bottom-left":
        styles.bottom = `${bottomOffset}px`;
        styles.left = `${leftOffset}px`;
        break;
      case "bottom-center":
        styles.bottom = `${bottomOffset}px`;
        break;
      case "bottom-right":
        styles.bottom = `${bottomOffset}px`;
        styles.right = `${rightOffset}px`;
        break;
      default:
        styles.top = `${topOffset}px`;
        styles.right = `${rightOffset}px`;
        break;
    }
    return styles;
  }, "getPositionOffsetStyles");
  (0, import_react6.useEffect)(() => {
    if (!attachTo) return;
    const handleMouseEnter = /* @__PURE__ */ __name(() => setIsHovered(true), "handleMouseEnter");
    const handleMouseLeave = /* @__PURE__ */ __name(() => setIsHovered(false), "handleMouseLeave");
    attachTo.addEventListener("mouseenter", handleMouseEnter);
    attachTo.addEventListener("mouseleave", handleMouseLeave);
    return () => {
      attachTo.removeEventListener("mouseenter", handleMouseEnter);
      attachTo.removeEventListener("mouseleave", handleMouseLeave);
    };
  }, [attachTo]);
  (0, import_react6.useEffect)(() => {
    if (!isOverlayOpen) return;
    const handleClickOutside = /* @__PURE__ */ __name((event) => {
      if (overlayRef.current && !overlayRef.current.contains(event.target)) {
        setIsOverlayOpen(false);
      }
    }, "handleClickOutside");
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [isOverlayOpen]);
  (0, import_react6.useEffect)(() => {
    if (isOverlayOpen) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = "";
    }
    return () => {
      document.body.style.overflow = "";
    };
  }, [isOverlayOpen]);
  const handleToggleOverlay = /* @__PURE__ */ __name(() => {
    setIsOverlayOpen(!isOverlayOpen);
  }, "handleToggleOverlay");
  const handleCallTool = /* @__PURE__ */ __name(async () => {
    try {
      setActionResult("Calling tool...");
      const args = toolArgs.trim() ? JSON.parse(toolArgs) : {};
      const result = await callTool(toolName, args);
      setActionResult(`Success: ${JSON.stringify(result, null, 2)}`);
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleCallTool");
  const handleSendFollowUpMessage = /* @__PURE__ */ __name(async () => {
    try {
      setActionResult("Sending follow-up message...");
      await sendFollowUpMessage(followUpMessage);
      setActionResult("Follow-up message sent successfully");
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleSendFollowUpMessage");
  const handleOpenExternal = /* @__PURE__ */ __name(() => {
    try {
      openExternal(externalUrl);
      setActionResult(`Opened external link: ${externalUrl}`);
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleOpenExternal");
  const handleRequestDisplayMode = /* @__PURE__ */ __name(async (mode) => {
    try {
      setActionResult(`Requesting display mode: ${mode}...`);
      const result = await requestDisplayMode(mode);
      setActionResult(`Display mode granted: ${result.mode}`);
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleRequestDisplayMode");
  const handleSetState = /* @__PURE__ */ __name(async () => {
    try {
      const newState = state ? { ...state, debugTimestamp: (/* @__PURE__ */ new Date()).toISOString() } : { debugTimestamp: (/* @__PURE__ */ new Date()).toISOString() };
      setActionResult("Setting state...");
      await setState(newState);
      setActionResult(`State updated: ${JSON.stringify(newState, null, 2)}`);
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleSetState");
  const handleFullscreen = /* @__PURE__ */ __name(async () => {
    try {
      await requestDisplayMode("fullscreen");
    } catch (error) {
      console.error("Failed to go fullscreen:", error);
    }
  }, "handleFullscreen");
  const handlePip = /* @__PURE__ */ __name(async () => {
    try {
      await requestDisplayMode("pip");
    } catch (error) {
      console.error("Failed to go pip:", error);
    }
  }, "handlePip");
  const getTooltipClasses = /* @__PURE__ */ __name(() => {
    const baseClasses = [
      "absolute",
      "px-2",
      "py-1",
      "bg-black/90",
      "text-white",
      "rounded",
      "text-xs",
      "whitespace-nowrap",
      "pointer-events-none",
      "transition-opacity",
      "duration-200",
      "ease-in-out"
    ];
    switch (position) {
      case "top-right":
        return [...baseClasses, "top-full", "right-0", "mt-2"];
      case "top-left":
        return [...baseClasses, "top-full", "left-0", "mt-2"];
      case "top-center":
        return [
          ...baseClasses,
          "top-full",
          "left-1/2",
          "-translate-x-1/2",
          "mt-2"
        ];
      case "bottom-right":
        return [...baseClasses, "bottom-full", "right-0", "mb-2"];
      case "bottom-left":
        return [...baseClasses, "bottom-full", "left-0", "mb-2"];
      case "bottom-center":
        return [
          ...baseClasses,
          "bottom-full",
          "left-1/2",
          "-translate-x-1/2",
          "mb-2"
        ];
      case "center-left":
        return [
          ...baseClasses,
          "left-full",
          "top-1/2",
          "-translate-y-1/2",
          "ml-2"
        ];
      case "center-right":
        return [
          ...baseClasses,
          "right-full",
          "top-1/2",
          "-translate-y-1/2",
          "mr-2"
        ];
      default:
        return [...baseClasses, "top-full", "right-0", "mt-2"];
    }
  }, "getTooltipClasses");
  const IconButton = /* @__PURE__ */ __name(({
    onClick,
    label,
    children: icon
  }) => {
    const [isButtonHovered, setIsButtonHovered] = (0, import_react6.useState)(false);
    const tooltipClasses = getTooltipClasses();
    return /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        className: `p-2 ${isDark ? "bg-white/10 hover:bg-white/20" : "bg-black/70 hover:bg-black/90"} text-white border-none rounded-lg cursor-pointer flex items-center justify-center w-8 h-8 transition-colors duration-200 backdrop-blur-md ${isDark ? "shadow-[0_2px_8px_rgba(0,0,0,0.3)]" : "shadow-[0_2px_8px_rgba(0,0,0,0.2)]"} relative`,
        onMouseEnter: () => setIsButtonHovered(true),
        onMouseLeave: () => setIsButtonHovered(false),
        onClick,
        "aria-label": label
      },
      /* @__PURE__ */ import_react6.default.createElement(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          className: "block"
        },
        icon
      ),
      showLabels && /* @__PURE__ */ import_react6.default.createElement(
        "span",
        {
          className: `${tooltipClasses.join(" ")} ${isButtonHovered ? "opacity-100" : "opacity-0"}`
        },
        label
      )
    );
  }, "IconButton");
  const formatValue = /* @__PURE__ */ __name((value) => {
    if (value === null) return "null";
    if (value === void 0) return "undefined";
    if (typeof value === "object") {
      try {
        return JSON.stringify(value, null, 2);
      } catch {
        return String(value);
      }
    }
    return String(value);
  }, "formatValue");
  const formatUserAgent = /* @__PURE__ */ __name((ua) => {
    if (!ua) return "N/A";
    return `${ua.device?.type || "unknown"}`;
  }, "formatUserAgent");
  const formatSafeArea = /* @__PURE__ */ __name((sa) => {
    if (!sa?.insets) return "N/A";
    const { top, bottom, left, right } = sa.insets;
    return `T:${top} B:${bottom} L:${left} R:${right}`;
  }, "formatSafeArea");
  return /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, /* @__PURE__ */ import_react6.default.createElement(
    "div",
    {
      ref: containerRef,
      className: `${className} relative h-fit`,
      onMouseEnter: () => !attachTo && setIsHovered(true),
      onMouseLeave: () => !attachTo && setIsHovered(false)
    },
    /* @__PURE__ */ import_react6.default.createElement(
      "div",
      {
        className: getPositionClasses().join(" "),
        style: getPositionOffsetStyles()
      },
      !isInInspector && /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, !isFullscreen && !isPip && /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, (viewControls === true || viewControls === "fullscreen") && /* @__PURE__ */ import_react6.default.createElement(IconButton, { onClick: handleFullscreen, label: "Fullscreen" }, /* @__PURE__ */ import_react6.default.createElement("path", { d: "M15 3h6v6" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "m21 3-7 7" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "m3 21 7-7" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M9 21H3v-6" })), (viewControls === true || viewControls === "pip") && /* @__PURE__ */ import_react6.default.createElement(IconButton, { onClick: handlePip, label: "Picture in Picture" }, /* @__PURE__ */ import_react6.default.createElement("path", { d: "M21 9V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v10c0 1.1.9 2 2 2h4" }), /* @__PURE__ */ import_react6.default.createElement("rect", { width: "10", height: "7", x: "12", y: "13", rx: "2" }))), enableDebugger && /* @__PURE__ */ import_react6.default.createElement(IconButton, { onClick: handleToggleOverlay, label: "Debug Info" }, /* @__PURE__ */ import_react6.default.createElement("path", { d: "M12 20v-9" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M14 7a4 4 0 0 1 4 4v3a6 6 0 0 1-12 0v-3a4 4 0 0 1 4-4z" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M14.12 3.88 16 2" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M21 21a4 4 0 0 0-3.81-4" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M21 5a4 4 0 0 1-3.55 3.97" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M22 13h-4" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M3 21a4 4 0 0 1 3.81-4" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M3 5a4 4 0 0 0 3.55 3.97" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M6 13H2" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "m8 2 1.88 1.88" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M9 7.13V6a3 3 0 1 1 6 0v1.13" })))
    ),
    children
  ), isOverlayOpen && enableDebugger && /* @__PURE__ */ import_react6.default.createElement(
    "div",
    {
      ref: overlayRef,
      className: "fixed inset-0 bg-black text-white font-mono text-xs z-[10000] overflow-auto p-4",
      onClick: (e) => {
        if (e.target === overlayRef.current) {
          setIsOverlayOpen(false);
        }
      }
    },
    /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: () => setIsOverlayOpen(false),
        className: "absolute top-4 right-4 bg-white/10 text-white border-none rounded w-8 h-8 cursor-pointer flex items-center justify-center text-lg leading-none",
        "aria-label": "Close"
      },
      "\xD7"
    ),
    /* @__PURE__ */ import_react6.default.createElement("div", { className: "max-w-[1200px] mx-auto pt-10" }, /* @__PURE__ */ import_react6.default.createElement("h1", { className: "text-lg font-bold mb-4 border-b border-gray-700 pb-2" }, "Debug Info"), /* @__PURE__ */ import_react6.default.createElement("table", { className: "w-full border-collapse border-spacing-0" }, /* @__PURE__ */ import_react6.default.createElement("tbody", null, /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Props"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 whitespace-pre-wrap break-all" }, formatValue(props))), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Output"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 whitespace-pre-wrap break-all" }, formatValue(output))), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Metadata"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 whitespace-pre-wrap break-all" }, formatValue(metadata))), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "State"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 whitespace-pre-wrap break-all" }, formatValue(state))), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Theme"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2" }, theme)), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Display Mode"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2" }, displayMode)), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Locale"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2" }, locale)), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Max Height"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2" }, maxHeight, "px")), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "User Agent"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2" }, formatUserAgent(userAgent))), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Safe Area"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2" }, formatSafeArea(safeArea))), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "API Available"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2" }, isAvailable ? "Yes" : "No")), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "window.openai Keys"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2" }, windowOpenAiKeys.length > 0 ? windowOpenAiKeys.join(", ") : "N/A")))), /* @__PURE__ */ import_react6.default.createElement("h2", { className: "text-base font-bold mt-8 mb-4 border-b border-gray-700 pb-2" }, "Actions"), /* @__PURE__ */ import_react6.default.createElement("div", { className: "flex flex-col gap-3" }, /* @__PURE__ */ import_react6.default.createElement("div", { className: "flex gap-2 items-center" }, /* @__PURE__ */ import_react6.default.createElement(
      "input",
      {
        type: "text",
        value: toolName,
        onChange: (e) => setToolName(e.target.value),
        placeholder: "Tool name",
        className: "py-1.5 px-2 bg-[#1a1a1a] text-white border border-gray-700 rounded font-mono text-xs w-[150px]"
      }
    ), /* @__PURE__ */ import_react6.default.createElement(
      "input",
      {
        type: "text",
        value: toolArgs,
        onChange: (e) => setToolArgs(e.target.value),
        placeholder: '{"key": "value"}',
        className: "py-1.5 px-2 bg-[#1a1a1a] text-white border border-gray-700 rounded font-mono text-xs flex-1"
      }
    ), /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: handleCallTool,
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs"
      },
      "Call Tool"
    )), /* @__PURE__ */ import_react6.default.createElement("div", { className: "flex gap-2 items-center" }, /* @__PURE__ */ import_react6.default.createElement(
      "input",
      {
        type: "text",
        value: followUpMessage,
        onChange: (e) => setFollowUpMessage(e.target.value),
        placeholder: "Follow-up message",
        className: "py-1.5 px-2 bg-[#1a1a1a] text-white border border-gray-700 rounded font-mono text-xs flex-1"
      }
    ), /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: handleSendFollowUpMessage,
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs"
      },
      "Send Follow-Up"
    )), /* @__PURE__ */ import_react6.default.createElement("div", { className: "flex gap-2 items-center" }, /* @__PURE__ */ import_react6.default.createElement(
      "input",
      {
        type: "text",
        value: externalUrl,
        onChange: (e) => setExternalUrl(e.target.value),
        placeholder: "External URL",
        className: "py-1.5 px-2 bg-[#1a1a1a] text-white border border-gray-700 rounded font-mono text-xs flex-1"
      }
    ), /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: handleOpenExternal,
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs"
      },
      "Open Link"
    )), /* @__PURE__ */ import_react6.default.createElement("div", { className: "flex gap-2 items-center" }, /* @__PURE__ */ import_react6.default.createElement("span", { className: "w-[150px] text-xs" }, "Display Mode:"), /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: () => handleRequestDisplayMode("inline"),
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs flex-1"
      },
      "Inline"
    ), /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: () => handleRequestDisplayMode("pip"),
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs flex-1"
      },
      "PiP"
    ), /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: () => handleRequestDisplayMode("fullscreen"),
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs flex-1"
      },
      "Fullscreen"
    )), /* @__PURE__ */ import_react6.default.createElement("div", { className: "flex gap-2 items-center" }, /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: handleSetState,
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs"
      },
      "Set State (Add Timestamp)"
    )), actionResult && /* @__PURE__ */ import_react6.default.createElement("div", { className: "mt-2 p-2 bg-[#1a1a1a] border border-gray-700 rounded whitespace-pre-wrap break-all text-[11px] max-h-[200px] overflow-auto" }, /* @__PURE__ */ import_react6.default.createElement("div", { className: "font-bold mb-1 text-gray-400" }, "Result:"), actionResult, /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: () => setActionResult(""),
        className: "mt-2 py-1 px-2 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-[11px]"
      },
      "Clear"
    ))))
  ));
}
__name(WidgetControls, "WidgetControls");

// src/react/McpUseProvider.tsx
var import_react7 = __toESM(require("react"), 1);
function getBasename() {
  if (typeof window === "undefined") return "/";
  const path = window.location.pathname;
  const match = path.match(/^(\/inspector\/api\/dev-widget\/[^/]+)/);
  if (match) {
    return match[1];
  }
  return "/";
}
__name(getBasename, "getBasename");
var HEIGHT_DEBOUNCE_MS = 150;
var MIN_HEIGHT_CHANGE_PX = 5;
function McpUseProvider({
  children,
  debugger: enableDebugger = false,
  viewControls = false,
  autoSize = false
}) {
  const basename = getBasename();
  const containerRef = (0, import_react7.useRef)(null);
  const lastHeightRef = (0, import_react7.useRef)(0);
  const debounceTimeoutRef = (0, import_react7.useRef)(null);
  const notificationInProgressRef = (0, import_react7.useRef)(false);
  const [BrowserRouter, setBrowserRouter] = (0, import_react7.useState)(null);
  const [routerError, setRouterError] = (0, import_react7.useState)(null);
  const [isRouterLoading, setIsRouterLoading] = (0, import_react7.useState)(true);
  (0, import_react7.useEffect)(() => {
    let mounted = true;
    (async () => {
      try {
        const routerModule = await import("react-router");
        if (mounted) {
          setBrowserRouter(() => routerModule.BrowserRouter);
          setIsRouterLoading(false);
        }
      } catch (error) {
        if (mounted) {
          setRouterError(
            new Error(
              "\u274C react-router not installed!\n\nTo use MCP widgets with McpUseProvider, you need to install:\n\n  npm install react-router\n  # or\n  pnpm add react-router\n\nThis dependency is automatically included in projects created with 'create-mcp-use-app'."
            )
          );
          setIsRouterLoading(false);
        }
      }
    })();
    return () => {
      mounted = false;
    };
  }, []);
  const notifyHeight = (0, import_react7.useCallback)((height) => {
    if (typeof window !== "undefined" && window.openai?.notifyIntrinsicHeight) {
      notificationInProgressRef.current = true;
      window.openai.notifyIntrinsicHeight(height).then(() => {
        notificationInProgressRef.current = false;
      }).catch((error) => {
        notificationInProgressRef.current = false;
        console.error(
          "[McpUseProvider] Failed to notify intrinsic height:",
          error
        );
      });
    }
  }, []);
  const debouncedNotifyHeight = (0, import_react7.useCallback)(
    (height) => {
      if (debounceTimeoutRef.current) {
        clearTimeout(debounceTimeoutRef.current);
      }
      debounceTimeoutRef.current = setTimeout(() => {
        const heightDiff = Math.abs(height - lastHeightRef.current);
        if (heightDiff >= MIN_HEIGHT_CHANGE_PX && height > 0) {
          lastHeightRef.current = height;
          notifyHeight(height);
        }
      }, HEIGHT_DEBOUNCE_MS);
    },
    [notifyHeight]
  );
  (0, import_react7.useEffect)(() => {
    if (!autoSize) {
      return;
    }
    const container = containerRef.current;
    if (!container || typeof ResizeObserver === "undefined") {
      return;
    }
    const observer = new ResizeObserver((entries) => {
      if (notificationInProgressRef.current) {
        return;
      }
      for (const entry of entries) {
        const height = entry.contentRect.height;
        const scrollHeight = entry.target.scrollHeight;
        const intrinsicHeight = Math.max(height, scrollHeight);
        debouncedNotifyHeight(intrinsicHeight);
      }
    });
    observer.observe(container);
    const initialHeight = Math.max(
      container.offsetHeight,
      container.scrollHeight
    );
    if (initialHeight > 0) {
      debouncedNotifyHeight(initialHeight);
    }
    return () => {
      observer.disconnect();
      if (debounceTimeoutRef.current) {
        clearTimeout(debounceTimeoutRef.current);
        debounceTimeoutRef.current = null;
      }
      notificationInProgressRef.current = false;
    };
  }, [autoSize, debouncedNotifyHeight]);
  if (isRouterLoading) {
    return /* @__PURE__ */ import_react7.default.createElement(import_react7.StrictMode, null, /* @__PURE__ */ import_react7.default.createElement(ThemeProvider, null, /* @__PURE__ */ import_react7.default.createElement("div", { style: { padding: "20px", textAlign: "center" } }, "Loading...")));
  }
  if (routerError) {
    throw routerError;
  }
  let content = children;
  content = /* @__PURE__ */ import_react7.default.createElement(ErrorBoundary, null, content);
  if (enableDebugger || viewControls) {
    content = /* @__PURE__ */ import_react7.default.createElement(WidgetControls, { debugger: enableDebugger, viewControls }, content);
  }
  if (BrowserRouter) {
    content = /* @__PURE__ */ import_react7.default.createElement(BrowserRouter, { basename }, content);
  }
  content = /* @__PURE__ */ import_react7.default.createElement(ThemeProvider, null, content);
  if (autoSize) {
    const containerStyle = {
      width: "100%",
      minHeight: 0
    };
    content = /* @__PURE__ */ import_react7.default.createElement("div", { ref: containerRef, style: containerStyle }, content);
  }
  return /* @__PURE__ */ import_react7.default.createElement(import_react7.StrictMode, null, content);
}
__name(McpUseProvider, "McpUseProvider");
